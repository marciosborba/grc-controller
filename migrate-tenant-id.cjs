#!/usr/bin/env node\n\n/**\n * üö® MIGRA√á√ÉO CR√çTICA: Adicionar tenant_id √†s tabelas\n * \n * Este script executa a migra√ß√£o cr√≠tica para adicionar tenant_id\n * em todas as tabelas que precisam de isolamento multi-tenant.\n * \n * ATEN√á√ÉO: Execute apenas ap√≥s fazer backup do banco!\n * \n * Uso: node migrate-tenant-id.cjs [--dry-run] [--force]\n */\n\nconst { Client } = require('pg');\nrequire('dotenv').config();\n\nclass TenantMigration {\n  constructor(options = {}) {\n    this.dryRun = options.dryRun || false;\n    this.force = options.force || false;\n    \n    // Configura√ß√£o da conex√£o PostgreSQL\n    this.config = {\n      host: 'db.myxvxponlmulnjstbjwd.supabase.co',\n      port: 5432,\n      database: 'postgres',\n      user: 'postgres',\n      password: process.env.SUPABASE_DB_PASSWORD,\n      ssl: { rejectUnauthorized: false }\n    };\n    \n    this.client = null;\n    \n    // Tabelas que precisam de tenant_id\n    this.criticalTables = [\n      'audits',\n      'audit_findings',\n      'audit_attachments',\n      'audit_action_items',\n      'audit_team_members',\n      'audit_reports',\n      'activity_logs',\n      'ai_chat_logs'\n    ];\n    \n    this.importantTables = [\n      'frameworks',\n      'framework_controls',\n      'compliance_records',\n      'controls',\n      'user_roles',\n      'ai_grc_prompt_templates'\n    ];\n    \n    this.allTables = [...this.criticalTables, ...this.importantTables];\n  }\n\n  async connect() {\n    try {\n      this.client = new Client(this.config);\n      await this.client.connect();\n      console.log('üîó Conectado ao PostgreSQL do Supabase');\n      return true;\n    } catch (error) {\n      console.error('‚ùå Erro ao conectar:', error.message);\n      return false;\n    }\n  }\n\n  async disconnect() {\n    if (this.client) {\n      await this.client.end();\n      console.log('üîå Desconectado do PostgreSQL');\n    }\n  }\n\n  async executeSQL(sql, description = '') {\n    if (this.dryRun) {\n      console.log(`üîç [DRY RUN] ${description}:`);\n      console.log(`   ${sql}`);\n      return { rowCount: 0 };\n    }\n    \n    try {\n      console.log(`üîß Executando: ${description}`);\n      const result = await this.client.query(sql);\n      console.log(`‚úÖ Sucesso: ${result.rowCount || 0} linhas afetadas`);\n      return result;\n    } catch (error) {\n      console.error(`‚ùå Erro SQL: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async columnExists(tableName, columnName) {\n    const sql = `\n      SELECT EXISTS (\n        SELECT FROM information_schema.columns \n        WHERE table_name = $1 AND column_name = $2\n      );\n    `;\n    const result = await this.client.query(sql, [tableName, columnName]);\n    return result.rows[0].exists;\n  }\n\n  async tableExists(tableName) {\n    const sql = `\n      SELECT EXISTS (\n        SELECT FROM information_schema.tables \n        WHERE table_name = $1\n      );\n    `;\n    const result = await this.client.query(sql, [tableName]);\n    return result.rows[0].exists;\n  }\n\n  async getDefaultTenantId() {\n    const result = await this.client.query('SELECT id FROM tenants ORDER BY created_at LIMIT 1');\n    if (result.rows.length === 0) {\n      throw new Error('Nenhum tenant encontrado. Crie pelo menos um tenant antes de executar a migra√ß√£o.');\n    }\n    return result.rows[0].id;\n  }\n\n  async checkPrerequisites() {\n    console.log('üîç Verificando pr√©-requisitos...');\n    \n    // Verificar se tabela tenants existe\n    const tenantsExists = await this.tableExists('tenants');\n    if (!tenantsExists) {\n      throw new Error('Tabela tenants n√£o encontrada!');\n    }\n    \n    // Verificar se h√° pelo menos um tenant\n    const tenantCount = await this.client.query('SELECT COUNT(*) FROM tenants');\n    if (parseInt(tenantCount.rows[0].count) === 0) {\n      throw new Error('Nenhum tenant encontrado. Crie pelo menos um tenant primeiro.');\n    }\n    \n    console.log(`‚úÖ Encontrados ${tenantCount.rows[0].count} tenants`);\n    \n    // Verificar quais tabelas existem\n    const existingTables = [];\n    const missingTables = [];\n    \n    for (const table of this.allTables) {\n      const exists = await this.tableExists(table);\n      if (exists) {\n        existingTables.push(table);\n      } else {\n        missingTables.push(table);\n      }\n    }\n    \n    console.log(`‚úÖ Tabelas encontradas: ${existingTables.length}`);\n    if (missingTables.length > 0) {\n      console.log(`‚ö†Ô∏è  Tabelas n√£o encontradas: ${missingTables.join(', ')}`);\n    }\n    \n    return existingTables;\n  }\n\n  async addTenantIdColumns(tables) {\n    console.log('\\nüìã FASE 1: Adicionando colunas tenant_id...');\n    \n    for (const table of tables) {\n      const exists = await this.columnExists(table, 'tenant_id');\n      if (exists) {\n        console.log(`‚úÖ Coluna tenant_id j√° existe na tabela ${table}`);\n        continue;\n      }\n      \n      const sql = `ALTER TABLE ${table} ADD COLUMN tenant_id UUID REFERENCES tenants(id);`;\n      await this.executeSQL(sql, `Adicionando tenant_id √† tabela ${table}`);\n    }\n  }\n\n  async migrateExistingData(tables) {\n    console.log('\\nüîÑ FASE 2: Migrando dados existentes...');\n    \n    const defaultTenantId = await this.getDefaultTenantId();\n    console.log(`üìå Usando tenant padr√£o: ${defaultTenantId}`);\n    \n    for (const table of tables) {\n      // Verificar se h√° dados sem tenant_id\n      const countResult = await this.client.query(`SELECT COUNT(*) FROM ${table} WHERE tenant_id IS NULL`);\n      const orphanCount = parseInt(countResult.rows[0].count);\n      \n      if (orphanCount === 0) {\n        console.log(`‚úÖ Tabela ${table}: Nenhum registro √≥rf√£o`);\n        continue;\n      }\n      \n      console.log(`üîÑ Tabela ${table}: ${orphanCount} registros √≥rf√£os`);\n      \n      // Estrat√©gias espec√≠ficas por tabela\n      if (table === 'audit_findings') {\n        // Migrar baseado na auditoria pai\n        await this.executeSQL(`\n          UPDATE audit_findings \n          SET tenant_id = (\n            SELECT a.tenant_id \n            FROM audits a \n            WHERE a.id = audit_findings.audit_id\n          )\n          WHERE tenant_id IS NULL AND audit_id IS NOT NULL;\n        `, `Migrando ${table} baseado na auditoria pai`);\n        \n        // √ìrf√£os restantes\n        await this.executeSQL(`\n          UPDATE audit_findings \n          SET tenant_id = '${defaultTenantId}' \n          WHERE tenant_id IS NULL;\n        `, `Migrando ${table} √≥rf√£os para tenant padr√£o`);\n        \n      } else if (table === 'audit_attachments') {\n        // Migrar baseado na auditoria pai\n        await this.executeSQL(`\n          UPDATE audit_attachments \n          SET tenant_id = (\n            SELECT a.tenant_id \n            FROM audits a \n            WHERE a.id = audit_attachments.audit_id\n          )\n          WHERE tenant_id IS NULL AND audit_id IS NOT NULL;\n        `, `Migrando ${table} baseado na auditoria pai`);\n        \n        // √ìrf√£os restantes\n        await this.executeSQL(`\n          UPDATE audit_attachments \n          SET tenant_id = '${defaultTenantId}' \n          WHERE tenant_id IS NULL;\n        `, `Migrando ${table} √≥rf√£os para tenant padr√£o`);\n        \n      } else if (table === 'audit_action_items') {\n        // Migrar baseado no finding pai\n        await this.executeSQL(`\n          UPDATE audit_action_items \n          SET tenant_id = (\n            SELECT af.tenant_id \n            FROM audit_findings af \n            WHERE af.id = audit_action_items.finding_id\n          )\n          WHERE tenant_id IS NULL AND finding_id IS NOT NULL;\n        `, `Migrando ${table} baseado no finding pai`);\n        \n        // √ìrf√£os restantes\n        await this.executeSQL(`\n          UPDATE audit_action_items \n          SET tenant_id = '${defaultTenantId}' \n          WHERE tenant_id IS NULL;\n        `, `Migrando ${table} √≥rf√£os para tenant padr√£o`);\n        \n      } else if (table === 'audit_team_members') {\n        // Migrar baseado na auditoria pai\n        await this.executeSQL(`\n          UPDATE audit_team_members \n          SET tenant_id = (\n            SELECT a.tenant_id \n            FROM audits a \n            WHERE a.id = audit_team_members.audit_id\n          )\n          WHERE tenant_id IS NULL AND audit_id IS NOT NULL;\n        `, `Migrando ${table} baseado na auditoria pai`);\n        \n        // √ìrf√£os restantes\n        await this.executeSQL(`\n          UPDATE audit_team_members \n          SET tenant_id = '${defaultTenantId}' \n          WHERE tenant_id IS NULL;\n        `, `Migrando ${table} √≥rf√£os para tenant padr√£o`);\n        \n      } else if (table === 'activity_logs' || table === 'ai_chat_logs' || table === 'user_roles') {\n        // Migrar baseado no user_id\n        await this.executeSQL(`\n          UPDATE ${table} \n          SET tenant_id = (\n            SELECT p.tenant_id \n            FROM profiles p \n            WHERE p.user_id = ${table}.user_id\n          )\n          WHERE tenant_id IS NULL AND user_id IS NOT NULL;\n        `, `Migrando ${table} baseado no user_id`);\n        \n        // √ìrf√£os restantes\n        await this.executeSQL(`\n          UPDATE ${table} \n          SET tenant_id = '${defaultTenantId}' \n          WHERE tenant_id IS NULL;\n        `, `Migrando ${table} √≥rf√£os para tenant padr√£o`);\n        \n      } else {\n        // Migra√ß√£o simples para tenant padr√£o\n        await this.executeSQL(`\n          UPDATE ${table} \n          SET tenant_id = '${defaultTenantId}' \n          WHERE tenant_id IS NULL;\n        `, `Migrando ${table} para tenant padr√£o`);\n      }\n    }\n  }\n\n  async duplicateSharedData(tables) {\n    console.log('\\nüìã FASE 3: Duplicando dados compartilhados...');\n    \n    const sharedTables = ['frameworks', 'framework_controls', 'compliance_records', 'controls', 'ai_grc_prompt_templates'];\n    const tablesToDuplicate = tables.filter(t => sharedTables.includes(t));\n    \n    if (tablesToDuplicate.length === 0) {\n      console.log('‚úÖ Nenhuma tabela compartilhada para duplicar');\n      return;\n    }\n    \n    // Obter todos os tenants\n    const tenantsResult = await this.client.query('SELECT id, name FROM tenants ORDER BY created_at');\n    const tenants = tenantsResult.rows;\n    \n    console.log(`üìå Duplicando para ${tenants.length} tenants`);\n    \n    for (const table of tablesToDuplicate) {\n      console.log(`üîÑ Processando tabela ${table}...`);\n      \n      // Verificar se h√° dados √≥rf√£os para duplicar\n      const orphanResult = await this.client.query(`SELECT COUNT(*) FROM ${table} WHERE tenant_id IS NULL`);\n      const orphanCount = parseInt(orphanResult.rows[0].count);\n      \n      if (orphanCount === 0) {\n        console.log(`‚úÖ Tabela ${table}: Nenhum dado √≥rf√£o para duplicar`);\n        continue;\n      }\n      \n      console.log(`üìã Tabela ${table}: ${orphanCount} registros √≥rf√£os para duplicar`);\n      \n      // Duplicar para cada tenant\n      for (const tenant of tenants) {\n        if (table === 'frameworks') {\n          await this.executeSQL(`\n            INSERT INTO frameworks (\n              id, name, description, version, is_active, \n              created_at, updated_at, tenant_id\n            )\n            SELECT \n              gen_random_uuid(),\n              name,\n              description,\n              version,\n              is_active,\n              created_at,\n              NOW(),\n              '${tenant.id}'\n            FROM frameworks \n            WHERE tenant_id IS NULL;\n          `, `Duplicando frameworks para tenant ${tenant.name}`);\n          \n        } else if (table === 'controls') {\n          await this.executeSQL(`\n            INSERT INTO controls (\n              id, control_id, title, description, control_type,\n              implementation_status, effectiveness, created_at, updated_at,\n              tenant_id\n            )\n            SELECT \n              gen_random_uuid(),\n              control_id,\n              title,\n              description,\n              control_type,\n              implementation_status,\n              effectiveness,\n              created_at,\n              NOW(),\n              '${tenant.id}'\n            FROM controls \n            WHERE tenant_id IS NULL;\n          `, `Duplicando controls para tenant ${tenant.name}`);\n          \n        } else if (table === 'compliance_records') {\n          await this.executeSQL(`\n            INSERT INTO compliance_records (\n              id, control_id, framework, control_description,\n              compliance_status, created_at, updated_at, tenant_id\n            )\n            SELECT \n              gen_random_uuid(),\n              control_id,\n              framework,\n              control_description,\n              compliance_status,\n              created_at,\n              NOW(),\n              '${tenant.id}'\n            FROM compliance_records \n            WHERE tenant_id IS NULL;\n          `, `Duplicando compliance_records para tenant ${tenant.name}`);\n          \n        } else if (table === 'ai_grc_prompt_templates') {\n          await this.executeSQL(`\n            INSERT INTO ai_grc_prompt_templates (\n              id, name, title, description, category, use_case,\n              template_content, is_active, is_global, is_public,\n              created_at, updated_at, tenant_id\n            )\n            SELECT \n              gen_random_uuid(),\n              name,\n              title,\n              description,\n              category,\n              use_case,\n              template_content,\n              is_active,\n              false,\n              false,\n              created_at,\n              NOW(),\n              '${tenant.id}'\n            FROM ai_grc_prompt_templates \n            WHERE tenant_id IS NULL;\n          `, `Duplicando ai_grc_prompt_templates para tenant ${tenant.name}`);\n        }\n      }\n      \n      // Remover registros √≥rf√£os originais\n      if (!this.dryRun) {\n        await this.executeSQL(`\n          DELETE FROM ${table} WHERE tenant_id IS NULL;\n        `, `Removendo registros √≥rf√£os originais de ${table}`);\n      }\n    }\n  }\n\n  async makeColumnsRequired(tables) {\n    console.log('\\nüîí FASE 4: Tornando tenant_id obrigat√≥rio...');\n    \n    for (const table of tables) {\n      // Verificar se ainda h√° registros sem tenant_id\n      const orphanResult = await this.client.query(`SELECT COUNT(*) FROM ${table} WHERE tenant_id IS NULL`);\n      const orphanCount = parseInt(orphanResult.rows[0].count);\n      \n      if (orphanCount > 0) {\n        console.error(`‚ùå Tabela ${table} ainda tem ${orphanCount} registros sem tenant_id`);\n        throw new Error(`Migra√ß√£o incompleta na tabela ${table}`);\n      }\n      \n      await this.executeSQL(`\n        ALTER TABLE ${table} ALTER COLUMN tenant_id SET NOT NULL;\n      `, `Tornando tenant_id obrigat√≥rio na tabela ${table}`);\n    }\n  }\n\n  async createIndexes(tables) {\n    console.log('\\n‚ö° FASE 5: Criando √≠ndices para performance...');\n    \n    const indexes = [\n      { table: 'audits', columns: 'tenant_id, status', name: 'idx_audits_tenant_status' },\n      { table: 'audit_findings', columns: 'tenant_id, status', name: 'idx_audit_findings_tenant_status' },\n      { table: 'activity_logs', columns: 'tenant_id, created_at DESC', name: 'idx_activity_logs_tenant_created' },\n      { table: 'frameworks', columns: 'tenant_id, is_active', name: 'idx_frameworks_tenant_active' },\n      { table: 'user_roles', columns: 'tenant_id, user_id', name: 'idx_user_roles_tenant_user' }\n    ];\n    \n    for (const index of indexes) {\n      if (!tables.includes(index.table)) continue;\n      \n      await this.executeSQL(`\n        CREATE INDEX IF NOT EXISTS ${index.name} ON ${index.table}(${index.columns});\n      `, `Criando √≠ndice ${index.name}`);\n    }\n  }\n\n  async implementRLS(tables) {\n    console.log('\\nüõ°Ô∏è  FASE 6: Implementando Row Level Security...');\n    \n    for (const table of tables) {\n      // Habilitar RLS\n      await this.executeSQL(`\n        ALTER TABLE ${table} ENABLE ROW LEVEL SECURITY;\n      `, `Habilitando RLS na tabela ${table}`);\n      \n      // Criar pol√≠tica de isolamento\n      await this.executeSQL(`\n        CREATE POLICY tenant_isolation_${table} ON ${table}\n          FOR ALL TO authenticated\n          USING (tenant_id = current_setting('app.current_tenant')::uuid);\n      `, `Criando pol√≠tica de isolamento para ${table}`);\n    }\n  }\n\n  async validateMigration(tables) {\n    console.log('\\n‚úÖ FASE 7: Validando migra√ß√£o...');\n    \n    let allValid = true;\n    \n    for (const table of tables) {\n      // Verificar se coluna existe e √© NOT NULL\n      const columnInfo = await this.client.query(`\n        SELECT is_nullable \n        FROM information_schema.columns \n        WHERE table_name = $1 AND column_name = 'tenant_id'\n      `, [table]);\n      \n      if (columnInfo.rows.length === 0) {\n        console.error(`‚ùå Tabela ${table}: Coluna tenant_id n√£o encontrada`);\n        allValid = false;\n        continue;\n      }\n      \n      const isNullable = columnInfo.rows[0].is_nullable === 'YES';\n      if (isNullable) {\n        console.error(`‚ùå Tabela ${table}: Coluna tenant_id ainda permite NULL`);\n        allValid = false;\n        continue;\n      }\n      \n      // Verificar se h√° registros √≥rf√£os\n      const orphanResult = await this.client.query(`SELECT COUNT(*) FROM ${table} WHERE tenant_id IS NULL`);\n      const orphanCount = parseInt(orphanResult.rows[0].count);\n      \n      if (orphanCount > 0) {\n        console.error(`‚ùå Tabela ${table}: ${orphanCount} registros √≥rf√£os encontrados`);\n        allValid = false;\n        continue;\n      }\n      \n      // Verificar se RLS est√° habilitado\n      const rlsResult = await this.client.query(`\n        SELECT relrowsecurity \n        FROM pg_class \n        WHERE relname = $1\n      `, [table]);\n      \n      if (rlsResult.rows.length === 0 || !rlsResult.rows[0].relrowsecurity) {\n        console.error(`‚ùå Tabela ${table}: RLS n√£o est√° habilitado`);\n        allValid = false;\n        continue;\n      }\n      \n      console.log(`‚úÖ Tabela ${table}: Valida√ß√£o OK`);\n    }\n    \n    return allValid;\n  }\n\n  async run() {\n    console.log('üö® INICIANDO MIGRA√á√ÉO CR√çTICA: Adicionar tenant_id √†s tabelas');\n    console.log('=' .repeat(70));\n    \n    if (this.dryRun) {\n      console.log('üîç MODO DRY RUN: Nenhuma altera√ß√£o ser√° feita no banco');\n    }\n    \n    if (!this.force && !this.dryRun) {\n      console.log('‚ö†Ô∏è  ATEN√á√ÉO: Esta migra√ß√£o far√° altera√ß√µes permanentes no banco!');\n      console.log('üí° Use --dry-run para simular ou --force para confirmar');\n      return false;\n    }\n    \n    try {\n      // Conectar ao banco\n      const connected = await this.connect();\n      if (!connected) {\n        throw new Error('Falha na conex√£o com o banco');\n      }\n      \n      // Verificar pr√©-requisitos\n      const existingTables = await this.checkPrerequisites();\n      \n      if (existingTables.length === 0) {\n        console.log('‚ö†Ô∏è  Nenhuma tabela encontrada para migra√ß√£o');\n        return true;\n      }\n      \n      // Executar migra√ß√£o em fases\n      await this.addTenantIdColumns(existingTables);\n      await this.migrateExistingData(existingTables);\n      await this.duplicateSharedData(existingTables);\n      \n      if (!this.dryRun) {\n        await this.makeColumnsRequired(existingTables);\n        await this.createIndexes(existingTables);\n        await this.implementRLS(existingTables);\n        \n        // Validar migra√ß√£o\n        const isValid = await this.validateMigration(existingTables);\n        if (!isValid) {\n          throw new Error('Valida√ß√£o da migra√ß√£o falhou');\n        }\n      }\n      \n      console.log('\\nüéâ MIGRA√á√ÉO CONCLU√çDA COM SUCESSO! üéâ');\n      console.log('=' .repeat(70));\n      console.log('‚úÖ Todas as tabelas agora t√™m isolamento por tenant');\n      console.log('‚úÖ Row Level Security implementado');\n      console.log('‚úÖ √çndices criados para performance');\n      console.log('\\nüìã Pr√≥ximos passos:');\n      console.log('1. Atualizar o c√≥digo da aplica√ß√£o para usar tenant_id');\n      console.log('2. Testar isolamento entre tenants');\n      console.log('3. Atualizar documenta√ß√£o');\n      \n      return true;\n      \n    } catch (error) {\n      console.error('\\n‚ùå ERRO DURANTE A MIGRA√á√ÉO:', error.message);\n      console.error('üí° Verifique os logs acima para detalhes');\n      return false;\n    } finally {\n      await this.disconnect();\n    }\n  }\n}\n\n// CLI Interface\nasync function main() {\n  const args = process.argv.slice(2);\n  const dryRun = args.includes('--dry-run');\n  const force = args.includes('--force');\n  const help = args.includes('--help') || args.includes('-h');\n  \n  if (help) {\n    console.log(`\nüö® Migra√ß√£o Cr√≠tica: Adicionar tenant_id √†s tabelas\n\nüìã Uso:\n  node migrate-tenant-id.cjs [op√ß√µes]\n\nüîß Op√ß√µes:\n  --dry-run    Simular migra√ß√£o sem fazer altera√ß√µes\n  --force      Executar migra√ß√£o (OBRIGAT√ìRIO para execu√ß√£o real)\n  --help, -h   Mostrar esta ajuda\n\nüìù Exemplos:\n  node migrate-tenant-id.cjs --dry-run     # Simular migra√ß√£o\n  node migrate-tenant-id.cjs --force       # Executar migra√ß√£o\n\n‚ö†Ô∏è  ATEN√á√ÉO:\n  - Fa√ßa backup do banco antes de executar\n  - Use --dry-run primeiro para verificar\n  - Esta migra√ß√£o √© irrevers√≠vel\n  - Certifique-se de ter SUPABASE_DB_PASSWORD no .env\n    `);\n    return;\n  }\n  \n  const migration = new TenantMigration({ dryRun, force });\n  const success = await migration.run();\n  \n  process.exit(success ? 0 : 1);\n}\n\n// Executar apenas se chamado diretamente\nif (require.main === module) {\n  main().catch(console.error);\n}\n\nmodule.exports = TenantMigration;"