#!/usr/bin/env node\n\n/**\n * ğŸ›¡ï¸ Security Monitor - GRC Controller\n * \n * Sistema de monitoramento de seguranÃ§a em tempo real\n * \n * Funcionalidades:\n * - Monitorar tentativas de acesso\n * - Detectar atividades suspeitas\n * - Gerar alertas de seguranÃ§a\n * - RelatÃ³rios de auditoria\n * - Dashboard de seguranÃ§a\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\n\nclass SecurityMonitor {\n  constructor() {\n    this.logDir = 'logs';\n    this.auditLog = path.join(this.logDir, 'database-audit.log');\n    this.securityLog = path.join(this.logDir, 'security-events.log');\n    this.alertsLog = path.join(this.logDir, 'security-alerts.log');\n    \n    this.thresholds = {\n      maxFailedLogins: 5,\n      maxConnectionsPerMinute: 10,\n      suspiciousCommandsThreshold: 3,\n      timeWindow: 300000 // 5 minutos\n    };\n    \n    this.suspiciousPatterns = [\n      /DROP\\s+TABLE/i,\n      /DELETE\\s+FROM/i,\n      /TRUNCATE/i,\n      /ALTER\\s+USER/i,\n      /GRANT\\s+ALL/i,\n      /UNION\\s+SELECT/i,\n      /--\\s*$/,\n      /\\/\\*.*\\*\\//\n    ];\n    \n    this.events = [];\n    this.alerts = [];\n  }\n\n  /**\n   * Iniciar monitoramento\n   */\n  start() {\n    console.log('ğŸ›¡ï¸ Iniciando Security Monitor...');\n    \n    // Criar diretÃ³rio de logs se nÃ£o existir\n    if (!fs.existsSync(this.logDir)) {\n      fs.mkdirSync(this.logDir, { recursive: true });\n    }\n    \n    // Monitorar logs existentes\n    this.loadExistingLogs();\n    \n    // Iniciar monitoramento em tempo real\n    this.startRealTimeMonitoring();\n    \n    console.log('âœ… Security Monitor ativo');\n    console.log(`ğŸ“Š Monitorando: ${this.auditLog}`);\n    console.log(`ğŸš¨ Alertas em: ${this.alertsLog}`);\n  }\n\n  /**\n   * Carregar logs existentes\n   */\n  loadExistingLogs() {\n    try {\n      if (fs.existsSync(this.auditLog)) {\n        const logContent = fs.readFileSync(this.auditLog, 'utf8');\n        const lines = logContent.trim().split('\\n').filter(line => line.trim());\n        \n        lines.forEach(line => {\n          try {\n            const event = JSON.parse(line);\n            this.processEvent(event);\n          } catch (error) {\n            // Ignorar linhas malformadas\n          }\n        });\n        \n        console.log(`ğŸ“‹ ${lines.length} eventos carregados do log`);\n      }\n    } catch (error) {\n      console.error('âŒ Erro ao carregar logs existentes:', error.message);\n    }\n  }\n\n  /**\n   * Iniciar monitoramento em tempo real\n   */\n  startRealTimeMonitoring() {\n    if (!fs.existsSync(this.auditLog)) {\n      console.log('âš ï¸  Arquivo de audit log nÃ£o encontrado, criando...');\n      fs.writeFileSync(this.auditLog, '');\n    }\n    \n    // Monitorar mudanÃ§as no arquivo de log\n    fs.watchFile(this.auditLog, (curr, prev) => {\n      if (curr.mtime > prev.mtime) {\n        this.processNewLogEntries();\n      }\n    });\n  }\n\n  /**\n   * Processar novas entradas do log\n   */\n  processNewLogEntries() {\n    try {\n      const logContent = fs.readFileSync(this.auditLog, 'utf8');\n      const lines = logContent.trim().split('\\n').filter(line => line.trim());\n      \n      // Processar apenas as Ãºltimas linhas (novas)\n      const newLines = lines.slice(this.events.length);\n      \n      newLines.forEach(line => {\n        try {\n          const event = JSON.parse(line);\n          this.processEvent(event);\n        } catch (error) {\n          // Ignorar linhas malformadas\n        }\n      });\n    } catch (error) {\n      console.error('âŒ Erro ao processar novas entradas:', error.message);\n    }\n  }\n\n  /**\n   * Processar evento de seguranÃ§a\n   */\n  processEvent(event) {\n    this.events.push(event);\n    \n    // Analisar evento\n    this.analyzeEvent(event);\n    \n    // Detectar padrÃµes suspeitos\n    this.detectSuspiciousActivity(event);\n    \n    // Verificar thresholds\n    this.checkThresholds();\n  }\n\n  /**\n   * Analisar evento individual\n   */\n  analyzeEvent(event) {\n    const analysis = {\n      timestamp: event.timestamp,\n      level: event.level,\n      user: event.user,\n      riskLevel: 'LOW',\n      reasons: []\n    };\n    \n    // Verificar nÃ­vel de log\n    if (event.level === 'ERROR') {\n      analysis.riskLevel = 'MEDIUM';\n      analysis.reasons.push('Error level event');\n    }\n    \n    // Verificar comandos suspeitos\n    if (event.data && event.data.sql) {\n      const sql = event.data.sql;\n      const suspiciousPattern = this.suspiciousPatterns.find(pattern => pattern.test(sql));\n      \n      if (suspiciousPattern) {\n        analysis.riskLevel = 'HIGH';\n        analysis.reasons.push(`Suspicious SQL pattern: ${suspiciousPattern}`);\n      }\n    }\n    \n    // Verificar tentativas de autenticaÃ§Ã£o\n    if (event.message.includes('autenticaÃ§Ã£o falhou')) {\n      analysis.riskLevel = 'MEDIUM';\n      analysis.reasons.push('Authentication failure');\n    }\n    \n    // Verificar horÃ¡rio suspeito (fora do horÃ¡rio comercial)\n    const hour = new Date(event.timestamp).getHours();\n    if (hour < 6 || hour > 22) {\n      analysis.riskLevel = analysis.riskLevel === 'LOW' ? 'MEDIUM' : analysis.riskLevel;\n      analysis.reasons.push('Outside business hours');\n    }\n    \n    // Gerar alerta se necessÃ¡rio\n    if (analysis.riskLevel !== 'LOW') {\n      this.generateAlert(analysis, event);\n    }\n  }\n\n  /**\n   * Detectar atividade suspeita\n   */\n  detectSuspiciousActivity(event) {\n    const now = Date.now();\n    const timeWindow = this.thresholds.timeWindow;\n    \n    // Filtrar eventos recentes\n    const recentEvents = this.events.filter(e => \n      now - new Date(e.timestamp).getTime() < timeWindow\n    );\n    \n    // Detectar mÃºltiplas falhas de autenticaÃ§Ã£o\n    const authFailures = recentEvents.filter(e => \n      e.message.includes('autenticaÃ§Ã£o falhou') && e.user === event.user\n    );\n    \n    if (authFailures.length >= this.thresholds.maxFailedLogins) {\n      this.generateAlert({\n        riskLevel: 'CRITICAL',\n        reasons: [`${authFailures.length} failed authentication attempts`]\n      }, event);\n    }\n    \n    // Detectar muitas conexÃµes\n    const connections = recentEvents.filter(e => \n      e.message.includes('Conectado ao PostgreSQL')\n    );\n    \n    if (connections.length >= this.thresholds.maxConnectionsPerMinute) {\n      this.generateAlert({\n        riskLevel: 'HIGH',\n        reasons: [`${connections.length} connections in ${timeWindow/1000}s`]\n      }, event);\n    }\n    \n    // Detectar comandos suspeitos em sequÃªncia\n    const suspiciousCommands = recentEvents.filter(e => \n      e.data && e.data.sql && this.suspiciousPatterns.some(pattern => pattern.test(e.data.sql))\n    );\n    \n    if (suspiciousCommands.length >= this.thresholds.suspiciousCommandsThreshold) {\n      this.generateAlert({\n        riskLevel: 'CRITICAL',\n        reasons: [`${suspiciousCommands.length} suspicious SQL commands`]\n      }, event);\n    }\n  }\n\n  /**\n   * Verificar thresholds\n   */\n  checkThresholds() {\n    // Implementar verificaÃ§Ãµes adicionais de threshold\n    // Por exemplo: uso de CPU, memÃ³ria, etc.\n  }\n\n  /**\n   * Gerar alerta de seguranÃ§a\n   */\n  generateAlert(analysis, event) {\n    const alert = {\n      id: crypto.randomBytes(8).toString('hex'),\n      timestamp: new Date().toISOString(),\n      riskLevel: analysis.riskLevel,\n      event: {\n        timestamp: event.timestamp,\n        user: event.user,\n        message: event.message,\n        level: event.level\n      },\n      analysis: {\n        reasons: analysis.reasons,\n        recommendation: this.getRecommendation(analysis.riskLevel)\n      },\n      status: 'OPEN'\n    };\n    \n    this.alerts.push(alert);\n    \n    // Salvar alerta\n    this.saveAlert(alert);\n    \n    // Exibir alerta no console\n    this.displayAlert(alert);\n  }\n\n  /**\n   * Obter recomendaÃ§Ã£o baseada no nÃ­vel de risco\n   */\n  getRecommendation(riskLevel) {\n    const recommendations = {\n      LOW: 'Monitor continued activity',\n      MEDIUM: 'Review user activity and consider additional verification',\n      HIGH: 'Investigate immediately and consider blocking user',\n      CRITICAL: 'Block user immediately and conduct full security audit'\n    };\n    \n    return recommendations[riskLevel] || 'Review activity';\n  }\n\n  /**\n   * Salvar alerta\n   */\n  saveAlert(alert) {\n    try {\n      const alertLine = JSON.stringify(alert) + '\\n';\n      fs.appendFileSync(this.alertsLog, alertLine);\n    } catch (error) {\n      console.error('âŒ Erro ao salvar alerta:', error.message);\n    }\n  }\n\n  /**\n   * Exibir alerta no console\n   */\n  displayAlert(alert) {\n    const colors = {\n      LOW: '\\x1b[36m',      // Cyan\n      MEDIUM: '\\x1b[33m',   // Yellow\n      HIGH: '\\x1b[31m',     // Red\n      CRITICAL: '\\x1b[35m', // Magenta\n      RESET: '\\x1b[0m'\n    };\n    \n    const color = colors[alert.riskLevel] || colors.RESET;\n    \n    console.log(`\\n${color}ğŸš¨ ALERTA DE SEGURANÃ‡A [${alert.riskLevel}]${colors.RESET}`);\n    console.log(`ğŸ“… ${alert.timestamp}`);\n    console.log(`ğŸ‘¤ UsuÃ¡rio: ${alert.event.user}`);\n    console.log(`ğŸ“ Evento: ${alert.event.message}`);\n    console.log(`ğŸ” RazÃµes: ${alert.analysis.reasons.join(', ')}`);\n    console.log(`ğŸ’¡ RecomendaÃ§Ã£o: ${alert.analysis.recommendation}`);\n    console.log(`ğŸ†” ID: ${alert.id}\\n`);\n  }\n\n  /**\n   * Gerar relatÃ³rio de seguranÃ§a\n   */\n  generateReport() {\n    const now = new Date();\n    const last24h = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n    \n    // Filtrar eventos das Ãºltimas 24 horas\n    const recentEvents = this.events.filter(e => \n      new Date(e.timestamp) > last24h\n    );\n    \n    const recentAlerts = this.alerts.filter(a => \n      new Date(a.timestamp) > last24h\n    );\n    \n    const report = {\n      timestamp: now.toISOString(),\n      period: '24 hours',\n      summary: {\n        totalEvents: recentEvents.length,\n        totalAlerts: recentAlerts.length,\n        criticalAlerts: recentAlerts.filter(a => a.riskLevel === 'CRITICAL').length,\n        highAlerts: recentAlerts.filter(a => a.riskLevel === 'HIGH').length,\n        mediumAlerts: recentAlerts.filter(a => a.riskLevel === 'MEDIUM').length,\n        lowAlerts: recentAlerts.filter(a => a.riskLevel === 'LOW').length\n      },\n      topUsers: this.getTopUsers(recentEvents),\n      topEvents: this.getTopEvents(recentEvents),\n      recommendations: this.getSecurityRecommendations(recentAlerts)\n    };\n    \n    return report;\n  }\n\n  /**\n   * Obter usuÃ¡rios mais ativos\n   */\n  getTopUsers(events) {\n    const userCounts = {};\n    \n    events.forEach(event => {\n      const user = event.user || 'unknown';\n      userCounts[user] = (userCounts[user] || 0) + 1;\n    });\n    \n    return Object.entries(userCounts)\n      .sort(([,a], [,b]) => b - a)\n      .slice(0, 5)\n      .map(([user, count]) => ({ user, count }));\n  }\n\n  /**\n   * Obter eventos mais comuns\n   */\n  getTopEvents(events) {\n    const eventCounts = {};\n    \n    events.forEach(event => {\n      const message = event.message || 'unknown';\n      eventCounts[message] = (eventCounts[message] || 0) + 1;\n    });\n    \n    return Object.entries(eventCounts)\n      .sort(([,a], [,b]) => b - a)\n      .slice(0, 5)\n      .map(([message, count]) => ({ message, count }));\n  }\n\n  /**\n   * Obter recomendaÃ§Ãµes de seguranÃ§a\n   */\n  getSecurityRecommendations(alerts) {\n    const recommendations = [];\n    \n    if (alerts.length === 0) {\n      recommendations.push('âœ… Nenhum alerta nas Ãºltimas 24 horas - sistema seguro');\n    } else {\n      const criticalCount = alerts.filter(a => a.riskLevel === 'CRITICAL').length;\n      const highCount = alerts.filter(a => a.riskLevel === 'HIGH').length;\n      \n      if (criticalCount > 0) {\n        recommendations.push(`ğŸš¨ ${criticalCount} alertas crÃ­ticos - revisar imediatamente`);\n      }\n      \n      if (highCount > 0) {\n        recommendations.push(`âš ï¸ ${highCount} alertas de alto risco - investigar`);\n      }\n      \n      recommendations.push('ğŸ” Revisar logs de auditoria regularmente');\n      recommendations.push('ğŸ” Considerar rotaÃ§Ã£o de credenciais');\n    }\n    \n    return recommendations;\n  }\n\n  /**\n   * Exibir dashboard\n   */\n  showDashboard() {\n    const report = this.generateReport();\n    \n    console.log('\\nğŸ›¡ï¸ DASHBOARD DE SEGURANÃ‡A - GRC Controller\\n');\n    console.log(`ğŸ“… PerÃ­odo: ${report.period}`);\n    console.log(`ğŸ• Gerado em: ${new Date(report.timestamp).toLocaleString()}\\n`);\n    \n    console.log('ğŸ“Š RESUMO:');\n    console.log(`  ğŸ“‹ Total de eventos: ${report.summary.totalEvents}`);\n    console.log(`  ğŸš¨ Total de alertas: ${report.summary.totalAlerts}`);\n    console.log(`  ğŸ”´ CrÃ­ticos: ${report.summary.criticalAlerts}`);\n    console.log(`  ğŸŸ  Altos: ${report.summary.highAlerts}`);\n    console.log(`  ğŸŸ¡ MÃ©dios: ${report.summary.mediumAlerts}`);\n    console.log(`  ğŸ”µ Baixos: ${report.summary.lowAlerts}\\n`);\n    \n    if (report.topUsers.length > 0) {\n      console.log('ğŸ‘¥ USUÃRIOS MAIS ATIVOS:');\n      report.topUsers.forEach((user, index) => {\n        console.log(`  ${index + 1}. ${user.user}: ${user.count} eventos`);\n      });\n      console.log('');\n    }\n    \n    if (report.topEvents.length > 0) {\n      console.log('ğŸ“‹ EVENTOS MAIS COMUNS:');\n      report.topEvents.forEach((event, index) => {\n        console.log(`  ${index + 1}. ${event.message.substring(0, 50)}...: ${event.count}x`);\n      });\n      console.log('');\n    }\n    \n    console.log('ğŸ’¡ RECOMENDAÃ‡Ã•ES:');\n    report.recommendations.forEach(rec => {\n      console.log(`  ${rec}`);\n    });\n    console.log('');\n  }\n\n  /**\n   * Parar monitoramento\n   */\n  stop() {\n    fs.unwatchFile(this.auditLog);\n    console.log('ğŸ›‘ Security Monitor parado');\n  }\n}\n\n// CLI Interface\nasync function main() {\n  const args = process.argv.slice(2);\n  const command = args[0];\n  \n  const monitor = new SecurityMonitor();\n  \n  switch (command) {\n    case 'start':\n      monitor.start();\n      \n      // Manter o processo rodando\n      process.on('SIGINT', () => {\n        console.log('\\nğŸ›‘ Parando Security Monitor...');\n        monitor.stop();\n        process.exit(0);\n      });\n      \n      // Mostrar dashboard a cada 5 minutos\n      setInterval(() => {\n        monitor.showDashboard();\n      }, 300000);\n      \n      break;\n      \n    case 'dashboard':\n      monitor.loadExistingLogs();\n      monitor.showDashboard();\n      break;\n      \n    case 'report':\n      monitor.loadExistingLogs();\n      const report = monitor.generateReport();\n      console.log(JSON.stringify(report, null, 2));\n      break;\n      \n    case 'alerts':\n      monitor.loadExistingLogs();\n      const recentAlerts = monitor.alerts.slice(-10);\n      \n      if (recentAlerts.length === 0) {\n        console.log('âœ… Nenhum alerta recente');\n      } else {\n        console.log(`ğŸš¨ Ãšltimos ${recentAlerts.length} alertas:\\n`);\n        recentAlerts.forEach(alert => {\n          monitor.displayAlert(alert);\n        });\n      }\n      break;\n      \n    default:\n      console.log(`\nğŸ›¡ï¸ Security Monitor - GRC Controller\n\nğŸ“‹ Comandos disponÃ­veis:\n\nğŸ” Monitoramento:\n  start                      - Iniciar monitoramento em tempo real\n  dashboard                  - Mostrar dashboard de seguranÃ§a\n  report                     - Gerar relatÃ³rio JSON\n  alerts                     - Mostrar alertas recentes\n  \nğŸ“ Exemplos:\n  node security-monitor.cjs start\n  node security-monitor.cjs dashboard\n  node security-monitor.cjs alerts\n  \nğŸ”§ Recursos:\n  âœ… Monitoramento em tempo real\n  âœ… DetecÃ§Ã£o de atividades suspeitas\n  âœ… Alertas automÃ¡ticos\n  âœ… Dashboard de seguranÃ§a\n  âœ… RelatÃ³rios de auditoria\n  âœ… AnÃ¡lise de padrÃµes\n      `);\n  }\n}\n\n// Executar apenas se chamado diretamente\nif (require.main === module) {\n  main().catch(console.error);\n}\n\nmodule.exports = SecurityMonitor;"