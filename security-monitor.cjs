#!/usr/bin/env node\n\n/**\n * üõ°Ô∏è Security Monitor - GRC Controller\n * \n * Sistema de monitoramento de seguran√ßa em tempo real\n * \n * Funcionalidades:\n * - Monitorar tentativas de acesso\n * - Detectar atividades suspeitas\n * - Gerar alertas de seguran√ßa\n * - Relat√≥rios de auditoria\n * - Dashboard de seguran√ßa\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\n\nclass SecurityMonitor {\n  constructor() {\n    this.logDir = 'logs';\n    this.auditLog = path.join(this.logDir, 'database-audit.log');\n    this.securityLog = path.join(this.logDir, 'security-events.log');\n    this.alertsLog = path.join(this.logDir, 'security-alerts.log');\n    \n    this.thresholds = {\n      maxFailedLogins: 5,\n      maxConnectionsPerMinute: 10,\n      suspiciousCommandsThreshold: 3,\n      timeWindow: 300000 // 5 minutos\n    };\n    \n    this.suspiciousPatterns = [\n      /DROP\\s+TABLE/i,\n      /DELETE\\s+FROM/i,\n      /TRUNCATE/i,\n      /ALTER\\s+USER/i,\n      /GRANT\\s+ALL/i,\n      /UNION\\s+SELECT/i,\n      /--\\s*$/,\n      /\\/\\*.*\\*\\//\n    ];\n    \n    this.events = [];\n    this.alerts = [];\n  }\n\n  /**\n   * Iniciar monitoramento\n   */\n  start() {\n    console.log('üõ°Ô∏è Iniciando Security Monitor...');\n    \n    // Criar diret√≥rio de logs se n√£o existir\n    if (!fs.existsSync(this.logDir)) {\n      fs.mkdirSync(this.logDir, { recursive: true });\n    }\n    \n    // Monitorar logs existentes\n    this.loadExistingLogs();\n    \n    // Iniciar monitoramento em tempo real\n    this.startRealTimeMonitoring();\n    \n    console.log('‚úÖ Security Monitor ativo');\n    console.log(`üìä Monitorando: ${this.auditLog}`);\n    console.log(`üö® Alertas em: ${this.alertsLog}`);\n  }\n\n  /**\n   * Carregar logs existentes\n   */\n  loadExistingLogs() {\n    try {\n      if (fs.existsSync(this.auditLog)) {\n        const logContent = fs.readFileSync(this.auditLog, 'utf8');\n        const lines = logContent.trim().split('\\n').filter(line => line.trim());\n        \n        lines.forEach(line => {\n          try {\n            const event = JSON.parse(line);\n            this.processEvent(event);\n          } catch (error) {\n            // Ignorar linhas malformadas\n          }\n        });\n        \n        console.log(`üìã ${lines.length} eventos carregados do log`);\n      }\n    } catch (error) {\n      console.error('‚ùå Erro ao carregar logs existentes:', error.message);\n    }\n  }\n\n  /**\n   * Iniciar monitoramento em tempo real\n   */\n  startRealTimeMonitoring() {\n    if (!fs.existsSync(this.auditLog)) {\n      console.log('‚ö†Ô∏è  Arquivo de audit log n√£o encontrado, criando...');\n      fs.writeFileSync(this.auditLog, '');\n    }\n    \n    // Monitorar mudan√ßas no arquivo de log\n    fs.watchFile(this.auditLog, (curr, prev) => {\n      if (curr.mtime > prev.mtime) {\n        this.processNewLogEntries();\n      }\n    });\n  }\n\n  /**\n   * Processar novas entradas do log\n   */\n  processNewLogEntries() {\n    try {\n      const logContent = fs.readFileSync(this.auditLog, 'utf8');\n      const lines = logContent.trim().split('\\n').filter(line => line.trim());\n      \n      // Processar apenas as √∫ltimas linhas (novas)\n      const newLines = lines.slice(this.events.length);\n      \n      newLines.forEach(line => {\n        try {\n          const event = JSON.parse(line);\n          this.processEvent(event);\n        } catch (error) {\n          // Ignorar linhas malformadas\n        }\n      });\n    } catch (error) {\n      console.error('‚ùå Erro ao processar novas entradas:', error.message);\n    }\n  }\n\n  /**\n   * Processar evento de seguran√ßa\n   */\n  processEvent(event) {\n    this.events.push(event);\n    \n    // Analisar evento\n    this.analyzeEvent(event);\n    \n    // Detectar padr√µes suspeitos\n    this.detectSuspiciousActivity(event);\n    \n    // Verificar thresholds\n    this.checkThresholds();\n  }\n\n  /**\n   * Analisar evento individual\n   */\n  analyzeEvent(event) {\n    const analysis = {\n      timestamp: event.timestamp,\n      level: event.level,\n      user: event.user,\n      riskLevel: 'LOW',\n      reasons: []\n    };\n    \n    // Verificar n√≠vel de log\n    if (event.level === 'ERROR') {\n      analysis.riskLevel = 'MEDIUM';\n      analysis.reasons.push('Error level event');\n    }\n    \n    // Verificar comandos suspeitos\n    if (event.data && event.data.sql) {\n      const sql = event.data.sql;\n      const suspiciousPattern = this.suspiciousPatterns.find(pattern => pattern.test(sql));\n      \n      if (suspiciousPattern) {\n        analysis.riskLevel = 'HIGH';\n        analysis.reasons.push(`Suspicious SQL pattern: ${suspiciousPattern}`);\n      }\n    }\n    \n    // Verificar tentativas de autentica√ß√£o\n    if (event.message.includes('autentica√ß√£o falhou')) {\n      analysis.riskLevel = 'MEDIUM';\n      analysis.reasons.push('Authentication failure');\n    }\n    \n    // Verificar hor√°rio suspeito (fora do hor√°rio comercial)\n    const hour = new Date(event.timestamp).getHours();\n    if (hour < 6 || hour > 22) {\n      analysis.riskLevel = analysis.riskLevel === 'LOW' ? 'MEDIUM' : analysis.riskLevel;\n      analysis.reasons.push('Outside business hours');\n    }\n    \n    // Gerar alerta se necess√°rio\n    if (analysis.riskLevel !== 'LOW') {\n      this.generateAlert(analysis, event);\n    }\n  }\n\n  /**\n   * Detectar atividade suspeita\n   */\n  detectSuspiciousActivity(event) {\n    const now = Date.now();\n    const timeWindow = this.thresholds.timeWindow;\n    \n    // Filtrar eventos recentes\n    const recentEvents = this.events.filter(e => \n      now - new Date(e.timestamp).getTime() < timeWindow\n    );\n    \n    // Detectar m√∫ltiplas falhas de autentica√ß√£o\n    const authFailures = recentEvents.filter(e => \n      e.message.includes('autentica√ß√£o falhou') && e.user === event.user\n    );\n    \n    if (authFailures.length >= this.thresholds.maxFailedLogins) {\n      this.generateAlert({\n        riskLevel: 'CRITICAL',\n        reasons: [`${authFailures.length} failed authentication attempts`]\n      }, event);\n    }\n    \n    // Detectar muitas conex√µes\n    const connections = recentEvents.filter(e => \n      e.message.includes('Conectado ao PostgreSQL')\n    );\n    \n    if (connections.length >= this.thresholds.maxConnectionsPerMinute) {\n      this.generateAlert({\n        riskLevel: 'HIGH',\n        reasons: [`${connections.length} connections in ${timeWindow/1000}s`]\n      }, event);\n    }\n    \n    // Detectar comandos suspeitos em sequ√™ncia\n    const suspiciousCommands = recentEvents.filter(e => \n      e.data && e.data.sql && this.suspiciousPatterns.some(pattern => pattern.test(e.data.sql))\n    );\n    \n    if (suspiciousCommands.length >= this.thresholds.suspiciousCommandsThreshold) {\n      this.generateAlert({\n        riskLevel: 'CRITICAL',\n        reasons: [`${suspiciousCommands.length} suspicious SQL commands`]\n      }, event);\n    }\n  }\n\n  /**\n   * Verificar thresholds\n   */\n  checkThresholds() {\n    // Implementar verifica√ß√µes adicionais de threshold\n    // Por exemplo: uso de CPU, mem√≥ria, etc.\n  }\n\n  /**\n   * Gerar alerta de seguran√ßa\n   */\n  generateAlert(analysis, event) {\n    const alert = {\n      id: crypto.randomBytes(8).toString('hex'),\n      timestamp: new Date().toISOString(),\n      riskLevel: analysis.riskLevel,\n      event: {\n        timestamp: event.timestamp,\n        user: event.user,\n        message: event.message,\n        level: event.level\n      },\n      analysis: {\n        reasons: analysis.reasons,\n        recommendation: this.getRecommendation(analysis.riskLevel)\n      },\n      status: 'OPEN'\n    };\n    \n    this.alerts.push(alert);\n    \n    // Salvar alerta\n    this.saveAlert(alert);\n    \n    // Exibir alerta no console\n    this.displayAlert(alert);\n  }\n\n  /**\n   * Obter recomenda√ß√£o baseada no n√≠vel de risco\n   */\n  getRecommendation(riskLevel) {\n    const recommendations = {\n      LOW: 'Monitor continued activity',\n      MEDIUM: 'Review user activity and consider additional verification',\n      HIGH: 'Investigate immediately and consider blocking user',\n      CRITICAL: 'Block user immediately and conduct full security audit'\n    };\n    \n    return recommendations[riskLevel] || 'Review activity';\n  }\n\n  /**\n   * Salvar alerta\n   */\n  saveAlert(alert) {\n    try {\n      const alertLine = JSON.stringify(alert) + '\\n';\n      fs.appendFileSync(this.alertsLog, alertLine);\n    } catch (error) {\n      console.error('‚ùå Erro ao salvar alerta:', error.message);\n    }\n  }\n\n  /**\n   * Exibir alerta no console\n   */\n  displayAlert(alert) {\n    const colors = {\n      LOW: '\\x1b[36m',      // Cyan\n      MEDIUM: '\\x1b[33m',   // Yellow\n      HIGH: '\\x1b[31m',     // Red\n      CRITICAL: '\\x1b[35m', // Magenta\n      RESET: '\\x1b[0m'\n    };\n    \n    const color = colors[alert.riskLevel] || colors.RESET;\n    \n    console.log(`\\n${color}üö® ALERTA DE SEGURAN√áA [${alert.riskLevel}]${colors.RESET}`);\n    console.log(`üìÖ ${alert.timestamp}`);\n    console.log(`üë§ Usu√°rio: ${alert.event.user}`);\n    console.log(`üìù Evento: ${alert.event.message}`);\n    console.log(`üîç Raz√µes: ${alert.analysis.reasons.join(', ')}`);\n    console.log(`üí° Recomenda√ß√£o: ${alert.analysis.recommendation}`);\n    console.log(`üÜî ID: ${alert.id}\\n`);\n  }\n\n  /**\n   * Gerar relat√≥rio de seguran√ßa\n   */\n  generateReport() {\n    const now = new Date();\n    const last24h = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n    \n    // Filtrar eventos das √∫ltimas 24 horas\n    const recentEvents = this.events.filter(e => \n      new Date(e.timestamp) > last24h\n    );\n    \n    const recentAlerts = this.alerts.filter(a => \n      new Date(a.timestamp) > last24h\n    );\n    \n    const report = {\n      timestamp: now.toISOString(),\n      period: '24 hours',\n      summary: {\n        totalEvents: recentEvents.length,\n        totalAlerts: recentAlerts.length,\n        criticalAlerts: recentAlerts.filter(a => a.riskLevel === 'CRITICAL').length,\n        highAlerts: recentAlerts.filter(a => a.riskLevel === 'HIGH').length,\n        mediumAlerts: recentAlerts.filter(a => a.riskLevel === 'MEDIUM').length,\n        lowAlerts: recentAlerts.filter(a => a.riskLevel === 'LOW').length\n      },\n      topUsers: this.getTopUsers(recentEvents),\n      topEvents: this.getTopEvents(recentEvents),\n      recommendations: this.getSecurityRecommendations(recentAlerts)\n    };\n    \n    return report;\n  }\n\n  /**\n   * Obter usu√°rios mais ativos\n   */\n  getTopUsers(events) {\n    const userCounts = {};\n    \n    events.forEach(event => {\n      const user = event.user || 'unknown';\n      userCounts[user] = (userCounts[user] || 0) + 1;\n    });\n    \n    return Object.entries(userCounts)\n      .sort(([,a], [,b]) => b - a)\n      .slice(0, 5)\n      .map(([user, count]) => ({ user, count }));\n  }\n\n  /**\n   * Obter eventos mais comuns\n   */\n  getTopEvents(events) {\n    const eventCounts = {};\n    \n    events.forEach(event => {\n      const message = event.message || 'unknown';\n      eventCounts[message] = (eventCounts[message] || 0) + 1;\n    });\n    \n    return Object.entries(eventCounts)\n      .sort(([,a], [,b]) => b - a)\n      .slice(0, 5)\n      .map(([message, count]) => ({ message, count }));\n  }\n\n  /**\n   * Obter recomenda√ß√µes de seguran√ßa\n   */\n  getSecurityRecommendations(alerts) {\n    const recommendations = [];\n    \n    if (alerts.length === 0) {\n      recommendations.push('‚úÖ Nenhum alerta nas √∫ltimas 24 horas - sistema seguro');\n    } else {\n      const criticalCount = alerts.filter(a => a.riskLevel === 'CRITICAL').length;\n      const highCount = alerts.filter(a => a.riskLevel === 'HIGH').length;\n      \n      if (criticalCount > 0) {\n        recommendations.push(`üö® ${criticalCount} alertas cr√≠ticos - revisar imediatamente`);\n      }\n      \n      if (highCount > 0) {\n        recommendations.push(`‚ö†Ô∏è ${highCount} alertas de alto risco - investigar`);\n      }\n      \n      recommendations.push('üîç Revisar logs de auditoria regularmente');\n      recommendations.push('üîê Considerar rota√ß√£o de credenciais');\n    }\n    \n    return recommendations;\n  }\n\n  /**\n   * Exibir dashboard\n   */\n  showDashboard() {\n    const report = this.generateReport();\n    \n    console.log('\\nüõ°Ô∏è DASHBOARD DE SEGURAN√áA - GRC Controller\\n');\n    console.log(`üìÖ Per√≠odo: ${report.period}`);\n    console.log(`üïê Gerado em: ${new Date(report.timestamp).toLocaleString()}\\n`);\n    \n    console.log('üìä RESUMO:');\n    console.log(`  üìã Total de eventos: ${report.summary.totalEvents}`);\n    console.log(`  üö® Total de alertas: ${report.summary.totalAlerts}`);\n    console.log(`  üî¥ Cr√≠ticos: ${report.summary.criticalAlerts}`);\n    console.log(`  üü† Altos: ${report.summary.highAlerts}`);\n    console.log(`  üü° M√©dios: ${report.summary.mediumAlerts}`);\n    console.log(`  üîµ Baixos: ${report.summary.lowAlerts}\\n`);\n    \n    if (report.topUsers.length > 0) {\n      console.log('üë• USU√ÅRIOS MAIS ATIVOS:');\n      report.topUsers.forEach((user, index) => {\n        console.log(`  ${index + 1}. ${user.user}: ${user.count} eventos`);\n      });\n      console.log('');\n    }\n    \n    if (report.topEvents.length > 0) {\n      console.log('üìã EVENTOS MAIS COMUNS:');\n      report.topEvents.forEach((event, index) => {\n        console.log(`  ${index + 1}. ${event.message.substring(0, 50)}...: ${event.count}x`);\n      });\n      console.log('');\n    }\n    \n    console.log('üí° RECOMENDA√á√ïES:');\n    report.recommendations.forEach(rec => {\n      console.log(`  ${rec}`);\n    });\n    console.log('');\n  }\n\n  /**\n   * Parar monitoramento\n   */\n  stop() {\n    fs.unwatchFile(this.auditLog);\n    console.log('üõë Security Monitor parado');\n  }\n}\n\n// CLI Interface\nasync function main() {\n  const args = process.argv.slice(2);\n  const command = args[0];\n  \n  const monitor = new SecurityMonitor();\n  \n  switch (command) {\n    case 'start':\n      monitor.start();\n      \n      // Manter o processo rodando\n      process.on('SIGINT', () => {\n        console.log('\\nüõë Parando Security Monitor...');\n        monitor.stop();\n        process.exit(0);\n      });\n      \n      // Mostrar dashboard a cada 5 minutos\n      setInterval(() => {\n        monitor.showDashboard();\n      }, 300000);\n      \n      break;\n      \n    case 'dashboard':\n      monitor.loadExistingLogs();\n      monitor.showDashboard();\n      break;\n      \n    case 'report':\n      monitor.loadExistingLogs();\n      const report = monitor.generateReport();\n      console.log(JSON.stringify(report, null, 2));\n      break;\n      \n    case 'alerts':\n      monitor.loadExistingLogs();\n      const recentAlerts = monitor.alerts.slice(-10);\n      \n      if (recentAlerts.length === 0) {\n        console.log('‚úÖ Nenhum alerta recente');\n      } else {\n        console.log(`üö® √öltimos ${recentAlerts.length} alertas:\\n`);\n        recentAlerts.forEach(alert => {\n          monitor.displayAlert(alert);\n        });\n      }\n      break;\n      \n    default:\n      console.log(`\nüõ°Ô∏è Security Monitor - GRC Controller\n\nüìã Comandos dispon√≠veis:\n\nüîç Monitoramento:\n  start                      - Iniciar monitoramento em tempo real\n  dashboard                  - Mostrar dashboard de seguran√ßa\n  report                     - Gerar relat√≥rio JSON\n  alerts                     - Mostrar alertas recentes\n  \nüìù Exemplos:\n  node security-monitor.cjs start\n  node security-monitor.cjs dashboard\n  node security-monitor.cjs alerts\n  \nüîß Recursos:\n  ‚úÖ Monitoramento em tempo real\n  ‚úÖ Detec√ß√£o de atividades suspeitas\n  ‚úÖ Alertas autom√°ticos\n  ‚úÖ Dashboard de seguran√ßa\n  ‚úÖ Relat√≥rios de auditoria\n  ‚úÖ An√°lise de padr√µes\n      `);\n  }\n}\n\n// Executar apenas se chamado diretamente\nif (require.main === module) {\n  main().catch(console.error);\n}\n\nmodule.exports = SecurityMonitor;"