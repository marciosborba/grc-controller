#!/usr/bin/env node

/**\n * 🔐 Secure Environment Manager\n * \n * Sistema de criptografia para credenciais sensíveis\n * Uso: node secure-env-manager.cjs [comando]\n * \n * Comandos:\n * - encrypt: Criptografar arquivo .env\n * - decrypt: Descriptografar para uso\n * - rotate: Rotacionar chaves de criptografia\n * - verify: Verificar integridade\n */\n\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\n\nclass SecureEnvManager {\n  constructor() {\n    this.algorithm = 'aes-256-gcm';\n    this.keyFile = '.env.key';\n    this.encryptedFile = '.env.encrypted';\n    this.backupDir = 'backups/env';\n    this.saltLength = 32;\n    this.ivLength = 16;\n    this.tagLength = 16;\n    \n    // Criar diretório de backup se não existir\n    if (!fs.existsSync(this.backupDir)) {\n      fs.mkdirSync(this.backupDir, { recursive: true });\n    }\n  }\n\n  /**\n   * Gerar chave de criptografia segura\n   */\n  generateKey() {\n    console.log('🔑 Gerando nova chave de criptografia...');\n    \n    const key = crypto.randomBytes(32);\n    const salt = crypto.randomBytes(this.saltLength);\n    \n    const keyData = {\n      key: key.toString('hex'),\n      salt: salt.toString('hex'),\n      created: new Date().toISOString(),\n      algorithm: this.algorithm,\n      version: '1.0'\n    };\n    \n    // Salvar chave com permissões restritas\n    fs.writeFileSync(this.keyFile, JSON.stringify(keyData, null, 2), { mode: 0o600 });\n    \n    console.log('✅ Chave gerada e salva em:', this.keyFile);\n    console.log('⚠️  IMPORTANTE: Mantenha este arquivo seguro e não o commite!');\n    \n    return keyData;\n  }\n\n  /**\n   * Carregar chave de criptografia\n   */\n  loadKey() {\n    if (!fs.existsSync(this.keyFile)) {\n      throw new Error(`Arquivo de chave não encontrado: ${this.keyFile}`);\n    }\n    \n    try {\n      const keyData = JSON.parse(fs.readFileSync(this.keyFile, 'utf8'));\n      \n      // Validar estrutura da chave\n      if (!keyData.key || !keyData.salt) {\n        throw new Error('Estrutura de chave inválida');\n      }\n      \n      return keyData;\n    } catch (error) {\n      throw new Error(`Erro ao carregar chave: ${error.message}`);\n    }\n  }\n\n  /**\n   * Criptografar arquivo .env\n   */\n  encrypt() {\n    console.log('🔒 Criptografando arquivo .env...');\n    \n    // Verificar se .env existe\n    if (!fs.existsSync('.env')) {\n      throw new Error('Arquivo .env não encontrado');\n    }\n    \n    // Carregar ou gerar chave\n    let keyData;\n    try {\n      keyData = this.loadKey();\n      console.log('🔑 Usando chave existente');\n    } catch {\n      console.log('🔑 Gerando nova chave...');\n      keyData = this.generateKey();\n    }\n    \n    // Ler conteúdo do .env\n    const envContent = fs.readFileSync('.env', 'utf8');\n    \n    // Criar backup do .env original\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);\n    const backupPath = path.join(this.backupDir, `.env.backup.${timestamp}`);\n    fs.writeFileSync(backupPath, envContent);\n    console.log('💾 Backup criado:', backupPath);\n    \n    // Criptografar\n    const key = Buffer.from(keyData.key, 'hex');\n    const iv = crypto.randomBytes(this.ivLength);\n    const cipher = crypto.createCipher(this.algorithm, key);\n    cipher.setAAD(Buffer.from(keyData.salt, 'hex'));\n    \n    let encrypted = cipher.update(envContent, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    \n    const authTag = cipher.getAuthTag();\n    \n    const encryptedData = {\n      encrypted,\n      iv: iv.toString('hex'),\n      authTag: authTag.toString('hex'),\n      salt: keyData.salt,\n      algorithm: this.algorithm,\n      created: new Date().toISOString(),\n      version: '1.0'\n    };\n    \n    // Salvar arquivo criptografado\n    fs.writeFileSync(this.encryptedFile, JSON.stringify(encryptedData, null, 2));\n    \n    // Remover .env original (opcional - comentado por segurança)\n    // fs.unlinkSync('.env');\n    \n    console.log('✅ Arquivo criptografado salvo em:', this.encryptedFile);\n    console.log('⚠️  Considere remover o .env original após verificar que a criptografia funcionou');\n    \n    return encryptedData;\n  }\n\n  /**\n   * Descriptografar arquivo .env\n   */\n  decrypt(outputFile = '.env.decrypted') {\n    console.log('🔓 Descriptografando arquivo...');\n    \n    // Verificar se arquivo criptografado existe\n    if (!fs.existsSync(this.encryptedFile)) {\n      throw new Error(`Arquivo criptografado não encontrado: ${this.encryptedFile}`);\n    }\n    \n    // Carregar chave\n    const keyData = this.loadKey();\n    \n    // Carregar dados criptografados\n    const encryptedData = JSON.parse(fs.readFileSync(this.encryptedFile, 'utf8'));\n    \n    // Validar dados\n    if (!encryptedData.encrypted || !encryptedData.iv || !encryptedData.authTag) {\n      throw new Error('Dados criptografados inválidos');\n    }\n    \n    try {\n      // Descriptografar\n      const key = Buffer.from(keyData.key, 'hex');\n      const iv = Buffer.from(encryptedData.iv, 'hex');\n      const authTag = Buffer.from(encryptedData.authTag, 'hex');\n      \n      const decipher = crypto.createDecipher(this.algorithm, key);\n      decipher.setAAD(Buffer.from(encryptedData.salt, 'hex'));\n      decipher.setAuthTag(authTag);\n      \n      let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n      \n      // Salvar arquivo descriptografado\n      fs.writeFileSync(outputFile, decrypted, { mode: 0o600 });\n      \n      console.log('✅ Arquivo descriptografado salvo em:', outputFile);\n      console.log('⚠️  Lembre-se de remover este arquivo após o uso');\n      \n      return decrypted;\n    } catch (error) {\n      throw new Error(`Erro na descriptografia: ${error.message}`);\n    }\n  }\n\n  /**\n   * Verificar integridade dos arquivos\n   */\n  verify() {\n    console.log('🔍 Verificando integridade...');\n    \n    const checks = {\n      keyFile: fs.existsSync(this.keyFile),\n      encryptedFile: fs.existsSync(this.encryptedFile),\n      keyValid: false,\n      encryptedValid: false\n    };\n    \n    // Verificar chave\n    if (checks.keyFile) {\n      try {\n        const keyData = this.loadKey();\n        checks.keyValid = keyData.key && keyData.salt;\n      } catch {\n        checks.keyValid = false;\n      }\n    }\n    \n    // Verificar arquivo criptografado\n    if (checks.encryptedFile) {\n      try {\n        const encryptedData = JSON.parse(fs.readFileSync(this.encryptedFile, 'utf8'));\n        checks.encryptedValid = encryptedData.encrypted && encryptedData.iv && encryptedData.authTag;\n      } catch {\n        checks.encryptedValid = false;\n      }\n    }\n    \n    // Relatório\n    console.log('📋 Relatório de Integridade:');\n    console.log(`  Arquivo de chave: ${checks.keyFile ? '✅' : '❌'} ${checks.keyValid ? '(válido)' : '(inválido)'}`);\n    console.log(`  Arquivo criptografado: ${checks.encryptedFile ? '✅' : '❌'} ${checks.encryptedValid ? '(válido)' : '(inválido)'}`);\n    \n    const allValid = checks.keyFile && checks.encryptedFile && checks.keyValid && checks.encryptedValid;\n    console.log(`\\n🎯 Status geral: ${allValid ? '✅ Tudo OK' : '❌ Problemas encontrados'}`);\n    \n    return checks;\n  }\n\n  /**\n   * Rotacionar chaves de criptografia\n   */\n  rotate() {\n    console.log('🔄 Rotacionando chaves de criptografia...');\n    \n    // Backup da chave atual\n    if (fs.existsSync(this.keyFile)) {\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);\n      const backupKeyPath = path.join(this.backupDir, `.env.key.backup.${timestamp}`);\n      fs.copyFileSync(this.keyFile, backupKeyPath);\n      console.log('💾 Backup da chave atual:', backupKeyPath);\n    }\n    \n    // Descriptografar com chave atual\n    let envContent;\n    try {\n      envContent = this.decrypt('.env.temp');\n      fs.unlinkSync('.env.temp'); // Remover arquivo temporário\n    } catch (error) {\n      console.error('❌ Erro ao descriptografar com chave atual:', error.message);\n      return false;\n    }\n    \n    // Gerar nova chave\n    this.generateKey();\n    \n    // Criptografar novamente com nova chave\n    fs.writeFileSync('.env', envContent, { mode: 0o600 });\n    this.encrypt();\n    fs.unlinkSync('.env'); // Remover .env temporário\n    \n    console.log('✅ Rotação de chaves concluída com sucesso!');\n    return true;\n  }\n\n  /**\n   * Limpar arquivos temporários\n   */\n  cleanup() {\n    console.log('🧹 Limpando arquivos temporários...');\n    \n    const tempFiles = ['.env.decrypted', '.env.temp'];\n    let cleaned = 0;\n    \n    tempFiles.forEach(file => {\n      if (fs.existsSync(file)) {\n        fs.unlinkSync(file);\n        cleaned++;\n        console.log(`🗑️  Removido: ${file}`);\n      }\n    });\n    \n    console.log(`✅ ${cleaned} arquivo(s) temporário(s) removido(s)`);\n  }\n\n  /**\n   * Mostrar status do sistema\n   */\n  status() {\n    console.log('📊 Status do Sistema de Criptografia\\n');\n    \n    const stats = {\n      keyFile: fs.existsSync(this.keyFile),\n      encryptedFile: fs.existsSync(this.encryptedFile),\n      envFile: fs.existsSync('.env'),\n      backupCount: 0\n    };\n    \n    // Contar backups\n    if (fs.existsSync(this.backupDir)) {\n      const backups = fs.readdirSync(this.backupDir);\n      stats.backupCount = backups.length;\n    }\n    \n    console.log(`🔑 Arquivo de chave: ${stats.keyFile ? '✅ Presente' : '❌ Ausente'}`);\n    console.log(`🔒 Arquivo criptografado: ${stats.encryptedFile ? '✅ Presente' : '❌ Ausente'}`);\n    console.log(`📄 Arquivo .env: ${stats.envFile ? '⚠️  Presente (considere criptografar)' : '✅ Ausente (seguro)'}`);\n    console.log(`💾 Backups disponíveis: ${stats.backupCount}`);\n    \n    // Informações da chave\n    if (stats.keyFile) {\n      try {\n        const keyData = this.loadKey();\n        console.log(`\\n🔑 Informações da Chave:`);\n        console.log(`   Algoritmo: ${keyData.algorithm}`);\n        console.log(`   Versão: ${keyData.version}`);\n        console.log(`   Criada em: ${keyData.created}`);\n      } catch (error) {\n        console.log(`\\n❌ Erro ao ler chave: ${error.message}`);\n      }\n    }\n    \n    return stats;\n  }\n}\n\n// CLI Interface\nasync function main() {\n  const args = process.argv.slice(2);\n  const command = args[0];\n  \n  if (!command) {\n    console.log(`\n🔐 Secure Environment Manager\n\n📋 Comandos disponíveis:\n\n🔒 Criptografia:\n  encrypt                    - Criptografar arquivo .env\n  decrypt [output]           - Descriptografar para arquivo (padrão: .env.decrypted)\n  rotate                     - Rotacionar chaves de criptografia\n  \n🔍 Verificação:\n  verify                     - Verificar integridade dos arquivos\n  status                     - Mostrar status do sistema\n  \n🧹 Manutenção:\n  cleanup                    - Limpar arquivos temporários\n  \n📝 Exemplos:\n  node secure-env-manager.cjs encrypt\n  node secure-env-manager.cjs decrypt\n  node secure-env-manager.cjs verify\n  node secure-env-manager.cjs status\n  \n⚠️  IMPORTANTE:\n  - Mantenha o arquivo .env.key seguro\n  - Não commite arquivos de chave\n  - Faça backup das chaves regularmente\n    `);\n    return;\n  }\n\n  const manager = new SecureEnvManager();\n  \n  try {\n    switch (command) {\n      case 'encrypt':\n        await manager.encrypt();\n        break;\n        \n      case 'decrypt':\n        const outputFile = args[1] || '.env.decrypted';\n        await manager.decrypt(outputFile);\n        break;\n        \n      case 'verify':\n        await manager.verify();\n        break;\n        \n      case 'rotate':\n        await manager.rotate();\n        break;\n        \n      case 'cleanup':\n        await manager.cleanup();\n        break;\n        \n      case 'status':\n        await manager.status();\n        break;\n        \n      default:\n        console.error(`❌ Comando desconhecido: ${command}`);\n        console.log('💡 Use sem argumentos para ver a lista de comandos');\n        process.exit(1);\n    }\n    \n  } catch (error) {\n    console.error('❌ Erro durante execução:', error.message);\n    process.exit(1);\n  }\n}\n\n// Executar apenas se chamado diretamente\nif (require.main === module) {\n  main().catch(console.error);\n}\n\nmodule.exports = SecureEnvManager;"