import { ApplicationData } from '../../types/ApplicationData';\nimport { BaseIntegration } from './BaseIntegration';\n\ninterface GitLabCredentials {\n  server: string;\n  token: string;\n  group?: string;\n  projects?: string[];\n}\n\ninterface GitLabFilters {\n  includeArchived?: boolean;\n  maxResults?: number;\n  group?: string;\n  projects?: string[];\n}\n\nexport class GitLabApplicationIntegration extends BaseIntegration {\n  private credentials: GitLabCredentials;\n\n  constructor(credentials: GitLabCredentials) {\n    super();\n    this.credentials = {\n      server: credentials.server || 'https://gitlab.com',\n      token: credentials.token,\n      group: credentials.group,\n      projects: credentials.projects\n    };\n  }\n\n  async testConnection(): Promise<{ success: boolean; message: string }> {\n    try {\n      const url = `${this.credentials.server}/api/v4/user`;\n      \n      const response = await this.makeHttpRequest(url, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.credentials.token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n\n      if (response.id) {\n        return {\n          success: true,\n          message: `Conexão estabelecida com sucesso! Usuário: ${response.name || response.username}`\n        };\n      } else {\n        return {\n          success: false,\n          message: 'Falha na autenticação com GitLab'\n        };\n      }\n    } catch (error) {\n      console.error('GitLab connection test failed:', error);\n      return {\n        success: false,\n        message: `Erro de conexão: ${error instanceof Error ? error.message : 'Erro desconhecido'}`\n      };\n    }\n  }\n\n  async getApplications(filters?: GitLabFilters): Promise<ApplicationData[]> {\n    try {\n      let projects: any[] = [];\n\n      if (filters?.projects || this.credentials.projects) {\n        // Import specific projects\n        const projectList = filters?.projects || this.credentials.projects!;\n        for (const projectPath of projectList) {\n          const projectData = await this.getProject(projectPath);\n          if (projectData) projects.push(projectData);\n        }\n      } else if (filters?.group || this.credentials.group) {\n        // Import all projects from group\n        projects = await this.getGroupProjects(filters?.group || this.credentials.group!, filters);\n      } else {\n        // Import user projects\n        projects = await this.getUserProjects(filters);\n      }\n\n      return this.parseGitLabProjects(projects);\n    } catch (error) {\n      console.error('Failed to get GitLab projects:', error);\n      throw error;\n    }\n  }\n\n  private async getProject(projectPath: string): Promise<any> {\n    try {\n      // Encode project path for URL\n      const encodedPath = encodeURIComponent(projectPath);\n      const url = `${this.credentials.server}/api/v4/projects/${encodedPath}`;\n      \n      const response = await this.makeHttpRequest(url, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.credentials.token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n\n      return response;\n    } catch (error) {\n      console.error(`Failed to get project ${projectPath}:`, error);\n      return null;\n    }\n  }\n\n  private async getGroupProjects(groupPath: string, filters?: GitLabFilters): Promise<any[]> {\n    try {\n      const encodedGroup = encodeURIComponent(groupPath);\n      let url = `${this.credentials.server}/api/v4/groups/${encodedGroup}/projects`;\n      \n      const params = new URLSearchParams({\n        include_subgroups: 'true',\n        order_by: 'updated_at',\n        sort: 'desc'\n      });\n\n      if (filters?.includeArchived) {\n        params.append('archived', 'true');\n      } else {\n        params.append('archived', 'false');\n      }\n\n      if (filters?.maxResults) {\n        params.append('per_page', Math.min(filters.maxResults, 100).toString());\n      }\n\n      url += '?' + params.toString();\n\n      const response = await this.makeHttpRequest(url, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.credentials.token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n\n      return Array.isArray(response) ? response : [];\n    } catch (error) {\n      console.error(`Failed to get group projects for ${groupPath}:`, error);\n      throw error;\n    }\n  }\n\n  private async getUserProjects(filters?: GitLabFilters): Promise<any[]> {\n    try {\n      let url = `${this.credentials.server}/api/v4/projects`;\n      \n      const params = new URLSearchParams({\n        membership: 'true',\n        order_by: 'updated_at',\n        sort: 'desc'\n      });\n\n      if (filters?.includeArchived) {\n        params.append('archived', 'true');\n      } else {\n        params.append('archived', 'false');\n      }\n\n      if (filters?.maxResults) {\n        params.append('per_page', Math.min(filters.maxResults, 100).toString());\n      }\n\n      url += '?' + params.toString();\n\n      const response = await this.makeHttpRequest(url, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.credentials.token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n\n      return Array.isArray(response) ? response : [];\n    } catch (error) {\n      console.error('Failed to get user projects:', error);\n      throw error;\n    }\n  }\n\n  private parseGitLabProjects(projects: any[]): ApplicationData[] {\n    const applications: ApplicationData[] = [];\n\n    projects.forEach(project => {\n      const application: ApplicationData = {\n        id: project.id?.toString() || `gitlab-${project.path}`,\n        name: project.name || 'Unknown Project',\n        type: this.inferApplicationType(project),\n        status: this.mapProjectStatus(project),\n        url: project.web_url,\n        technology: this.inferTechnology(project),\n        language: project.default_branch ? 'Multiple' : 'Unknown',\n        owner: project.owner?.name || project.namespace?.name || 'Unknown Owner',\n        department: project.namespace?.full_path || 'Unknown Department',\n        description: project.description,\n        repository_url: project.http_url_to_repo,\n        documentation_url: project.wiki_enabled ? `${project.web_url}/-/wikis/home` : undefined,\n        environment: project.default_branch === 'main' || project.default_branch === 'master' ? 'Production' : 'Development',\n        criticality: this.inferCriticality(project),\n        data_classification: project.visibility === 'public' ? 'Public' : 'Internal',\n        created_date: project.created_at ? new Date(project.created_at) : undefined,\n        last_deployment: project.last_activity_at ? new Date(project.last_activity_at) : undefined,\n        source_tool: 'GitLab',\n        source_type: 'GitLab',\n        // Modern fields\n        container_platform: this.detectContainerPlatform(project),\n        cloud_provider: this.detectCloudProvider(project),\n        microservices_architecture: this.detectMicroservices(project),\n        ci_cd_pipeline: this.extractCIPipelineInfo(project),\n        raw_data: {\n          id: project.id,\n          path: project.path,\n          path_with_namespace: project.path_with_namespace,\n          visibility: project.visibility,\n          archived: project.archived,\n          default_branch: project.default_branch,\n          topics: project.topics || project.tag_list,\n          star_count: project.star_count,\n          forks_count: project.forks_count,\n          issues_enabled: project.issues_enabled,\n          merge_requests_enabled: project.merge_requests_enabled,\n          wiki_enabled: project.wiki_enabled,\n          snippets_enabled: project.snippets_enabled,\n          container_registry_enabled: project.container_registry_enabled,\n          packages_enabled: project.packages_enabled,\n          runner_token_expiration_interval: project.runner_token_expiration_interval,\n          ci_config_path: project.ci_config_path,\n          auto_devops_enabled: project.auto_devops_enabled,\n          auto_devops_deploy_strategy: project.auto_devops_deploy_strategy,\n          repository_storage: project.repository_storage,\n          approvals_before_merge: project.approvals_before_merge,\n          mirror: project.mirror,\n          external_authorization_classification_label: project.external_authorization_classification_label\n        }\n      };\n\n      applications.push(application);\n    });\n\n    return applications;\n  }\n\n  private inferApplicationType(project: any): 'Web Application' | 'Mobile App' | 'API' | 'Database' | 'Cloud Service' | 'Desktop App' | 'Microservice' {\n    const name = project.name?.toLowerCase() || '';\n    const description = project.description?.toLowerCase() || '';\n    const topics = project.topics || project.tag_list || [];\n    \n    const text = `${name} ${description} ${topics.join(' ')}`;\n    \n    if (text.includes('mobile') || text.includes('android') || text.includes('ios') || text.includes('flutter') || text.includes('react-native')) return 'Mobile App';\n    if (text.includes('api') || text.includes('service') || text.includes('microservice') || name.includes('api')) return 'API';\n    if (text.includes('database') || text.includes('db') || text.includes('sql') || text.includes('mongodb')) return 'Database';\n    if (text.includes('desktop') || text.includes('electron') || text.includes('qt')) return 'Desktop App';\n    if (text.includes('microservice') || text.includes('micro-service')) return 'Microservice';\n    if (text.includes('cloud') || text.includes('aws') || text.includes('azure') || text.includes('gcp') || text.includes('kubernetes')) return 'Cloud Service';\n    \n    return 'Web Application'; // Default\n  }\n\n  private mapProjectStatus(project: any): 'Ativo' | 'Desenvolvimento' | 'Teste' | 'Descontinuado' | 'Manutenção' {\n    if (project.archived) return 'Descontinuado';\n    \n    // Check last activity\n    const lastActivity = project.last_activity_at ? new Date(project.last_activity_at) : null;\n    const now = new Date();\n    const daysSinceLastActivity = lastActivity ? Math.floor((now.getTime() - lastActivity.getTime()) / (1000 * 60 * 60 * 24)) : 999;\n    \n    if (daysSinceLastActivity > 365) return 'Manutenção'; // No activity for over a year\n    if (daysSinceLastActivity > 90) return 'Teste'; // Limited activity\n    \n    return 'Ativo'; // Active development\n  }\n\n  private inferTechnology(project: any): string {\n    const topics = project.topics || project.tag_list || [];\n    const description = project.description?.toLowerCase() || '';\n    const name = project.name?.toLowerCase() || '';\n    \n    // Check topics first\n    const techTopics = ['javascript', 'typescript', 'python', 'java', 'go', 'rust', 'php', 'ruby', 'csharp', 'cpp', 'react', 'vue', 'angular', 'django', 'flask', 'spring', 'express', 'laravel', 'rails'];\n    for (const topic of topics) {\n      if (techTopics.includes(topic.toLowerCase())) {\n        return topic;\n      }\n    }\n    \n    // Check description and name\n    const text = `${name} ${description}`;\n    if (text.includes('react')) return 'React';\n    if (text.includes('vue')) return 'Vue.js';\n    if (text.includes('angular')) return 'Angular';\n    if (text.includes('python')) return 'Python';\n    if (text.includes('java')) return 'Java';\n    if (text.includes('node')) return 'Node.js';\n    if (text.includes('php')) return 'PHP';\n    if (text.includes('ruby')) return 'Ruby';\n    if (text.includes('go')) return 'Go';\n    if (text.includes('rust')) return 'Rust';\n    \n    return 'Unknown';\n  }\n\n  private inferCriticality(project: any): 'Critical' | 'High' | 'Medium' | 'Low' {\n    const stars = project.star_count || 0;\n    const forks = project.forks_count || 0;\n    const topics = project.topics || project.tag_list || [];\n    \n    // Check for critical indicators in topics\n    const criticalTopics = ['production', 'critical', 'core', 'main', 'primary'];\n    if (topics.some((topic: string) => criticalTopics.includes(topic.toLowerCase()))) {\n      return 'Critical';\n    }\n    \n    const popularity = stars + forks;\n    \n    if (popularity > 500) return 'Critical';\n    if (popularity > 50) return 'High';\n    if (popularity > 5) return 'Medium';\n    \n    return 'Low';\n  }\n\n  private detectContainerPlatform(project: any): string | undefined {\n    const topics = project.topics || project.tag_list || [];\n    const description = project.description?.toLowerCase() || '';\n    const name = project.name?.toLowerCase() || '';\n    \n    const text = `${name} ${description} ${topics.join(' ')}`;\n    \n    if (text.includes('kubernetes') || text.includes('k8s')) return 'Kubernetes';\n    if (text.includes('openshift')) return 'OpenShift';\n    if (text.includes('docker')) return 'Docker';\n    if (project.container_registry_enabled) return 'Docker';\n    \n    return undefined;\n  }\n\n  private detectCloudProvider(project: any): string | undefined {\n    const topics = project.topics || project.tag_list || [];\n    const description = project.description?.toLowerCase() || '';\n    const name = project.name?.toLowerCase() || '';\n    \n    const text = `${name} ${description} ${topics.join(' ')}`;\n    \n    if (text.includes('aws') || text.includes('amazon')) return 'AWS';\n    if (text.includes('azure') || text.includes('microsoft')) return 'Azure';\n    if (text.includes('gcp') || text.includes('google cloud')) return 'GCP';\n    if (text.includes('digitalocean')) return 'DigitalOcean';\n    if (text.includes('heroku')) return 'Heroku';\n    \n    return undefined;\n  }\n\n  private detectMicroservices(project: any): boolean {\n    const topics = project.topics || project.tag_list || [];\n    const description = project.description?.toLowerCase() || '';\n    const name = project.name?.toLowerCase() || '';\n    \n    const text = `${name} ${description} ${topics.join(' ')}`;\n    \n    return text.includes('microservice') || text.includes('micro-service') || text.includes('microservices');\n  }\n\n  private extractCIPipelineInfo(project: any): any {\n    const pipelineInfo: any = {};\n    \n    if (project.ci_config_path) {\n      pipelineInfo.config_path = project.ci_config_path;\n    }\n    \n    if (project.auto_devops_enabled) {\n      pipelineInfo.auto_devops = {\n        enabled: true,\n        deploy_strategy: project.auto_devops_deploy_strategy\n      };\n    }\n    \n    if (project.runner_token_expiration_interval) {\n      pipelineInfo.runner_token_expiration = project.runner_token_expiration_interval;\n    }\n    \n    return Object.keys(pipelineInfo).length > 0 ? pipelineInfo : undefined;\n  }\n}\n"