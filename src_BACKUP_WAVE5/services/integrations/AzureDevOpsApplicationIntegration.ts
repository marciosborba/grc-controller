import { ApplicationData } from '../../types/ApplicationData';\nimport { BaseIntegration } from './BaseIntegration';\n\ninterface AzureDevOpsCredentials {\n  organization: string;\n  token: string; // Personal Access Token\n  projects?: string[];\n}\n\ninterface AzureDevOpsFilters {\n  maxResults?: number;\n  projects?: string[];\n  includeInactive?: boolean;\n}\n\nexport class AzureDevOpsApplicationIntegration extends BaseIntegration {\n  private credentials: AzureDevOpsCredentials;\n  private baseUrl: string;\n\n  constructor(credentials: AzureDevOpsCredentials) {\n    super();\n    this.credentials = credentials;\n    this.baseUrl = `https://dev.azure.com/${credentials.organization}`;\n  }\n\n  async testConnection(): Promise<{ success: boolean; message: string }> {\n    try {\n      const url = `${this.baseUrl}/_apis/projects?api-version=7.0&$top=1`;\n      \n      const auth = Buffer.from(`:${this.credentials.token}`).toString('base64');\n      \n      const response = await this.makeHttpRequest(url, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Basic ${auth}`,\n          'Content-Type': 'application/json'\n        }\n      });\n\n      if (response.count !== undefined) {\n        return {\n          success: true,\n          message: `Conexão estabelecida com sucesso! Organização: ${this.credentials.organization}`\n        };\n      } else {\n        return {\n          success: false,\n          message: 'Falha na autenticação com Azure DevOps'\n        };\n      }\n    } catch (error) {\n      console.error('Azure DevOps connection test failed:', error);\n      return {\n        success: false,\n        message: `Erro de conexão: ${error instanceof Error ? error.message : 'Erro desconhecido'}`\n      };\n    }\n  }\n\n  async getApplications(filters?: AzureDevOpsFilters): Promise<ApplicationData[]> {\n    try {\n      let projects: any[] = [];\n\n      if (filters?.projects || this.credentials.projects) {\n        // Import specific projects\n        const projectList = filters?.projects || this.credentials.projects!;\n        for (const projectName of projectList) {\n          const projectData = await this.getProject(projectName);\n          if (projectData) projects.push(projectData);\n        }\n      } else {\n        // Import all projects\n        projects = await this.getAllProjects(filters);\n      }\n\n      // Get additional details for each project\n      const detailedProjects = await Promise.all(\n        projects.map(async (project) => {\n          const details = await this.getProjectDetails(project.id);\n          return { ...project, ...details };\n        })\n      );\n\n      return this.parseAzureDevOpsProjects(detailedProjects);\n    } catch (error) {\n      console.error('Failed to get Azure DevOps projects:', error);\n      throw error;\n    }\n  }\n\n  private async getProject(projectName: string): Promise<any> {\n    try {\n      const url = `${this.baseUrl}/_apis/projects/${encodeURIComponent(projectName)}?api-version=7.0&includeCapabilities=true&includeHistory=true`;\n      \n      const auth = Buffer.from(`:${this.credentials.token}`).toString('base64');\n      \n      const response = await this.makeHttpRequest(url, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Basic ${auth}`,\n          'Content-Type': 'application/json'\n        }\n      });\n\n      return response;\n    } catch (error) {\n      console.error(`Failed to get project ${projectName}:`, error);\n      return null;\n    }\n  }\n\n  private async getAllProjects(filters?: AzureDevOpsFilters): Promise<any[]> {\n    try {\n      let url = `${this.baseUrl}/_apis/projects?api-version=7.0&includeCapabilities=true&includeHistory=true`;\n      \n      const params = new URLSearchParams();\n      \n      if (!filters?.includeInactive) {\n        params.append('stateFilter', 'wellFormed');\n      }\n      \n      if (filters?.maxResults) {\n        params.append('$top', Math.min(filters.maxResults, 1000).toString());\n      }\n      \n      if (params.toString()) {\n        url += '&' + params.toString();\n      }\n\n      const auth = Buffer.from(`:${this.credentials.token}`).toString('base64');\n      \n      const response = await this.makeHttpRequest(url, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Basic ${auth}`,\n          'Content-Type': 'application/json'\n        }\n      });\n\n      return response.value || [];\n    } catch (error) {\n      console.error('Failed to get all projects:', error);\n      throw error;\n    }\n  }\n\n  private async getProjectDetails(projectId: string): Promise<any> {\n    try {\n      // Get repositories for the project\n      const reposUrl = `${this.baseUrl}/${projectId}/_apis/git/repositories?api-version=7.0`;\n      const buildsUrl = `${this.baseUrl}/${projectId}/_apis/build/definitions?api-version=7.0&$top=10`;\n      const releasesUrl = `${this.baseUrl}/${projectId}/_apis/release/definitions?api-version=7.0&$top=10`;\n      \n      const auth = Buffer.from(`:${this.credentials.token}`).toString('base64');\n      const headers = {\n        'Authorization': `Basic ${auth}`,\n        'Content-Type': 'application/json'\n      };\n\n      const [reposResponse, buildsResponse, releasesResponse] = await Promise.allSettled([\n        this.makeHttpRequest(reposUrl, { method: 'GET', headers }),\n        this.makeHttpRequest(buildsUrl, { method: 'GET', headers }),\n        this.makeHttpRequest(releasesUrl, { method: 'GET', headers })\n      ]);\n\n      return {\n        repositories: reposResponse.status === 'fulfilled' ? reposResponse.value.value || [] : [],\n        buildDefinitions: buildsResponse.status === 'fulfilled' ? buildsResponse.value.value || [] : [],\n        releaseDefinitions: releasesResponse.status === 'fulfilled' ? releasesResponse.value.value || [] : []\n      };\n    } catch (error) {\n      console.error(`Failed to get project details for ${projectId}:`, error);\n      return {\n        repositories: [],\n        buildDefinitions: [],\n        releaseDefinitions: []\n      };\n    }\n  }\n\n  private parseAzureDevOpsProjects(projects: any[]): ApplicationData[] {\n    const applications: ApplicationData[] = [];\n\n    projects.forEach(project => {\n      const application: ApplicationData = {\n        id: project.id || `azure-${project.name}`,\n        name: project.name || 'Unknown Project',\n        type: this.inferApplicationType(project),\n        status: this.mapProjectStatus(project),\n        url: project.url || `${this.baseUrl}/${project.name}`,\n        technology: this.inferTechnology(project),\n        owner: 'Azure DevOps', // Azure DevOps doesn't have a direct owner field\n        description: project.description,\n        repository_url: this.getPrimaryRepositoryUrl(project),\n        environment: 'Production', // Default for Azure DevOps projects\n        criticality: this.inferCriticality(project),\n        data_classification: project.visibility === 'public' ? 'Public' : 'Internal',\n        created_date: project.lastUpdateTime ? new Date(project.lastUpdateTime) : undefined,\n        source_tool: 'Azure DevOps',\n        source_type: 'Azure DevOps',\n        // Modern fields\n        cloud_provider: 'Azure', // Azure DevOps is Microsoft Azure\n        deployment_model: 'Cloud',\n        ci_cd_pipeline: this.extractCIPipelineInfo(project),\n        microservices_architecture: this.detectMicroservices(project),\n        raw_data: {\n          id: project.id,\n          name: project.name,\n          description: project.description,\n          url: project.url,\n          state: project.state,\n          revision: project.revision,\n          visibility: project.visibility,\n          lastUpdateTime: project.lastUpdateTime,\n          capabilities: project.capabilities,\n          defaultTeam: project.defaultTeam,\n          repositories: project.repositories,\n          buildDefinitions: project.buildDefinitions,\n          releaseDefinitions: project.releaseDefinitions\n        }\n      };\n\n      applications.push(application);\n    });\n\n    return applications;\n  }\n\n  private inferApplicationType(project: any): 'Web Application' | 'Mobile App' | 'API' | 'Database' | 'Cloud Service' | 'Desktop App' | 'Microservice' {\n    const name = project.name?.toLowerCase() || '';\n    const description = project.description?.toLowerCase() || '';\n    const repositories = project.repositories || [];\n    \n    const text = `${name} ${description}`;\n    \n    // Check repositories for technology indicators\n    const hasWebTech = repositories.some((repo: any) => {\n      const repoName = repo.name?.toLowerCase() || '';\n      return repoName.includes('web') || repoName.includes('frontend') || repoName.includes('ui');\n    });\n    \n    const hasApiTech = repositories.some((repo: any) => {\n      const repoName = repo.name?.toLowerCase() || '';\n      return repoName.includes('api') || repoName.includes('service') || repoName.includes('backend');\n    });\n    \n    if (text.includes('mobile') || text.includes('android') || text.includes('ios') || text.includes('xamarin')) return 'Mobile App';\n    if (text.includes('api') || text.includes('service') || hasApiTech) return 'API';\n    if (text.includes('database') || text.includes('db') || text.includes('sql')) return 'Database';\n    if (text.includes('desktop') || text.includes('wpf') || text.includes('winforms')) return 'Desktop App';\n    if (text.includes('microservice') || text.includes('micro-service')) return 'Microservice';\n    if (text.includes('cloud') || text.includes('azure') || text.includes('function')) return 'Cloud Service';\n    if (hasWebTech) return 'Web Application';\n    \n    return 'Web Application'; // Default\n  }\n\n  private mapProjectStatus(project: any): 'Ativo' | 'Desenvolvimento' | 'Teste' | 'Descontinuado' | 'Manutenção' {\n    const state = project.state?.toLowerCase() || '';\n    \n    switch (state) {\n      case 'wellformed':\n      case 'createpending':\n        return 'Ativo';\n      case 'deleting':\n      case 'deleted':\n        return 'Descontinuado';\n      default:\n        return 'Ativo';\n    }\n  }\n\n  private inferTechnology(project: any): string {\n    const name = project.name?.toLowerCase() || '';\n    const description = project.description?.toLowerCase() || '';\n    const repositories = project.repositories || [];\n    const buildDefinitions = project.buildDefinitions || [];\n    \n    // Check build definitions for technology indicators\n    const buildTech = buildDefinitions.map((build: any) => build.name?.toLowerCase() || '').join(' ');\n    \n    const text = `${name} ${description} ${buildTech}`;\n    \n    if (text.includes('.net') || text.includes('dotnet') || text.includes('csharp') || text.includes('c#')) return '.NET';\n    if (text.includes('java') || text.includes('spring')) return 'Java';\n    if (text.includes('python') || text.includes('django') || text.includes('flask')) return 'Python';\n    if (text.includes('node') || text.includes('javascript') || text.includes('typescript')) return 'Node.js';\n    if (text.includes('react')) return 'React';\n    if (text.includes('angular')) return 'Angular';\n    if (text.includes('vue')) return 'Vue.js';\n    if (text.includes('php')) return 'PHP';\n    if (text.includes('ruby')) return 'Ruby';\n    if (text.includes('go') || text.includes('golang')) return 'Go';\n    if (text.includes('rust')) return 'Rust';\n    if (text.includes('xamarin')) return 'Xamarin';\n    if (text.includes('unity')) return 'Unity';\n    \n    // Check repositories for language indicators\n    if (repositories.length > 0) {\n      return 'Multiple'; // Multiple repositories might have different technologies\n    }\n    \n    return 'Unknown';\n  }\n\n  private inferCriticality(project: any): 'Critical' | 'High' | 'Medium' | 'Low' {\n    const name = project.name?.toLowerCase() || '';\n    const description = project.description?.toLowerCase() || '';\n    const buildCount = project.buildDefinitions?.length || 0;\n    const releaseCount = project.releaseDefinitions?.length || 0;\n    \n    const text = `${name} ${description}`;\n    \n    if (text.includes('critical') || text.includes('production') || text.includes('core') || text.includes('main')) return 'Critical';\n    if (text.includes('important') || text.includes('primary') || buildCount > 5 || releaseCount > 3) return 'High';\n    if (text.includes('support') || text.includes('secondary') || buildCount > 2 || releaseCount > 1) return 'Medium';\n    if (text.includes('test') || text.includes('demo') || text.includes('poc') || text.includes('prototype')) return 'Low';\n    \n    return 'Medium'; // Default\n  }\n\n  private getPrimaryRepositoryUrl(project: any): string | undefined {\n    const repositories = project.repositories || [];\n    if (repositories.length > 0) {\n      return repositories[0].webUrl || repositories[0].remoteUrl;\n    }\n    return undefined;\n  }\n\n  private detectMicroservices(project: any): boolean {\n    const name = project.name?.toLowerCase() || '';\n    const description = project.description?.toLowerCase() || '';\n    const repositories = project.repositories || [];\n    \n    const text = `${name} ${description}`;\n    \n    // Check if project has multiple repositories (common in microservices)\n    const hasMultipleRepos = repositories.length > 3;\n    \n    return text.includes('microservice') || text.includes('micro-service') || text.includes('microservices') || hasMultipleRepos;\n  }\n\n  private extractCIPipelineInfo(project: any): any {\n    const pipelineInfo: any = {};\n    \n    const buildDefinitions = project.buildDefinitions || [];\n    const releaseDefinitions = project.releaseDefinitions || [];\n    \n    if (buildDefinitions.length > 0) {\n      pipelineInfo.build_pipelines = buildDefinitions.map((build: any) => ({\n        id: build.id,\n        name: build.name,\n        type: build.type,\n        quality: build.quality,\n        queue: build.queue?.name\n      }));\n    }\n    \n    if (releaseDefinitions.length > 0) {\n      pipelineInfo.release_pipelines = releaseDefinitions.map((release: any) => ({\n        id: release.id,\n        name: release.name,\n        source: release.source,\n        revision: release.revision\n      }));\n    }\n    \n    if (buildDefinitions.length > 0 || releaseDefinitions.length > 0) {\n      pipelineInfo.has_ci_cd = true;\n      pipelineInfo.pipeline_count = buildDefinitions.length + releaseDefinitions.length;\n    }\n    \n    return Object.keys(pipelineInfo).length > 0 ? pipelineInfo : undefined;\n  }\n}\n"