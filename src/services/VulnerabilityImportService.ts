// =====================================================
// VULNERABILITY IMPORT SERVICE
// =====================================================
// Serviço principal para gerenciar importações de vulnerabilidades

import { supabase } from '@/integrations/supabase/client';
import { 
  ImportConfiguration, 
  ImportJob, 
  ImportPreview, 
  ParsedVulnerability,
  ConnectionConfig,
  FieldMapping,
  ImportSettings,
  ImportSourceType,
  APIResponse
} from '@/components/vulnerabilities/import/types/import';

// Importar conectores
import { createNessusConnector } from '@/components/vulnerabilities/import/connectors/NessusConnector';
import { createQualysConnector } from '@/components/vulnerabilities/import/connectors/QualysConnector';
import { createGenericAPIConnector } from '@/components/vulnerabilities/import/connectors/GenericAPIConnector';

// Importar parsers
import { parseNessusFile } from '@/components/vulnerabilities/import/parsers/NessusParser';

export class VulnerabilityImportService {
  private tenantId: string;
  private userId: string;

  constructor(tenantId: string, userId: string) {
    this.tenantId = tenantId;
    this.userId = userId;
  }

  /**
   * Cria uma nova configuração de importação
   */
  async createImportConfiguration(config: Omit<ImportConfiguration, 'id' | 'created_at' | 'updated_at'>): Promise<APIResponse<ImportConfiguration>> {
    try {
      const { data, error } = await supabase
        .from('import_configurations')
        .insert({
          ...config,
          tenant_id: this.tenantId,
          created_by: this.userId
        })
        .select()
        .single();

      if (error) throw error;

      return {
        success: true,
        data: data as ImportConfiguration
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro ao criar configuração'
      };
    }
  }

  /**
   * Lista configurações de importação
   */
  async getImportConfigurations(): Promise<APIResponse<ImportConfiguration[]>> {
    try {
      const { data, error } = await supabase
        .from('import_configurations')
        .select('*')
        .eq('tenant_id', this.tenantId)
        .eq('is_active', true)
        .order('created_at', { ascending: false });

      if (error) throw error;

      return {
        success: true,
        data: data as ImportConfiguration[]
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro ao obter configurações'
      };
    }
  }

  /**
   * Testa conexão com fonte de dados
   */
  async testConnection(sourceType: ImportSourceType, config: ConnectionConfig): Promise<APIResponse> {
    try {
      let result: APIResponse;

      switch (sourceType) {
        case 'nessus_api':
          const nessusConnector = createNessusConnector(config);
          result = await nessusConnector.testConnection();
          await nessusConnector.logout();
          break;

        case 'qualys_api':
          const qualysConnector = createQualysConnector(config);
          result = await qualysConnector.testConnection();
          break;

        case 'generic_api':
          const genericConnector = createGenericAPIConnector(config);
          result = await genericConnector.testConnection();
          break;

        default:
          result = {
            success: false,
            error: `Teste de conexão não implementado para ${sourceType}`
          };
      }

      return result;
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro no teste de conexão'
      };
    }
  }

  /**
   * Gera preview de importação
   */
  async generatePreview(
    sourceType: ImportSourceType,
    config: ConnectionConfig,
    file?: File
  ): Promise<APIResponse<ImportPreview>> {
    try {
      let vulnerabilities: ParsedVulnerability[] = [];

      if (file) {
        // Importação por arquivo
        vulnerabilities = await this.parseFile(sourceType, file);
      } else {
        // Importação por API
        vulnerabilities = await this.fetchFromAPI(sourceType, config);
      }

      // Gerar preview
      const preview: ImportPreview = {
        source_type: sourceType,
        total_records: vulnerabilities.length,
        sample_records: vulnerabilities.slice(0, 10).map(v => v.raw_data),
        detected_fields: this.extractFields(vulnerabilities),
        field_mapping_suggestions: this.generateFieldMappingSuggestions(sourceType),
        validation_results: this.validateVulnerabilities(vulnerabilities),
        estimated_import_time: Math.ceil(vulnerabilities.length / 10) // 10 records per second
      };

      return {
        success: true,
        data: preview
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro ao gerar preview'
      };
    }
  }

  /**
   * Inicia processo de importação
   */
  async startImport(
    sourceType: ImportSourceType,
    config: ConnectionConfig,
    fieldMapping: FieldMapping,
    settings: ImportSettings,
    file?: File
  ): Promise<APIResponse<ImportJob>> {
    try {
      // Criar job de importação
      const { data: job, error: jobError } = await supabase
        .from('import_jobs')
        .insert({
          tenant_id: this.tenantId,
          source_type: sourceType,
          status: 'pending',
          file_name: file?.name,
          file_size: file?.size,
          source_info: { config, fieldMapping, settings },
          created_by: this.userId
        })
        .select()
        .single();

      if (jobError) throw jobError;

      // Processar importação em background
      this.processImportJob(job.id, sourceType, config, fieldMapping, settings, file);

      return {
        success: true,
        data: job as ImportJob
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro ao iniciar importação'
      };
    }
  }

  /**
   * Processa job de importação
   */
  private async processImportJob(
    jobId: string,
    sourceType: ImportSourceType,
    config: ConnectionConfig,
    fieldMapping: FieldMapping,
    settings: ImportSettings,
    file?: File
  ): Promise<void> {
    try {
      // Atualizar status para processando
      await this.updateJobStatus(jobId, 'processing');

      // Obter vulnerabilidades
      let vulnerabilities: ParsedVulnerability[] = [];
      
      if (file) {
        vulnerabilities = await this.parseFile(sourceType, file);
      } else {
        vulnerabilities = await this.fetchFromAPI(sourceType, config);
      }

      // Aplicar filtros
      vulnerabilities = this.applyFilters(vulnerabilities, settings);

      // Mapear campos
      const mappedVulnerabilities = this.mapFields(vulnerabilities, fieldMapping);

      // Importar em lotes
      const batchSize = settings.batch_size || 100;
      let successCount = 0;
      let errorCount = 0;
      const errors: any[] = [];

      for (let i = 0; i < mappedVulnerabilities.length; i += batchSize) {
        const batch = mappedVulnerabilities.slice(i, i + batchSize);
        
        try {
          const result = await this.importBatch(batch, jobId);
          successCount += result.success;
          errorCount += result.errors;
          errors.push(...result.errorDetails);

          // Atualizar progresso
          await this.updateJobProgress(jobId, i + batch.length, successCount, errorCount);
        } catch (error) {
          console.error('Erro no lote:', error);
          errorCount += batch.length;
        }
      }

      // Finalizar job
      await this.completeJob(jobId, successCount, errorCount, errors);

    } catch (error) {
      await this.failJob(jobId, error instanceof Error ? error.message : 'Erro desconhecido');
    }
  }

  /**
   * Parse de arquivo baseado no tipo
   */
  private async parseFile(sourceType: ImportSourceType, file: File): Promise<ParsedVulnerability[]> {
    const content = await this.readFileContent(file);

    switch (sourceType) {
      case 'nessus_file':
        return parseNessusFile(content);
      
      case 'csv_file':
        return this.parseCSVFile(content);
      
      case 'json_file':
        return this.parseJSONFile(content);
      
      default:
        throw new Error(`Parser não implementado para ${sourceType}`);
    }
  }

  /**
   * Busca dados via API
   */
  private async fetchFromAPI(sourceType: ImportSourceType, config: ConnectionConfig): Promise<ParsedVulnerability[]> {
    switch (sourceType) {
      case 'nessus_api':
        const nessusConnector = createNessusConnector(config);
        const nessusResult = await nessusConnector.getAllVulnerabilities();
        await nessusConnector.logout();
        
        if (!nessusResult.success || !nessusResult.data) {
          throw new Error(nessusResult.error || 'Erro ao obter dados do Nessus');
        }
        return nessusResult.data;

      case 'qualys_api':
        const qualysConnector = createQualysConnector(config);
        const qualysResult = await qualysConnector.getAllVulnerabilities();
        
        if (!qualysResult.success || !qualysResult.data) {
          throw new Error(qualysResult.error || 'Erro ao obter dados do Qualys');
        }
        return qualysResult.data;

      case 'generic_api':
        const genericConnector = createGenericAPIConnector(config);
        const genericResult = await genericConnector.getAllVulnerabilities();
        
        if (!genericResult.success || !genericResult.data) {
          throw new Error(genericResult.error || 'Erro ao obter dados da API');
        }
        return genericResult.data;

      default:
        throw new Error(`Conector não implementado para ${sourceType}`);
    }
  }

  /**
   * Lê conteúdo do arquivo
   */
  private readFileContent(file: File): Promise<string> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => resolve(e.target?.result as string);
      reader.onerror = () => reject(new Error('Erro ao ler arquivo'));
      reader.readAsText(file);
    });
  }

  /**
   * Parse de arquivo CSV
   */
  private parseCSVFile(content: string): ParsedVulnerability[] {
    const lines = content.split('\n').filter(line => line.trim());
    if (lines.length < 2) throw new Error('Arquivo CSV deve ter pelo menos cabeçalho e uma linha');
    
    const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
    const vulnerabilities: ParsedVulnerability[] = [];
    
    for (let i = 1; i < lines.length; i++) {
      const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
      const record: any = {};
      
      headers.forEach((header, index) => {
        record[header] = values[index] || '';
      });
      
      vulnerabilities.push({
        raw_data: record,
        title: record.title || record.name || `Vulnerabilidade ${i}`,
        description: record.description || '',
        severity: this.normalizeSeverity(record.severity || 'Info'),
        cvss_score: record.cvss_score ? parseFloat(record.cvss_score) : undefined,
        asset_name: record.asset_name || record.host || '',
        source_tool: 'CSV Import',
        is_valid: !!(record.title || record.name),
        validation_errors: [],
        validation_warnings: []
      });
    }
    
    return vulnerabilities;
  }

  /**
   * Parse de arquivo JSON
   */
  private parseJSONFile(content: string): ParsedVulnerability[] {
    const data = JSON.parse(content);
    const records = Array.isArray(data) ? data : [data];
    
    return records.map((record, index) => ({
      raw_data: record,
      title: record.title || record.name || `Vulnerabilidade ${index + 1}`,
      description: record.description || '',
      severity: this.normalizeSeverity(record.severity || 'Info'),
      cvss_score: record.cvss_score ? parseFloat(record.cvss_score) : undefined,
      asset_name: record.asset_name || record.host || '',
      source_tool: 'JSON Import',
      is_valid: !!(record.title || record.name),
      validation_errors: [],
      validation_warnings: []
    }));
  }

  /**
   * Normaliza severidade
   */
  private normalizeSeverity(severity: string): string {
    const severityStr = severity.toLowerCase();
    if (severityStr.includes('critical') || severityStr === '5') return 'Critical';
    if (severityStr.includes('high') || severityStr === '4') return 'High';
    if (severityStr.includes('medium') || severityStr === '3') return 'Medium';
    if (severityStr.includes('low') || severityStr === '2') return 'Low';
    return 'Info';
  }

  /**
   * Extrai campos detectados
   */
  private extractFields(vulnerabilities: ParsedVulnerability[]): string[] {
    if (vulnerabilities.length === 0) return [];
    
    const fields = new Set<string>();
    vulnerabilities.slice(0, 5).forEach(vuln => {
      Object.keys(vuln.raw_data).forEach(key => fields.add(key));
    });
    
    return Array.from(fields);
  }

  /**
   * Gera sugestões de mapeamento de campos
   */
  private generateFieldMappingSuggestions(sourceType: ImportSourceType): Partial<FieldMapping> {
    // Retornar mapeamentos padrão baseados no tipo de fonte
    const mappings: Record<string, Partial<FieldMapping>> = {
      nessus_file: {
        title: 'pluginName',
        description: 'description',
        severity: 'severity',
        asset_name: 'host',
        source_tool: 'Nessus'
      },
      qualys_file: {
        title: 'TITLE',
        description: 'DIAGNOSIS',
        severity: 'SEVERITY',
        asset_name: 'IP',
        source_tool: 'Qualys'
      }
    };

    return mappings[sourceType] || {};
  }

  /**
   * Valida vulnerabilidades
   */
  private validateVulnerabilities(vulnerabilities: ParsedVulnerability[]) {
    const validRecords = vulnerabilities.filter(v => v.is_valid).length;
    const invalidRecords = vulnerabilities.length - validRecords;
    
    return {
      valid_records: validRecords,
      invalid_records: invalidRecords,
      warnings: [],
      errors: []
    };
  }

  /**
   * Aplica filtros de importação
   */
  private applyFilters(vulnerabilities: ParsedVulnerability[], settings: ImportSettings): ParsedVulnerability[] {
    let filtered = vulnerabilities;

    // Filtro por severidade
    if (settings.severity_filter?.length) {
      filtered = filtered.filter(v => 
        v.severity && settings.severity_filter!.includes(v.severity)
      );
    }

    // Filtro por data
    if (settings.date_filter?.start_date || settings.date_filter?.end_date) {
      filtered = filtered.filter(v => {
        if (!v.first_found) return true;
        
        const vulnDate = new Date(v.first_found);
        if (settings.date_filter?.start_date && vulnDate < settings.date_filter.start_date) {
          return false;
        }
        if (settings.date_filter?.end_date && vulnDate > settings.date_filter.end_date) {
          return false;
        }
        return true;
      });
    }

    // Limite máximo de registros
    if (settings.max_records && filtered.length > settings.max_records) {
      filtered = filtered.slice(0, settings.max_records);
    }

    return filtered;
  }

  /**
   * Mapeia campos usando configuração
   */
  private mapFields(vulnerabilities: ParsedVulnerability[], mapping: FieldMapping): any[] {
    return vulnerabilities.map(vuln => {
      const mapped: any = {
        tenant_id: this.tenantId,
        created_by: this.userId,
        updated_by: this.userId
      };

      // Mapear campos obrigatórios
      mapped.title = this.getFieldValue(vuln.raw_data, mapping.title) || vuln.title;
      mapped.description = this.getFieldValue(vuln.raw_data, mapping.description) || vuln.description;
      mapped.severity = this.getFieldValue(vuln.raw_data, mapping.severity) || vuln.severity;
      mapped.asset_name = this.getFieldValue(vuln.raw_data, mapping.asset_name) || vuln.asset_name;
      mapped.source_tool = this.getFieldValue(vuln.raw_data, mapping.source_tool) || vuln.source_tool;

      // Mapear campos opcionais
      if (mapping.cvss_score) {
        const cvssValue = this.getFieldValue(vuln.raw_data, mapping.cvss_score);
        mapped.cvss_score = cvssValue ? parseFloat(cvssValue) : vuln.cvss_score;
      }

      if (mapping.cve_id) {
        mapped.cve_id = this.getFieldValue(vuln.raw_data, mapping.cve_id) || vuln.cve_id;
      }

      if (mapping.asset_ip) {
        mapped.asset_ip = this.getFieldValue(vuln.raw_data, mapping.asset_ip) || vuln.asset_ip;
      }

      if (mapping.port) {
        const portValue = this.getFieldValue(vuln.raw_data, mapping.port);
        mapped.port = portValue ? parseInt(portValue) : vuln.port;
      }

      if (mapping.protocol) {
        mapped.protocol = this.getFieldValue(vuln.raw_data, mapping.protocol) || vuln.protocol;
      }

      if (mapping.solution) {
        mapped.solution = this.getFieldValue(vuln.raw_data, mapping.solution) || vuln.solution;
      }

      // Dados brutos para referência
      mapped.raw_data = vuln.raw_data;

      return mapped;
    });
  }

  /**
   * Obtém valor do campo mapeado
   */
  private getFieldValue(data: any, fieldPath: string): any {
    if (!fieldPath) return undefined;
    
    // Suporte para caminhos aninhados (ex: "host.ip")
    return fieldPath.split('.').reduce((obj, key) => obj?.[key], data);
  }

  /**
   * Importa lote de vulnerabilidades
   */
  private async importBatch(vulnerabilities: any[], jobId: string): Promise<{
    success: number;
    errors: number;
    errorDetails: any[];
  }> {
    const result = {
      success: 0,
      errors: 0,
      errorDetails: [] as any[]
    };

    // Adicionar job_id a cada vulnerabilidade
    const vulnsWithJobId = vulnerabilities.map(v => ({
      ...v,
      import_job_id: jobId
    }));

    try {
      const { data, error } = await supabase
        .from('vulnerabilities')
        .insert(vulnsWithJobId)
        .select('id');

      if (error) {
        result.errors = vulnerabilities.length;
        result.errorDetails.push({
          message: error.message,
          count: vulnerabilities.length
        });
      } else {
        result.success = data?.length || 0;
      }
    } catch (error) {
      result.errors = vulnerabilities.length;
      result.errorDetails.push({
        message: error instanceof Error ? error.message : 'Erro desconhecido',
        count: vulnerabilities.length
      });
    }

    return result;
  }

  /**
   * Atualiza status do job
   */
  private async updateJobStatus(jobId: string, status: string): Promise<void> {
    await supabase
      .from('import_jobs')
      .update({ status })
      .eq('id', jobId);
  }

  /**
   * Atualiza progresso do job
   */
  private async updateJobProgress(
    jobId: string, 
    processed: number, 
    successful: number, 
    failed: number
  ): Promise<void> {
    await supabase
      .from('import_jobs')
      .update({
        processed_records: processed,
        successful_imports: successful,
        failed_imports: failed
      })
      .eq('id', jobId);
  }

  /**
   * Completa job com sucesso
   */
  private async completeJob(
    jobId: string, 
    successful: number, 
    failed: number, 
    errors: any[]
  ): Promise<void> {
    await supabase
      .from('import_jobs')
      .update({
        status: 'completed',
        completed_at: new Date().toISOString(),
        successful_imports: successful,
        failed_imports: failed,
        errors: errors
      })
      .eq('id', jobId);
  }

  /**
   * Marca job como falhou
   */
  private async failJob(jobId: string, errorMessage: string): Promise<void> {
    await supabase
      .from('import_jobs')
      .update({
        status: 'failed',
        completed_at: new Date().toISOString(),
        errors: [{ message: errorMessage, timestamp: new Date().toISOString() }]
      })
      .eq('id', jobId);
  }

  /**
   * Obtém histórico de jobs
   */
  async getImportJobs(): Promise<APIResponse<ImportJob[]>> {
    try {
      const { data, error } = await supabase
        .from('import_jobs')
        .select('*')
        .eq('tenant_id', this.tenantId)
        .order('created_at', { ascending: false })
        .limit(50);

      if (error) throw error;

      return {
        success: true,
        data: data as ImportJob[]
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro ao obter jobs'
      };
    }
  }

  /**
   * Obtém estatísticas de importação
   */
  async getImportStatistics(days: number = 30): Promise<APIResponse<any>> {
    try {
      const { data, error } = await supabase
        .rpc('get_import_statistics', {
          p_tenant_id: this.tenantId,
          p_days: days
        });

      if (error) throw error;

      return {
        success: true,
        data: data[0] || {
          total_jobs: 0,
          successful_jobs: 0,
          failed_jobs: 0,
          total_vulnerabilities: 0,
          avg_processing_time: null
        }
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro ao obter estatísticas'
      };
    }
  }
}

/**
 * Função utilitária para criar instância do serviço
 */
export const createImportService = (tenantId: string, userId: string): VulnerabilityImportService => {
  return new VulnerabilityImportService(tenantId, userId);
};