/**\n * üöÄ ENCRYPTION CACHE SYSTEM\n * \n * Sistema de cache otimizado para chaves de criptografia por tenant.\n * Implementa estrat√©gias avan√ßadas de cache para m√°xima performance.\n */\n\nimport { EncryptionPurpose } from './tenantCrypto';\n\n// ============================================================================\n// INTERFACES E TIPOS\n// ============================================================================\n\ninterface CacheEntry<T> {\n  data: T;\n  expires: number;\n  accessCount: number;\n  lastAccessed: number;\n  size: number; // Tamanho em bytes\n  priority: number; // 1-10, maior = mais importante\n}\n\ninterface CacheStats {\n  size: number;\n  maxSize: number;\n  hitCount: number;\n  missCount: number;\n  hitRate: number;\n  evictionCount: number;\n  memoryUsage: number;\n  averageAccessTime: number;\n}\n\ninterface CacheConfig {\n  maxSize: number;\n  ttlMs: number;\n  maxMemoryMB: number;\n  cleanupIntervalMs: number;\n  compressionEnabled: boolean;\n  persistToDisk: boolean;\n}\n\n// ============================================================================\n// CACHE AVAN√áADO COM M√öLTIPLAS ESTRAT√âGIAS\n// ============================================================================\n\nexport class AdvancedEncryptionCache {\n  private cache = new Map<string, CacheEntry<any>>();\n  private stats: CacheStats;\n  private config: CacheConfig;\n  private cleanupTimer?: NodeJS.Timeout;\n  private accessTimes: number[] = [];\n\n  constructor(config: Partial<CacheConfig> = {}) {\n    this.config = {\n      maxSize: 1000,\n      ttlMs: 3600000, // 1 hora\n      maxMemoryMB: 50,\n      cleanupIntervalMs: 300000, // 5 minutos\n      compressionEnabled: true,\n      persistToDisk: false,\n      ...config\n    };\n\n    this.stats = {\n      size: 0,\n      maxSize: this.config.maxSize,\n      hitCount: 0,\n      missCount: 0,\n      hitRate: 0,\n      evictionCount: 0,\n      memoryUsage: 0,\n      averageAccessTime: 0\n    };\n\n    this.startCleanupTimer();\n  }\n\n  // ========================================================================\n  // M√âTODOS PRINCIPAIS\n  // ========================================================================\n\n  /**\n   * Obt√©m item do cache\n   */\n  get<T>(key: string): T | null {\n    const startTime = performance.now();\n    \n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      this.stats.missCount++;\n      this.updateStats();\n      return null;\n    }\n\n    // Verificar expira√ß√£o\n    if (entry.expires <= Date.now()) {\n      this.cache.delete(key);\n      this.stats.missCount++;\n      this.stats.evictionCount++;\n      this.updateStats();\n      return null;\n    }\n\n    // Atualizar estat√≠sticas de acesso\n    entry.accessCount++;\n    entry.lastAccessed = Date.now();\n    this.stats.hitCount++;\n    \n    const accessTime = performance.now() - startTime;\n    this.recordAccessTime(accessTime);\n    \n    this.updateStats();\n    \n    return this.decompress(entry.data);\n  }\n\n  /**\n   * Armazena item no cache\n   */\n  set<T>(key: string, data: T, options?: { ttl?: number; priority?: number }): boolean {\n    try {\n      const ttl = options?.ttl || this.config.ttlMs;\n      const priority = options?.priority || 5;\n      const compressedData = this.compress(data);\n      const size = this.estimateSize(compressedData);\n\n      // Verificar limites de mem√≥ria\n      if (this.stats.memoryUsage + size > this.config.maxMemoryMB * 1024 * 1024) {\n        this.evictByMemory();\n      }\n\n      // Verificar limite de tamanho\n      if (this.cache.size >= this.config.maxSize) {\n        this.evictLRU();\n      }\n\n      const entry: CacheEntry<T> = {\n        data: compressedData,\n        expires: Date.now() + ttl,\n        accessCount: 1,\n        lastAccessed: Date.now(),\n        size,\n        priority\n      };\n\n      this.cache.set(key, entry);\n      this.stats.memoryUsage += size;\n      this.updateStats();\n\n      return true;\n\n    } catch (error) {\n      console.error('‚ùå Erro ao armazenar no cache:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Remove item do cache\n   */\n  delete(key: string): boolean {\n    const entry = this.cache.get(key);\n    if (entry) {\n      this.stats.memoryUsage -= entry.size;\n      this.cache.delete(key);\n      this.updateStats();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Limpa cache por padr√£o\n   */\n  clear(pattern?: string): number {\n    let deletedCount = 0;\n    \n    if (pattern) {\n      const regex = new RegExp(pattern);\n      for (const [key, entry] of this.cache) {\n        if (regex.test(key)) {\n          this.stats.memoryUsage -= entry.size;\n          this.cache.delete(key);\n          deletedCount++;\n        }\n      }\n    } else {\n      deletedCount = this.cache.size;\n      this.cache.clear();\n      this.stats.memoryUsage = 0;\n    }\n\n    this.updateStats();\n    return deletedCount;\n  }\n\n  // ========================================================================\n  // M√âTODOS ESPEC√çFICOS PARA TENANT CRYPTO\n  // ========================================================================\n\n  /**\n   * Gera chave de cache para tenant crypto\n   */\n  private getTenantCacheKey(\n    tenantId: string, \n    purpose: EncryptionPurpose, \n    operation: 'encrypt' | 'decrypt',\n    dataHash?: string\n  ): string {\n    const base = `tenant:${tenantId}:${purpose}:${operation}`;\n    return dataHash ? `${base}:${dataHash}` : base;\n  }\n\n  /**\n   * Cache espec√≠fico para chaves de tenant\n   */\n  setTenantKey(\n    tenantId: string,\n    purpose: EncryptionPurpose,\n    keyData: any,\n    ttl?: number\n  ): boolean {\n    const key = this.getTenantCacheKey(tenantId, purpose, 'encrypt');\n    return this.set(key, keyData, { ttl, priority: 8 }); // Alta prioridade para chaves\n  }\n\n  /**\n   * Obt√©m chave de tenant do cache\n   */\n  getTenantKey(tenantId: string, purpose: EncryptionPurpose): any | null {\n    const key = this.getTenantCacheKey(tenantId, purpose, 'encrypt');\n    return this.get(key);\n  }\n\n  /**\n   * Cache para resultados de criptografia\n   */\n  setCryptoResult(\n    tenantId: string,\n    purpose: EncryptionPurpose,\n    operation: 'encrypt' | 'decrypt',\n    inputHash: string,\n    result: string\n  ): boolean {\n    const key = this.getTenantCacheKey(tenantId, purpose, operation, inputHash);\n    return this.set(key, result, { priority: 6 }); // Prioridade m√©dia\n  }\n\n  /**\n   * Obt√©m resultado de criptografia do cache\n   */\n  getCryptoResult(\n    tenantId: string,\n    purpose: EncryptionPurpose,\n    operation: 'encrypt' | 'decrypt',\n    inputHash: string\n  ): string | null {\n    const key = this.getTenantCacheKey(tenantId, purpose, operation, inputHash);\n    return this.get(key);\n  }\n\n  /**\n   * Invalida cache de um tenant espec√≠fico\n   */\n  invalidateTenant(tenantId: string, purpose?: EncryptionPurpose): number {\n    const pattern = purpose \n      ? `tenant:${tenantId}:${purpose}:.*`\n      : `tenant:${tenantId}:.*`;\n    return this.clear(pattern);\n  }\n\n  // ========================================================================\n  // ESTRAT√âGIAS DE EVICTION\n  // ========================================================================\n\n  /**\n   * Eviction por LRU (Least Recently Used)\n   */\n  private evictLRU(): void {\n    const entries = Array.from(this.cache.entries())\n      .sort((a, b) => a[1].lastAccessed - b[1].lastAccessed);\n    \n    const toEvict = Math.ceil(this.config.maxSize * 0.1); // Remove 10%\n    \n    for (let i = 0; i < toEvict && i < entries.length; i++) {\n      const [key, entry] = entries[i];\n      this.stats.memoryUsage -= entry.size;\n      this.cache.delete(key);\n      this.stats.evictionCount++;\n    }\n  }\n\n  /**\n   * Eviction por uso de mem√≥ria\n   */\n  private evictByMemory(): void {\n    const targetMemory = this.config.maxMemoryMB * 1024 * 1024 * 0.8; // 80% do limite\n    \n    const entries = Array.from(this.cache.entries())\n      .sort((a, b) => {\n        // Priorizar por: baixa prioridade, pouco uso, mais antigo\n        const scoreA = a[1].priority * a[1].accessCount / (Date.now() - a[1].lastAccessed);\n        const scoreB = b[1].priority * b[1].accessCount / (Date.now() - b[1].lastAccessed);\n        return scoreA - scoreB;\n      });\n    \n    for (const [key, entry] of entries) {\n      if (this.stats.memoryUsage <= targetMemory) break;\n      \n      this.stats.memoryUsage -= entry.size;\n      this.cache.delete(key);\n      this.stats.evictionCount++;\n    }\n  }\n\n  /**\n   * Limpeza de itens expirados\n   */\n  private cleanupExpired(): number {\n    const now = Date.now();\n    let cleanedCount = 0;\n    \n    for (const [key, entry] of this.cache) {\n      if (entry.expires <= now) {\n        this.stats.memoryUsage -= entry.size;\n        this.cache.delete(key);\n        cleanedCount++;\n      }\n    }\n    \n    this.stats.evictionCount += cleanedCount;\n    this.updateStats();\n    \n    return cleanedCount;\n  }\n\n  // ========================================================================\n  // COMPRESS√ÉO E UTILIT√ÅRIOS\n  // ========================================================================\n\n  /**\n   * Comprime dados se habilitado\n   */\n  private compress<T>(data: T): T {\n    if (!this.config.compressionEnabled) {\n      return data;\n    }\n\n    try {\n      // Implementa√ß√£o simples de compress√£o (em produ√ß√£o usar biblioteca espec√≠fica)\n      if (typeof data === 'string' && data.length > 100) {\n        // Simular compress√£o\n        return data as T;\n      }\n      return data;\n    } catch {\n      return data;\n    }\n  }\n\n  /**\n   * Descomprime dados\n   */\n  private decompress<T>(data: T): T {\n    if (!this.config.compressionEnabled) {\n      return data;\n    }\n\n    try {\n      // Implementa√ß√£o de descompress√£o\n      return data;\n    } catch {\n      return data;\n    }\n  }\n\n  /**\n   * Estima tamanho dos dados\n   */\n  private estimateSize(data: any): number {\n    try {\n      return JSON.stringify(data).length * 2; // Estimativa aproximada\n    } catch {\n      return 1000; // Fallback\n    }\n  }\n\n  /**\n   * Registra tempo de acesso\n   */\n  private recordAccessTime(time: number): void {\n    this.accessTimes.push(time);\n    \n    // Manter apenas os √∫ltimos 1000 tempos\n    if (this.accessTimes.length > 1000) {\n      this.accessTimes = this.accessTimes.slice(-1000);\n    }\n  }\n\n  /**\n   * Atualiza estat√≠sticas\n   */\n  private updateStats(): void {\n    this.stats.size = this.cache.size;\n    this.stats.hitRate = this.stats.hitCount + this.stats.missCount > 0 \n      ? (this.stats.hitCount / (this.stats.hitCount + this.stats.missCount)) * 100 \n      : 0;\n    \n    if (this.accessTimes.length > 0) {\n      this.stats.averageAccessTime = this.accessTimes.reduce((a, b) => a + b, 0) / this.accessTimes.length;\n    }\n  }\n\n  /**\n   * Inicia timer de limpeza\n   */\n  private startCleanupTimer(): void {\n    this.cleanupTimer = setInterval(() => {\n      const cleaned = this.cleanupExpired();\n      if (cleaned > 0) {\n        // Cache cleanup: ${cleaned} itens expirados removidos\n      }\n    }, this.config.cleanupIntervalMs);\n  }\n\n  // ========================================================================\n  // M√âTODOS P√öBLICOS DE MONITORAMENTO\n  // ========================================================================\n\n  /**\n   * Obt√©m estat√≠sticas do cache\n   */\n  getStats(): CacheStats {\n    this.updateStats();\n    return { ...this.stats };\n  }\n\n  /**\n   * Obt√©m configura√ß√£o atual\n   */\n  getConfig(): CacheConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Atualiza configura√ß√£o\n   */\n  updateConfig(newConfig: Partial<CacheConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n    this.stats.maxSize = this.config.maxSize;\n    \n    // Reiniciar timer se intervalo mudou\n    if (newConfig.cleanupIntervalMs && this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.startCleanupTimer();\n    }\n  }\n\n  /**\n   * Obt√©m informa√ß√µes detalhadas de uma entrada\n   */\n  getEntryInfo(key: string): CacheEntry<any> | null {\n    const entry = this.cache.get(key);\n    return entry ? { ...entry } : null;\n  }\n\n  /**\n   * Lista todas as chaves do cache\n   */\n  getKeys(pattern?: string): string[] {\n    const keys = Array.from(this.cache.keys());\n    \n    if (pattern) {\n      const regex = new RegExp(pattern);\n      return keys.filter(key => regex.test(key));\n    }\n    \n    return keys;\n  }\n\n  /**\n   * For√ßa limpeza manual\n   */\n  forceCleanup(): { expired: number; evicted: number } {\n    const expired = this.cleanupExpired();\n    \n    let evicted = 0;\n    if (this.cache.size > this.config.maxSize) {\n      const sizeBefore = this.cache.size;\n      this.evictLRU();\n      evicted = sizeBefore - this.cache.size;\n    }\n    \n    return { expired, evicted };\n  }\n\n  /**\n   * Exporta dados do cache (para backup)\n   */\n  export(): any {\n    const data: any = {};\n    \n    for (const [key, entry] of this.cache) {\n      data[key] = {\n        data: entry.data,\n        expires: entry.expires,\n        accessCount: entry.accessCount,\n        priority: entry.priority\n      };\n    }\n    \n    return {\n      data,\n      stats: this.stats,\n      config: this.config,\n      exportedAt: Date.now()\n    };\n  }\n\n  /**\n   * Importa dados do cache (para restore)\n   */\n  import(exportedData: any): boolean {\n    try {\n      this.cache.clear();\n      this.stats.memoryUsage = 0;\n      \n      for (const [key, entry] of Object.entries(exportedData.data)) {\n        const cacheEntry = entry as any;\n        const size = this.estimateSize(cacheEntry.data);\n        \n        this.cache.set(key, {\n          data: cacheEntry.data,\n          expires: cacheEntry.expires,\n          accessCount: cacheEntry.accessCount || 1,\n          lastAccessed: Date.now(),\n          size,\n          priority: cacheEntry.priority || 5\n        });\n        \n        this.stats.memoryUsage += size;\n      }\n      \n      this.updateStats();\n      return true;\n      \n    } catch (error) {\n      console.error('‚ùå Erro ao importar cache:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Destructor - limpa recursos\n   */\n  destroy(): void {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n    }\n    this.cache.clear();\n  }\n}\n\n// ============================================================================\n// INST√ÇNCIA GLOBAL\n// ============================================================================\n\nexport const encryptionCache = new AdvancedEncryptionCache({\n  maxSize: 2000,\n  ttlMs: 3600000, // 1 hora\n  maxMemoryMB: 100,\n  cleanupIntervalMs: 300000, // 5 minutos\n  compressionEnabled: true,\n  persistToDisk: false\n});\n\n// ============================================================================\n// FUN√á√ïES DE CONVENI√äNCIA\n// ============================================================================\n\n/**\n * Gera hash para dados (para usar como chave de cache)\n */\nexport function generateDataHash(data: string): string {\n  // Implementa√ß√£o simples de hash (em produ√ß√£o usar crypto.subtle)\n  let hash = 0;\n  for (let i = 0; i < data.length; i++) {\n    const char = data.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n  return Math.abs(hash).toString(36);\n}\n\n/**\n * Monitora performance do cache\n */\nexport function monitorCachePerformance(): void {\n  setInterval(() => {\n    const stats = encryptionCache.getStats();\n    \n    if (stats.hitRate < 80) {\n      console.warn(`‚ö†Ô∏è Cache hit rate baixo: ${stats.hitRate.toFixed(1)}%`);\n    }\n    \n    if (stats.averageAccessTime > 10) {\n      console.warn(`‚ö†Ô∏è Tempo de acesso alto: ${stats.averageAccessTime.toFixed(2)}ms`);\n    }\n    \n    if (stats.memoryUsage > 80 * 1024 * 1024) { // 80MB\n      console.warn(`‚ö†Ô∏è Uso de mem√≥ria alto: ${(stats.memoryUsage / 1024 / 1024).toFixed(1)}MB`);\n    }\n  }, 60000); // A cada minuto\n}\n\nexport default encryptionCache;\n"