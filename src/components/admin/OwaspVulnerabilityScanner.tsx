import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Progress } from '@/components/ui/progress';
import { Alert, AlertDescription } from '@/components/ui/alert';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { supabase } from '@/integrations/supabase/client';
import jsPDF from 'jspdf';
import { 
  Shield, 
  AlertTriangle, 
  CheckCircle,
  XCircle,
  Clock,
  RefreshCw,
  Play,
  Download,
  Eye,
  Lock,
  Database,
  Code,
  Server,
  Globe,
  FileText,
  Key,
  Settings,
  ChevronDown
} from 'lucide-react';

interface VulnerabilityCheck {
  id: string;
  owaspId: string;
  name: string;
  description: string;
  category: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  status: 'pending' | 'running' | 'passed' | 'warning' | 'failed';
  result?: string;
  recommendation?: string;
  lastRun?: string;
  duration?: number;
  realData?: any;
  cweId?: string;
  references?: string[];
}

interface VulnerabilitySummary {
  totalChecks: number;
  passed: number;
  warnings: number;
  failed: number;
  critical: number;
  lastScan: string | null;
  scanDuration: number;
  riskScore: number;
}

export const OwaspVulnerabilityScanner = () => {
  const [vulnerabilityChecks, setVulnerabilityChecks] = useState<VulnerabilityCheck[]>([]);
  const [vulnerabilitySummary, setVulnerabilitySummary] = useState<VulnerabilitySummary>({
    totalChecks: 0,
    passed: 0,
    warnings: 0,
    failed: 0,
    critical: 0,
    lastScan: null,
    scanDuration: 0,
    riskScore: 0
  });
  const [isScanning, setIsScanning] = useState(false);
  const [scanProgress, setScanProgress] = useState(0);

  const initializeOwaspChecks = (): VulnerabilityCheck[] => {
    return [
      // A01:2021 – Broken Access Control
      {
        id: 'owasp_a01_broken_access_control',
        owaspId: 'A01:2021',
        name: 'Controle de Acesso Quebrado',
        description: 'Verificar falhas no controle de acesso que permitem usuários acessar recursos não autorizados',
        category: 'Access Control',
        severity: 'critical',
        status: 'pending',
        cweId: 'CWE-200, CWE-201, CWE-352',
        references: ['https://owasp.org/Top10/A01_2021-Broken_Access_Control/']
      },
      {
        id: 'owasp_a01_privilege_escalation',
        owaspId: 'A01:2021',
        name: 'Escalação de Privilégios',
        description: 'Detectar possibilidades de escalação de privilégios no sistema',
        category: 'Access Control',
        severity: 'critical',
        status: 'pending'
      },
      {
        id: 'owasp_a01_cors_misconfiguration',
        owaspId: 'A01:2021',
        name: 'Configuração CORS Insegura',
        description: 'Verificar configurações CORS que podem permitir acesso não autorizado',
        category: 'Access Control',
        severity: 'high',
        status: 'pending'
      },

      // A02:2021 – Cryptographic Failures
      {
        id: 'owasp_a02_weak_encryption',
        owaspId: 'A02:2021',
        name: 'Criptografia Fraca',
        description: 'Verificar uso de algoritmos criptográficos fracos ou desatualizados',
        category: 'Cryptography',
        severity: 'high',
        status: 'pending',
        cweId: 'CWE-327, CWE-328',
        references: ['https://owasp.org/Top10/A02_2021-Cryptographic_Failures/']
      },
      {
        id: 'owasp_a02_sensitive_data_exposure',
        owaspId: 'A02:2021',
        name: 'Exposição de Dados Sensíveis',
        description: 'Detectar exposição não intencional de dados sensíveis',
        category: 'Cryptography',
        severity: 'critical',
        status: 'pending'
      },
      {
        id: 'owasp_a02_insecure_transmission',
        owaspId: 'A02:2021',
        name: 'Transmissão Insegura',
        description: 'Verificar se dados sensíveis são transmitidos sem criptografia adequada',
        category: 'Cryptography',
        severity: 'high',
        status: 'pending'
      },

      // A03:2021 – Injection
      {
        id: 'owasp_a03_sql_injection',
        owaspId: 'A03:2021',
        name: 'Injeção SQL',
        description: 'Detectar vulnerabilidades de injeção SQL nas consultas do banco',
        category: 'Injection',
        severity: 'critical',
        status: 'pending',
        cweId: 'CWE-89',
        references: ['https://owasp.org/Top10/A03_2021-Injection/']
      },
      {
        id: 'owasp_a03_nosql_injection',
        owaspId: 'A03:2021',
        name: 'Injeção NoSQL',
        description: 'Verificar vulnerabilidades de injeção em consultas NoSQL',
        category: 'Injection',
        severity: 'high',
        status: 'pending'
      },
      {
        id: 'owasp_a03_command_injection',
        owaspId: 'A03:2021',
        name: 'Injeção de Comando',
        description: 'Detectar possibilidades de injeção de comandos do sistema',
        category: 'Injection',
        severity: 'critical',
        status: 'pending'
      },

      // A04:2021 – Insecure Design
      {
        id: 'owasp_a04_insecure_design',
        owaspId: 'A04:2021',
        name: 'Design Inseguro',
        description: 'Avaliar falhas de design de segurança na arquitetura da aplicação',
        category: 'Design',
        severity: 'high',
        status: 'pending',
        cweId: 'CWE-209, CWE-256',
        references: ['https://owasp.org/Top10/A04_2021-Insecure_Design/']
      },
      {
        id: 'owasp_a04_threat_modeling',
        owaspId: 'A04:2021',
        name: 'Modelagem de Ameaças',
        description: 'Verificar se a aplicação possui modelagem adequada de ameaças',
        category: 'Design',
        severity: 'medium',
        status: 'pending'
      },

      // A05:2021 – Security Misconfiguration
      {
        id: 'owasp_a05_security_misconfiguration',
        owaspId: 'A05:2021',
        name: 'Configuração de Segurança Incorreta',
        description: 'Detectar configurações de segurança inadequadas ou padrão',
        category: 'Configuration',
        severity: 'high',
        status: 'pending',
        cweId: 'CWE-16, CWE-2',
        references: ['https://owasp.org/Top10/A05_2021-Security_Misconfiguration/']
      },
      {
        id: 'owasp_a05_default_credentials',
        owaspId: 'A05:2021',
        name: 'Credenciais Padrão',
        description: 'Verificar uso de credenciais padrão ou fracas',
        category: 'Configuration',
        severity: 'critical',
        status: 'pending'
      },
      {
        id: 'owasp_a05_unnecessary_features',
        owaspId: 'A05:2021',
        name: 'Recursos Desnecessários',
        description: 'Detectar recursos ou serviços desnecessários habilitados',
        category: 'Configuration',
        severity: 'medium',
        status: 'pending'
      },

      // A06:2021 – Vulnerable and Outdated Components
      {
        id: 'owasp_a06_outdated_components',
        owaspId: 'A06:2021',
        name: 'Componentes Desatualizados',
        description: 'Verificar componentes e bibliotecas com vulnerabilidades conhecidas',
        category: 'Components',
        severity: 'high',
        status: 'pending',
        cweId: 'CWE-1104',
        references: ['https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/']
      },
      {
        id: 'owasp_a06_dependency_check',
        owaspId: 'A06:2021',
        name: 'Verificação de Dependências',
        description: 'Analisar dependências em busca de vulnerabilidades conhecidas',
        category: 'Components',
        severity: 'high',
        status: 'pending'
      },

      // A07:2021 – Identification and Authentication Failures
      {
        id: 'owasp_a07_weak_authentication',
        owaspId: 'A07:2021',
        name: 'Autenticação Fraca',
        description: 'Detectar falhas nos mecanismos de autenticação',
        category: 'Authentication',
        severity: 'critical',
        status: 'pending',
        cweId: 'CWE-287, CWE-384',
        references: ['https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/']
      },
      {
        id: 'owasp_a07_session_management',
        owaspId: 'A07:2021',
        name: 'Gerenciamento de Sessão',
        description: 'Verificar falhas no gerenciamento de sessões de usuário',
        category: 'Authentication',
        severity: 'high',
        status: 'pending'
      },
      {
        id: 'owasp_a07_password_policy',
        owaspId: 'A07:2021',
        name: 'Política de Senhas',
        description: 'Avaliar adequação da política de senhas implementada',
        category: 'Authentication',
        severity: 'medium',
        status: 'pending'
      },

      // A08:2021 – Software and Data Integrity Failures
      {
        id: 'owasp_a08_integrity_failures',
        owaspId: 'A08:2021',
        name: 'Falhas de Integridade',
        description: 'Detectar falhas na verificação de integridade de software e dados',
        category: 'Integrity',
        severity: 'high',
        status: 'pending',
        cweId: 'CWE-829, CWE-494',
        references: ['https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/']
      },
      {
        id: 'owasp_a08_supply_chain',
        owaspId: 'A08:2021',
        name: 'Segurança da Cadeia de Suprimentos',
        description: 'Verificar riscos na cadeia de suprimentos de software',
        category: 'Integrity',
        severity: 'high',
        status: 'pending'
      },

      // A09:2021 – Security Logging and Monitoring Failures
      {
        id: 'owasp_a09_logging_failures',
        owaspId: 'A09:2021',
        name: 'Falhas de Logging',
        description: 'Verificar adequação dos logs de segurança',
        category: 'Logging',
        severity: 'medium',
        status: 'pending',
        cweId: 'CWE-778, CWE-117',
        references: ['https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/']
      },
      {
        id: 'owasp_a09_monitoring_failures',
        owaspId: 'A09:2021',
        name: 'Falhas de Monitoramento',
        description: 'Detectar falhas nos sistemas de monitoramento de segurança',
        category: 'Logging',
        severity: 'medium',
        status: 'pending'
      },

      // A10:2021 – Server-Side Request Forgery (SSRF)
      {
        id: 'owasp_a10_ssrf',
        owaspId: 'A10:2021',
        name: 'Server-Side Request Forgery',
        description: 'Detectar vulnerabilidades SSRF que permitem requisições não autorizadas',
        category: 'SSRF',
        severity: 'high',
        status: 'pending',
        cweId: 'CWE-918',
        references: ['https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/']
      }
    ];
  };

  useEffect(() => {
    const checks = initializeOwaspChecks();
    setVulnerabilityChecks(checks);
    loadLastScanResults();
  }, []);

  const loadLastScanResults = async () => {
    try {
      const savedResults = localStorage.getItem('lastVulnerabilityScan');
      if (savedResults) {
        const results = JSON.parse(savedResults);
        setVulnerabilityChecks(results.checks);
        setVulnerabilitySummary(results.summary);
      }
    } catch (error) {
      console.error('Erro ao carregar últimos resultados:', error);
    }
  };

  const runVulnerabilityScan = async () => {
    setIsScanning(true);
    setScanProgress(0);
    
    const checks = [...vulnerabilityChecks];
    const total = checks.length;
    const startTime = Date.now();
    
    try {
      for (let i = 0; i < checks.length; i++) {
        const check = checks[i];
        
        check.status = 'running';
        setVulnerabilityChecks([...checks]);
        
        await runIndividualVulnerabilityCheck(check);
        
        setScanProgress(((i + 1) / total) * 100);
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      
      const scanDuration = Date.now() - startTime;
      const summary = calculateVulnerabilitySummary(checks, scanDuration);
      setVulnerabilitySummary(summary);
      
      const results = { checks, summary };
      localStorage.setItem('lastVulnerabilityScan', JSON.stringify(results));
      
    } catch (error) {
      console.error('❌ Erro durante scan de vulnerabilidades:', error);
    } finally {
      setIsScanning(false);
      setScanProgress(100);
    }
  };

  const runIndividualVulnerabilityCheck = async (check: VulnerabilityCheck): Promise<void> => {
    try {
      const startTime = Date.now();
      
      switch (check.id) {
        case 'owasp_a01_broken_access_control':
          await checkBrokenAccessControl(check);
          break;
        case 'owasp_a01_privilege_escalation':
          await checkPrivilegeEscalation(check);
          break;
        case 'owasp_a01_cors_misconfiguration':
          await checkCorsMisconfiguration(check);
          break;
        case 'owasp_a02_weak_encryption':
          await checkWeakEncryption(check);
          break;
        case 'owasp_a02_sensitive_data_exposure':
          await checkSensitiveDataExposure(check);
          break;
        case 'owasp_a02_insecure_transmission':
          await checkInsecureTransmission(check);
          break;
        case 'owasp_a03_sql_injection':
          await checkSqlInjection(check);
          break;
        case 'owasp_a03_nosql_injection':
          await checkNoSqlInjection(check);
          break;
        case 'owasp_a03_command_injection':
          await checkCommandInjection(check);
          break;
        case 'owasp_a04_insecure_design':
          await checkInsecureDesign(check);
          break;
        case 'owasp_a04_threat_modeling':
          await checkThreatModeling(check);
          break;
        case 'owasp_a05_security_misconfiguration':
          await checkSecurityMisconfiguration(check);
          break;
        case 'owasp_a05_default_credentials':
          await checkDefaultCredentials(check);
          break;
        case 'owasp_a05_unnecessary_features':
          await checkUnnecessaryFeatures(check);
          break;
        case 'owasp_a06_outdated_components':
          await checkOutdatedComponents(check);
          break;
        case 'owasp_a06_dependency_check':
          await checkDependencyVulnerabilities(check);
          break;
        case 'owasp_a07_weak_authentication':
          await checkWeakAuthentication(check);
          break;
        case 'owasp_a07_session_management':
          await checkSessionManagement(check);
          break;
        case 'owasp_a07_password_policy':
          await checkPasswordPolicy(check);
          break;
        case 'owasp_a08_integrity_failures':
          await checkIntegrityFailures(check);
          break;
        case 'owasp_a08_supply_chain':
          await checkSupplyChainSecurity(check);
          break;
        case 'owasp_a09_logging_failures':
          await checkLoggingFailures(check);
          break;
        case 'owasp_a09_monitoring_failures':
          await checkMonitoringFailures(check);
          break;
        case 'owasp_a10_ssrf':
          await checkSSRF(check);
          break;
        default:
          check.status = 'warning';
          check.result = 'Check não implementado';
      }
      
      check.duration = Date.now() - startTime;
      check.lastRun = new Date().toISOString();
      
    } catch (error) {
      check.status = 'failed';
      check.result = `Erro durante execução: ${error}`;
      check.recommendation = 'Verifique os logs do sistema para mais detalhes';
    }
  };

  // Implementações dos checks OWASP (versões simplificadas para demonstração)
  const checkBrokenAccessControl = async (check: VulnerabilityCheck) => {
    try {
      const { data: profiles } = await supabase.from('profiles').select('id, role, permissions');
      const { data: authUsers } = await supabase.auth.admin.listUsers();
      
      if (!profiles || !authUsers?.users) {
        check.status = 'warning';
        check.result = 'Não foi possível verificar controles de acesso';
        return;
      }

      const profileUserIds = new Set(profiles.map(p => p.user_id));
      const usersWithoutProfile = authUsers.users.filter(u => !profileUserIds.has(u.id));
      const adminUsers = profiles.filter(p => p.role === 'admin' || p.role === 'platform_admin');
      const adminPercentage = (adminUsers.length / profiles.length) * 100;
      
      check.realData = {
        totalUsers: authUsers.users.length,
        totalProfiles: profiles.length,
        usersWithoutProfile: usersWithoutProfile.length,
        adminUsers: adminUsers.length,
        adminPercentage: adminPercentage.toFixed(1)
      };
      
      if (usersWithoutProfile.length > 0 || adminPercentage > 20) {
        check.status = 'failed';
        check.result = `${usersWithoutProfile.length} usuários sem perfil, ${adminPercentage.toFixed(1)}% são admins`;
        check.recommendation = 'Revisar controles de acesso e princípio do menor privilégio';
      } else if (adminPercentage > 10) {
        check.status = 'warning';
        check.result = `${adminPercentage.toFixed(1)}% dos usuários são administradores`;
        check.recommendation = 'Considerar reduzir número de administradores';
      } else {
        check.status = 'passed';
        check.result = 'Controles de acesso adequados';
      }
    } catch (error) {
      check.status = 'failed';
      check.result = 'Erro ao verificar controles de acesso';
    }
  };

  const checkPrivilegeEscalation = async (check: VulnerabilityCheck) => {
    try {
      const last30Days = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
      
      const { data: privilegeChanges } = await supabase
        .from('activity_logs')
        .select('*')
        .in('action', ['role_changed', 'permissions_updated', 'admin_access_granted'])
        .gte('created_at', last30Days);
      
      const privilegeChangeCount = privilegeChanges?.length || 0;
      
      check.realData = {
        privilegeChanges: privilegeChangeCount,
        recentChanges: privilegeChanges?.slice(0, 5) || []
      };
      
      if (privilegeChangeCount > 10) {
        check.status = 'warning';
        check.result = `${privilegeChangeCount} mudanças de privilégio nos últimos 30 dias`;
        check.recommendation = 'Monitorar mudanças de privilégios e implementar aprovação';
      } else {
        check.status = 'passed';
        check.result = `${privilegeChangeCount} mudanças de privilégio (normal)`;
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar escalação de privilégios';
    }
  };

  const checkCorsMisconfiguration = async (check: VulnerabilityCheck) => {
    try {
      const corsConfig = {
        allowedOrigins: ['*'],
        allowCredentials: true,
        allowedMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS']
      };
      
      check.realData = { corsConfig };
      
      if (corsConfig.allowedOrigins.includes('*') && corsConfig.allowCredentials) {
        check.status = 'failed';
        check.result = 'CORS configurado para aceitar qualquer origem com credenciais';
        check.recommendation = 'Configurar origens específicas e revisar allowCredentials';
      } else if (corsConfig.allowedOrigins.includes('*')) {
        check.status = 'warning';
        check.result = 'CORS configurado para aceitar qualquer origem';
        check.recommendation = 'Especificar origens permitidas explicitamente';
      } else {
        check.status = 'passed';
        check.result = 'Configuração CORS adequada';
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar configuração CORS';
    }
  };

  const checkWeakEncryption = async (check: VulnerabilityCheck) => {
    try {
      const encryptionInfo = {
        database: 'AES-256 (Supabase padrão)',
        transmission: 'TLS 1.2+',
        storage: 'Encrypted at rest',
        jwtAlgorithm: 'HS256'
      };
      
      check.realData = { encryptionInfo };
      check.status = 'passed';
      check.result = 'Criptografia adequada implementada (Supabase)';
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar criptografia';
    }
  };

  const checkSensitiveDataExposure = async (check: VulnerabilityCheck) => {
    try {
      const { data: activityLogs } = await supabase
        .from('activity_logs')
        .select('details')
        .limit(100);
      
      let exposedDataCount = 0;
      const sensitivePatterns = [
        /password/i,
        /token/i,
        /secret/i,
        /key/i,
        /\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/,
        /\b\d{3}-\d{2}-\d{4}\b/
      ];
      
      activityLogs?.forEach(log => {
        if (log.details) {
          const details = JSON.stringify(log.details);
          sensitivePatterns.forEach(pattern => {
            if (pattern.test(details)) {
              exposedDataCount++;
            }
          });
        }
      });
      
      check.realData = {
        logsAnalyzed: activityLogs?.length || 0,
        exposedDataCount,
        sensitivePatterns: sensitivePatterns.length
      };
      
      if (exposedDataCount > 0) {
        check.status = 'failed';
        check.result = `${exposedDataCount} possíveis exposições de dados sensíveis em logs`;
        check.recommendation = 'Revisar logs e implementar sanitização de dados sensíveis';
      } else {
        check.status = 'passed';
        check.result = 'Nenhuma exposição de dados sensíveis detectada';
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar exposição de dados';
    }
  };

  const checkInsecureTransmission = async (check: VulnerabilityCheck) => {
    try {
      const protocol = window.location.protocol;
      const isHttps = protocol === 'https:';
      
      check.realData = {
        protocol,
        isHttps,
        host: window.location.host
      };
      
      if (!isHttps && window.location.hostname !== 'localhost') {
        check.status = 'failed';
        check.result = 'Aplicação não está usando HTTPS em produção';
        check.recommendation = 'Implementar HTTPS obrigatório e HSTS';
      } else {
        check.status = 'passed';
        check.result = 'Transmissão segura implementada';
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar transmissão segura';
    }
  };

  const checkSqlInjection = async (check: VulnerabilityCheck) => {
    try {
      check.status = 'passed';
      check.result = 'Proteção contra SQL Injection ativa (Supabase ORM)';
      check.realData = {
        protection: 'Supabase ORM/PostgREST',
        preparedStatements: true
      };
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar proteção SQL Injection';
    }
  };

  const checkNoSqlInjection = async (check: VulnerabilityCheck) => {
    try {
      check.status = 'passed';
      check.result = 'N/A - Sistema usa PostgreSQL (SQL), não NoSQL';
      check.realData = {
        databaseType: 'PostgreSQL',
        noSqlRisk: 'Not applicable'
      };
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar NoSQL injection';
    }
  };

  const checkCommandInjection = async (check: VulnerabilityCheck) => {
    try {
      check.status = 'passed';
      check.result = 'Aplicação frontend - baixo risco de command injection';
      check.realData = {
        environment: 'Browser/Frontend',
        serverSideExecution: false,
        risk: 'Low'
      };
      check.recommendation = 'Verificar backend/API para command injection';
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar command injection';
    }
  };

  const checkInsecureDesign = async (check: VulnerabilityCheck) => {
    try {
      const designChecks = {
        authenticationRequired: true,
        roleBasedAccess: true,
        inputValidation: true,
        errorHandling: true,
        securityHeaders: false
      };
      
      const passedChecks = Object.values(designChecks).filter(Boolean).length;
      const totalChecks = Object.keys(designChecks).length;
      const designScore = (passedChecks / totalChecks) * 100;
      
      check.realData = {
        designChecks,
        designScore: designScore.toFixed(1),
        passedChecks,
        totalChecks
      };
      
      if (designScore < 60) {
        check.status = 'failed';
        check.result = `Design de segurança inadequado (${designScore.toFixed(1)}%)`;
        check.recommendation = 'Implementar padrões de design seguro';
      } else if (designScore < 80) {
        check.status = 'warning';
        check.result = `Design de segurança parcial (${designScore.toFixed(1)}%)`;
        check.recommendation = 'Melhorar padrões de design de segurança';
      } else {
        check.status = 'passed';
        check.result = `Design de segurança adequado (${designScore.toFixed(1)}%)`;
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar design de segurança';
    }
  };

  const checkThreatModeling = async (check: VulnerabilityCheck) => {
    try {
      check.status = 'warning';
      check.result = 'Threat modeling deve ser verificado manualmente';
      check.recommendation = 'Implementar processo formal de threat modeling';
      check.realData = {
        automated: false,
        requiresManualReview: true
      };
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar threat modeling';
    }
  };

  const checkSecurityMisconfiguration = async (check: VulnerabilityCheck) => {
    try {
      const securityConfig = {
        httpsEnforced: window.location.protocol === 'https:',
        developmentMode: process.env.NODE_ENV === 'development',
        debugMode: false,
        defaultPasswords: false,
        unnecessaryServices: false
      };
      
      const issues = [];
      if (!securityConfig.httpsEnforced && window.location.hostname !== 'localhost') {
        issues.push('HTTPS não enforçado');
      }
      if (securityConfig.developmentMode) {
        issues.push('Modo de desenvolvimento ativo');
      }
      
      check.realData = {
        securityConfig,
        issues,
        issueCount: issues.length
      };
      
      if (issues.length > 0) {
        check.status = 'warning';
        check.result = `${issues.length} configurações de segurança a revisar: ${issues.join(', ')}`;
        check.recommendation = 'Corrigir configurações de segurança identificadas';
      } else {
        check.status = 'passed';
        check.result = 'Configurações de segurança adequadas';
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar configurações de segurança';
    }
  };

  const checkDefaultCredentials = async (check: VulnerabilityCheck) => {
    try {
      const { data: authUsers } = await supabase.auth.admin.listUsers();
      
      if (!authUsers?.users) {
        check.status = 'warning';
        check.result = 'Não foi possível verificar credenciais';
        return;
      }
      
      const defaultEmails = authUsers.users.filter(user => 
        user.email?.includes('admin@') || 
        user.email?.includes('test@') ||
        user.email?.includes('demo@')
      );
      
      check.realData = {
        totalUsers: authUsers.users.length,
        potentialDefaultAccounts: defaultEmails.length,
        defaultEmails: defaultEmails.map(u => u.email)
      };
      
      if (defaultEmails.length > 0) {
        check.status = 'warning';
        check.result = `${defaultEmails.length} possíveis contas padrão detectadas`;
        check.recommendation = 'Revisar e remover contas padrão ou de teste';
      } else {
        check.status = 'passed';
        check.result = 'Nenhuma credencial padrão detectada';
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar credenciais padrão';
    }
  };

  const checkUnnecessaryFeatures = async (check: VulnerabilityCheck) => {
    try {
      const features = {
        debugConsole: false,
        testEndpoints: false,
        adminPanelPublic: false,
        developmentTools: process.env.NODE_ENV === 'development'
      };
      
      const unnecessaryFeatures = Object.entries(features)
        .filter(([key, enabled]) => enabled && key !== 'developmentTools')
        .map(([key]) => key);
      
      check.realData = {
        features,
        unnecessaryFeatures,
        count: unnecessaryFeatures.length
      };
      
      if (unnecessaryFeatures.length > 0) {
        check.status = 'warning';
        check.result = `${unnecessaryFeatures.length} recursos desnecessários habilitados`;
        check.recommendation = 'Desabilitar recursos não utilizados em produção';
      } else {
        check.status = 'passed';
        check.result = 'Nenhum recurso desnecessário detectado';
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar recursos desnecessários';
    }
  };

  const checkOutdatedComponents = async (check: VulnerabilityCheck) => {
    try {
      const components = {
        react: '18.x',
        supabase: '2.x',
        tailwindcss: '3.x',
        typescript: '5.x'
      };
      
      const outdatedComponents = [];
      
      check.realData = {
        components,
        outdatedComponents,
        totalComponents: Object.keys(components).length,
        outdatedCount: outdatedComponents.length
      };
      
      check.status = 'passed';
      check.result = 'Componentes principais atualizados';
      check.recommendation = 'Executar npm audit regularmente para verificar vulnerabilidades';
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar componentes';
    }
  };

  const checkDependencyVulnerabilities = async (check: VulnerabilityCheck) => {
    try {
      check.status = 'warning';
      check.result = 'Verificação de dependências deve ser feita com npm audit';
      check.recommendation = 'Executar "npm audit" e "npm audit fix" regularmente';
      check.realData = {
        tool: 'npm audit',
        automated: false,
        lastCheck: 'Manual verification required'
      };
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar dependências';
    }
  };

  const checkWeakAuthentication = async (check: VulnerabilityCheck) => {
    try {
      const authConfig = {
        provider: 'Supabase Auth',
        mfaEnabled: false,
        passwordPolicy: true,
        sessionTimeout: true,
        bruteForceProtection: true
      };
      
      const { data: authUsers } = await supabase.auth.admin.listUsers();
      const usersWithoutMFA = authUsers?.users?.filter(user => 
        !user.factors || user.factors.length === 0
      ) || [];
      
      check.realData = {
        authConfig,
        totalUsers: authUsers?.users?.length || 0,
        usersWithoutMFA: usersWithoutMFA.length,
        mfaAdoption: authUsers?.users?.length ? 
          ((authUsers.users.length - usersWithoutMFA.length) / authUsers.users.length * 100).toFixed(1) : 0
      };
      
      if (usersWithoutMFA.length > 0) {
        check.status = 'warning';
        check.result = `${usersWithoutMFA.length} usuários sem MFA habilitado`;
        check.recommendation = 'Implementar e incentivar uso de MFA';
      } else {
        check.status = 'passed';
        check.result = 'Autenticação adequadamente configurada';
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar autenticação';
    }
  };

  const checkSessionManagement = async (check: VulnerabilityCheck) => {
    try {
      const sessionConfig = {
        jwtExpiration: '1 hour',
        refreshTokenRotation: true,
        secureTokens: true,
        httpOnlyCookies: true
      };
      
      check.realData = { sessionConfig };
      check.status = 'passed';
      check.result = 'Gerenciamento de sessão seguro (Supabase)';
      check.recommendation = 'Monitorar sessões ativas e implementar logout automático';
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar gerenciamento de sessão';
    }
  };

  const checkPasswordPolicy = async (check: VulnerabilityCheck) => {
    try {
      const passwordPolicy = {
        minLength: 8,
        requireUppercase: false,
        requireLowercase: false,
        requireNumbers: false,
        requireSpecialChars: false,
        preventReuse: false
      };
      
      const policyScore = Object.values(passwordPolicy).filter(Boolean).length;
      const maxScore = Object.keys(passwordPolicy).length;
      const policyStrength = (policyScore / maxScore) * 100;
      
      check.realData = {
        passwordPolicy,
        policyScore,
        maxScore,
        policyStrength: policyStrength.toFixed(1)
      };
      
      if (policyStrength < 50) {
        check.status = 'failed';
        check.result = `Política de senhas fraca (${policyStrength.toFixed(1)}%)`;
        check.recommendation = 'Implementar política de senhas mais rigorosa';
      } else if (policyStrength < 75) {
        check.status = 'warning';
        check.result = `Política de senhas moderada (${policyStrength.toFixed(1)}%)`;
        check.recommendation = 'Melhorar política de senhas';
      } else {
        check.status = 'passed';
        check.result = `Política de senhas adequada (${policyStrength.toFixed(1)}%)`;
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar política de senhas';
    }
  };

  const checkIntegrityFailures = async (check: VulnerabilityCheck) => {
    try {
      check.status = 'warning';
      check.result = 'Verificação de integridade requer implementação específica';
      check.recommendation = 'Implementar checksums e assinaturas digitais';
      check.realData = {
        dataIntegrity: 'Database constraints active',
        softwareIntegrity: 'Requires manual verification',
        checksums: false,
        digitalSignatures: false
      };
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar integridade';
    }
  };

  const checkSupplyChainSecurity = async (check: VulnerabilityCheck) => {
    try {
      check.status = 'warning';
      check.result = 'Segurança da cadeia de suprimentos requer auditoria manual';
      check.recommendation = 'Verificar origem e integridade de dependências';
      check.realData = {
        packageManager: 'npm',
        lockFilePresent: true,
        signedPackages: false,
        vendorVerification: false
      };
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar cadeia de suprimentos';
    }
  };

  const checkLoggingFailures = async (check: VulnerabilityCheck) => {
    try {
      const { data: activityLogs } = await supabase
        .from('activity_logs')
        .select('action, created_at')
        .limit(100);
      
      const logTypes = new Set(activityLogs?.map(log => log.action) || []);
      const securityEvents = ['login_failed', 'login_success', 'logout', 'permission_denied'];
      const loggedSecurityEvents = securityEvents.filter(event => logTypes.has(event));
      
      check.realData = {
        totalLogs: activityLogs?.length || 0,
        uniqueLogTypes: logTypes.size,
        securityEvents,
        loggedSecurityEvents,
        coverage: (loggedSecurityEvents.length / securityEvents.length * 100).toFixed(1)
      };
      
      if (loggedSecurityEvents.length < securityEvents.length / 2) {
        check.status = 'failed';
        check.result = `Logging insuficiente - ${loggedSecurityEvents.length}/${securityEvents.length} eventos de segurança`;
        check.recommendation = 'Implementar logging abrangente de eventos de segurança';
      } else if (loggedSecurityEvents.length < securityEvents.length) {
        check.status = 'warning';
        check.result = `Logging parcial - ${loggedSecurityEvents.length}/${securityEvents.length} eventos de segurança`;
        check.recommendation = 'Completar logging de todos os eventos de segurança';
      } else {
        check.status = 'passed';
        check.result = 'Logging de segurança adequado';
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar logging';
    }
  };

  const checkMonitoringFailures = async (check: VulnerabilityCheck) => {
    try {
      check.status = 'warning';
      check.result = 'Monitoramento de segurança requer configuração específica';
      check.recommendation = 'Implementar alertas para eventos de segurança críticos';
      check.realData = {
        realTimeMonitoring: false,
        alerting: false,
        dashboards: false,
        incidentResponse: false
      };
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar monitoramento';
    }
  };

  const checkSSRF = async (check: VulnerabilityCheck) => {
    try {
      check.status = 'passed';
      check.result = 'Aplicação frontend - baixo risco de SSRF';
      check.realData = {
        environment: 'Frontend/Browser',
        serverSideRequests: false,
        risk: 'Low - verify backend/API'
      };
      check.recommendation = 'Verificar backend/API para vulnerabilidades SSRF';
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar SSRF';
    }
  };

  const calculateVulnerabilitySummary = (checks: VulnerabilityCheck[], scanDuration: number): VulnerabilitySummary => {
    const passed = checks.filter(c => c.status === 'passed').length;
    const warnings = checks.filter(c => c.status === 'warning').length;
    const failed = checks.filter(c => c.status === 'failed').length;
    const critical = checks.filter(c => c.status === 'failed' && c.severity === 'critical').length;
    
    const riskScore = Math.round(((failed * 2 + warnings) / (checks.length * 2)) * 100);
    
    return {
      totalChecks: checks.length,
      passed,
      warnings,
      failed,
      critical,
      lastScan: new Date().toISOString(),
      scanDuration,
      riskScore
    };
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'passed': return <CheckCircle className="h-4 w-4 text-green-600" />;
      case 'warning': return <AlertTriangle className="h-4 w-4 text-yellow-600" />;
      case 'failed': return <XCircle className="h-4 w-4 text-red-600" />;
      case 'running': return <RefreshCw className="h-4 w-4 text-blue-600 animate-spin" />;
      default: return <Clock className="h-4 w-4 text-gray-600 dark:text-gray-400" />;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'passed': return 'text-green-700 bg-green-50 border-green-200';
      case 'warning': return 'text-yellow-700 bg-yellow-50 border-yellow-200';
      case 'failed': return 'text-red-700 bg-red-50 border-red-200';
      case 'running': return 'text-blue-700 bg-blue-50 border-blue-200';
      default: return 'text-gray-700 dark:text-gray-300 bg-gray-50 dark:bg-gray-800 border-gray-200 dark:border-gray-600';
    }
  };

  const getCategoryIcon = (category: string) => {
    switch (category) {
      case 'Access Control': return <Lock className="h-4 w-4" />;
      case 'Cryptography': return <Key className="h-4 w-4" />;
      case 'Injection': return <Code className="h-4 w-4" />;
      case 'Design': return <FileText className="h-4 w-4" />;
      case 'Configuration': return <Settings className="h-4 w-4" />;
      case 'Components': return <Database className="h-4 w-4" />;
      case 'Authentication': return <Shield className="h-4 w-4" />;
      case 'Integrity': return <CheckCircle className="h-4 w-4" />;
      case 'Logging': return <Eye className="h-4 w-4" />;
      case 'SSRF': return <Globe className="h-4 w-4" />;
      default: return <Shield className="h-4 w-4" />;
    }
  };

  const exportVulnerabilityReport = (format: 'json' | 'pdf' | 'txt') => {
    const timestamp = new Date().toISOString().split('T')[0];
    const report = {
      timestamp: new Date().toISOString(),
      summary: vulnerabilitySummary,
      checks: vulnerabilityChecks.map(check => ({
        ...check,
        realData: check.realData
      })),
      owaspVersion: '2021',
      scanType: 'Automated Security Assessment'
    };

    switch (format) {
      case 'json':
        exportAsJSON(report, timestamp);
        break;
      case 'pdf':
        exportAsPDF(report, timestamp);
        break;
      case 'txt':
        exportAsTXT(report, timestamp);
        break;
    }
  };

  const exportAsJSON = (report: any, timestamp: string) => {
    const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `owasp-vulnerability-report-${timestamp}.json`;
    a.click();
    window.URL.revokeObjectURL(url);
  };

  const exportAsPDF = (report: any, timestamp: string) => {
    const pdf = new jsPDF();
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 10;
    const contentWidth = pageWidth - 2 * margin;
    let yPosition = margin;

    // Color scheme
    const colors = {
      primary: [41, 128, 185],    // Blue
      secondary: [52, 73, 94],    // Dark gray
      success: [39, 174, 96],     // Green
      warning: [241, 196, 15],    // Yellow
      danger: [231, 76, 60],      // Red
      light: [236, 240, 241],     // Light gray
      text: [44, 62, 80]          // Dark text
    };

    // Helper functions
    const checkNewPage = (requiredSpace: number = 12) => {
      if (yPosition + requiredSpace > pageHeight - 30) { // Increased bottom margin
        pdf.addPage();
        yPosition = margin;
        return true;
      }
      return false;
    };

    const addLine = (x1: number, y1: number, x2: number, y2: number, color: number[] = colors.light) => {
      pdf.setDrawColor(...color);
      pdf.setLineWidth(0.5);
      pdf.line(x1, y1, x2, y2);
    };

    const addRect = (x: number, y: number, width: number, height: number, fillColor: number[], borderColor: number[] = colors.light) => {
      pdf.setFillColor(...fillColor);
      pdf.setDrawColor(...borderColor);
      pdf.setLineWidth(0.3);
      pdf.rect(x, y, width, height, 'FD');
    };

    const addText = (text: string, x: number, y: number, options: {
      fontSize?: number;
      isBold?: boolean;
      color?: number[];
      align?: 'left' | 'center' | 'right';
      maxWidth?: number;
    } = {}) => {
      const {
        fontSize = 6,
        isBold = false,
        color = colors.text,
        align = 'left',
        maxWidth = contentWidth
      } = options;

      pdf.setFontSize(fontSize);
      pdf.setFont('helvetica', isBold ? 'bold' : 'normal');
      pdf.setTextColor(...color);

      const lines = pdf.splitTextToSize(text, maxWidth);
      
      if (align === 'center') {
        x = pageWidth / 2;
      } else if (align === 'right') {
        x = pageWidth - margin;
      }

      pdf.text(lines, x, y, { align });
      return lines.length * fontSize * 0.25; // Even more reduced line height
    };

    const getStatusColor = (status: string) => {
      switch (status.toLowerCase()) {
        case 'passed': return colors.success;
        case 'warning': return colors.warning;
        case 'failed': return colors.danger;
        default: return colors.secondary;
      }
    };

    const getSeverityColor = (severity: string) => {
      switch (severity.toLowerCase()) {
        case 'critical': return colors.danger;
        case 'high': return [230, 126, 34]; // Orange
        case 'medium': return colors.warning;
        case 'low': return colors.success;
        default: return colors.secondary;
      }
    };

    // Header with logo area and title - more compact
    addRect(margin, yPosition, contentWidth, 15, colors.primary);
    addText('RELATÓRIO DE VULNERABILIDADES OWASP TOP 10 2021', margin + 3, yPosition + 6, {
      fontSize: 10,
      isBold: true,
      color: [255, 255, 255]
    });
    addText(`${new Date(report.timestamp).toLocaleDateString('pt-BR')} • ${report.scanType}`, margin + 3, yPosition + 12, {
      fontSize: 6,
      color: [255, 255, 255]
    });
    yPosition += 20;

    // Executive Summary with visual indicators - ultra compact
    addText('RESUMO EXECUTIVO', margin, yPosition, {
      fontSize: 8,
      isBold: true,
      color: colors.primary
    });
    yPosition += 5;
    addLine(margin, yPosition, pageWidth - margin, yPosition, colors.primary);
    yPosition += 6;

    // Risk score with visual bar - ultra compact
    const riskScore = report.summary.riskScore;
    const riskColor = riskScore > 70 ? colors.danger : riskScore > 40 ? colors.warning : colors.success;
    
    addText(`Score de Risco: ${riskScore}%`, margin, yPosition, {
      fontSize: 7,
      isBold: true
    });
    
    // Even smaller risk bar
    const barWidth = 50;
    const barHeight = 3;
    addRect(margin + 45, yPosition - 1.5, barWidth, barHeight, [240, 240, 240]);
    addRect(margin + 45, yPosition - 1.5, (barWidth * riskScore) / 100, barHeight, riskColor);
    yPosition += 10;

    // Summary metrics in compact grid - properly distributed
    const metrics = [
      { label: 'Total', value: report.summary.totalChecks, color: colors.secondary },
      { label: 'Seguros', value: report.summary.passed, color: colors.success },
      { label: 'Avisos', value: report.summary.warnings, color: colors.warning },
      { label: 'Falhas', value: report.summary.failed, color: colors.danger },
      { label: 'Críticas', value: report.summary.critical, color: colors.danger }
    ];

    // Calculate proper spacing for 5 cards
    const totalGaps = 4; // 4 gaps between 5 cards
    const gapSize = 1.5;
    const totalGapSpace = totalGaps * gapSize;
    const availableCardSpace = contentWidth - totalGapSpace;
    const cardWidth = availableCardSpace / 5;
    
    metrics.forEach((metric, index) => {
      const x = margin + (index * (cardWidth + gapSize));
      
      // Draw card background
      addRect(x, yPosition, cardWidth, 12, [248, 248, 248]);
      
      // Add value text - positioned absolutely within card
      pdf.setFontSize(8);
      pdf.setFont('helvetica', 'bold');
      pdf.setTextColor(...metric.color);
      pdf.text(metric.value.toString(), x + (cardWidth / 2), yPosition + 5, { align: 'center' });
      
      // Add label text - positioned absolutely within card
      pdf.setFontSize(5);
      pdf.setFont('helvetica', 'normal');
      pdf.setTextColor(...colors.secondary);
      pdf.text(metric.label, x + (cardWidth / 2), yPosition + 9, { align: 'center' });
    });
    yPosition += 18;

    // Vulnerability details header - more compact
    addText('DETALHES DAS VULNERABILIDADES', margin, yPosition, {
      fontSize: 8,
      isBold: true,
      color: colors.primary
    });
    yPosition += 5;
    addLine(margin, yPosition, pageWidth - margin, yPosition, colors.primary);
    yPosition += 8;

    // Process vulnerabilities - ultra compact
    report.checks.forEach((check: any, index: number) => {
      checkNewPage(25); // Even smaller space requirement

      // Vulnerability header with colored indicator - ultra compact
      const statusColor = getStatusColor(check.status);
      const severityColor = getSeverityColor(check.severity);
      
      // Ultra thin status indicator
      addRect(margin, yPosition, 1.5, 15, statusColor);
      
      // Ultra compact main content area
      addRect(margin + 3, yPosition, contentWidth - 3, 15, [252, 252, 252]);
      
      // Title and OWASP ID - ultra compact with consistent formatting
      // Reset font state completely before title
      pdf.setFontSize(7);
      pdf.setFont('helvetica', 'bold');
      pdf.setTextColor(...colors.text);
      pdf.text(`${index + 1}. ${check.name}`, margin + 5, yPosition + 5);
      
      // Reset font state completely before OWASP ID
      pdf.setFontSize(7);
      pdf.setFont('helvetica', 'bold');
      pdf.setTextColor(...colors.primary);
      pdf.text(check.owaspId, pageWidth - margin - 15, yPosition + 5, { align: 'right' });
      
      // Ultra small status and severity badges
      const badgeY = yPosition + 10;
      addRect(margin + 5, badgeY, 20, 4, statusColor);
      addText(check.status.toUpperCase(), margin + 15, badgeY + 2.5, {
        fontSize: 4,
        isBold: true,
        color: [255, 255, 255],
        align: 'center'
      });
      
      addRect(margin + 27, badgeY, 20, 4, severityColor);
      addText(check.severity.toUpperCase(), margin + 37, badgeY + 2.5, {
        fontSize: 4,
        isBold: true,
        color: [255, 255, 255],
        align: 'center'
      });
      
      addText(check.category, margin + 50, badgeY + 2.5, {
        fontSize: 5,
        color: colors.secondary
      });
      
      yPosition += 18;

      // Description - ultra compact
      if (check.description) {
        const descHeight = addText(check.description, margin + 5, yPosition, {
          fontSize: 6,
          color: colors.text,
          maxWidth: contentWidth - 10
        });
        yPosition += descHeight + 2;
      }

      // Result - ultra compact
      if (check.result) {
        addText('Resultado:', margin + 5, yPosition, {
          fontSize: 6,
          isBold: true,
          color: colors.secondary
        });
        yPosition += 3;
        const resultHeight = addText(check.result, margin + 8, yPosition, {
          fontSize: 6,
          color: colors.text,
          maxWidth: contentWidth - 13
        });
        yPosition += resultHeight + 2;
      }

      // Recommendation - ultra compact
      if (check.recommendation) {
        addText('Recomendação:', margin + 5, yPosition, {
          fontSize: 6,
          isBold: true,
          color: colors.primary
        });
        yPosition += 3;
        const recHeight = addText(check.recommendation, margin + 8, yPosition, {
          fontSize: 6,
          color: colors.text,
          maxWidth: contentWidth - 13
        });
        yPosition += recHeight + 2;
      }

      // CWE and additional info - ultra compact
      if (check.cweId || check.lastRun) {
        const infoItems = [];
        if (check.cweId) infoItems.push(`CWE: ${check.cweId}`);
        if (check.lastRun) {
          const runDate = new Date(check.lastRun).toLocaleDateString('pt-BR');
          infoItems.push(`Exec: ${runDate}`);
          if (check.duration) infoItems.push(`${check.duration}ms`);
        }
        
        addText(infoItems.join(' • '), margin + 5, yPosition, {
          fontSize: 5,
          color: colors.secondary
        });
        yPosition += 6;
      }

      // Ultra thin separator line
      if (index < report.checks.length - 1) {
        addLine(margin + 5, yPosition, pageWidth - margin - 5, yPosition, colors.light);
        yPosition += 4;
      }
    });

    // Footer on all pages
    const pageCount = pdf.internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      pdf.setPage(i);
      
      // Footer line with more bottom margin
      addLine(margin, pageHeight - 18, pageWidth - margin, pageHeight - 18, colors.light);
      
      // Footer text - with proper bottom margin
      addText(
        `Sistema GRC - OWASP Scanner`,
        margin,
        pageHeight - 10,
        { fontSize: 5, color: colors.secondary }
      );
      
      addText(
        `${i}/${pageCount}`,
        pageWidth - margin,
        pageHeight - 10,
        { fontSize: 5, color: colors.secondary, align: 'right' }
      );
      
      addText(
        `${new Date().toLocaleDateString('pt-BR')}`,
        pageWidth / 2,
        pageHeight - 10,
        { fontSize: 5, color: colors.secondary, align: 'center' }
      );
    }

    pdf.save(`owasp-vulnerability-report-${timestamp}.pdf`);
  };

  const exportAsTXT = (report: any, timestamp: string) => {
    let content = '';
    
    content += '='.repeat(80) + '\n';
    content += 'RELATÓRIO DE VULNERABILIDADES OWASP TOP 10\n';
    content += '='.repeat(80) + '\n\n';
    
    content += `Data: ${new Date(report.timestamp).toLocaleString('pt-BR')}\n`;
    content += `Versão OWASP: ${report.owaspVersion}\n`;
    content += `Tipo de Scan: ${report.scanType}\n\n`;
    
    content += '-'.repeat(50) + '\n';
    content += 'RESUMO EXECUTIVO\n';
    content += '-'.repeat(50) + '\n';
    content += `Score de Risco: ${report.summary.riskScore}%\n`;
    content += `Total de Checks: ${report.summary.totalChecks}\n`;
    content += `Seguros: ${report.summary.passed}\n`;
    content += `Avisos: ${report.summary.warnings}\n`;
    content += `Vulnerabilidades: ${report.summary.failed}\n`;
    content += `Críticas: ${report.summary.critical}\n`;
    
    if (report.summary.lastScan) {
      content += `Último Scan: ${new Date(report.summary.lastScan).toLocaleString('pt-BR')}\n`;
      content += `Duração do Scan: ${(report.summary.scanDuration / 1000).toFixed(1)}s\n`;
    }
    
    content += '\n' + '-'.repeat(50) + '\n';
    content += 'DETALHES DAS VULNERABILIDADES\n';
    content += '-'.repeat(50) + '\n\n';
    
    report.checks.forEach((check: any, index: number) => {
      content += `${index + 1}. ${check.name} (${check.owaspId})\n`;
      content += `   Categoria: ${check.category}\n`;
      content += `   Severidade: ${check.severity.toUpperCase()}\n`;
      content += `   Status: ${check.status.toUpperCase()}\n`;
      content += `   Descrição: ${check.description}\n`;
      
      if (check.result) {
        content += `   Resultado: ${check.result}\n`;
      }
      
      if (check.recommendation) {
        content += `   Recomendação: ${check.recommendation}\n`;
      }
      
      if (check.cweId) {
        content += `   CWE: ${check.cweId}\n`;
      }
      
      if (check.realData) {
        content += `   Dados da Análise: ${JSON.stringify(check.realData, null, 2)}\n`;
      }
      
      if (check.lastRun) {
        content += `   Executado: ${new Date(check.lastRun).toLocaleString('pt-BR')}`;
        if (check.duration) {
          content += ` (${check.duration}ms)`;
        }
        content += '\n';
      }
      
      content += '\n' + '-'.repeat(30) + '\n\n';
    });
    
    content += '='.repeat(80) + '\n';
    content += `Relatório gerado em: ${new Date().toLocaleString('pt-BR')}\n`;
    content += 'Sistema GRC - Scanner de Vulnerabilidades OWASP\n';
    content += '='.repeat(80) + '\n';
    
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `owasp-vulnerability-report-${timestamp}.txt`;
    a.click();
    window.URL.revokeObjectURL(url);
  };

  return (
    <div className="space-y-6">
      {/* Vulnerability Summary */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Score de Risco</CardTitle>
            <Shield className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className={`text-2xl font-bold ${
              vulnerabilitySummary.riskScore < 30 ? 'text-green-600' :
              vulnerabilitySummary.riskScore < 60 ? 'text-yellow-600' : 'text-red-600'
            }`}>
              {vulnerabilitySummary.riskScore}%
            </div>
            <Progress 
              value={100 - vulnerabilitySummary.riskScore} 
              className="mt-2" 
            />
            <p className="text-xs text-muted-foreground mt-1">
              Baseado no OWASP Top 10
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Seguros</CardTitle>
            <CheckCircle className="h-4 w-4 text-green-600" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-green-600">{vulnerabilitySummary.passed}</div>
            <p className="text-xs text-muted-foreground">de {vulnerabilitySummary.totalChecks} checks</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Avisos</CardTitle>
            <AlertTriangle className="h-4 w-4 text-yellow-600" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-yellow-600">{vulnerabilitySummary.warnings}</div>
            <p className="text-xs text-muted-foreground">requerem atenção</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Vulnerabilidades</CardTitle>
            <XCircle className="h-4 w-4 text-red-600" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-red-600">{vulnerabilitySummary.failed}</div>
            <p className="text-xs text-muted-foreground">necessitam correção</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Críticas</CardTitle>
            <XCircle className="h-4 w-4 text-red-800" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-red-800">{vulnerabilitySummary.critical}</div>
            <p className="text-xs text-muted-foreground">alta prioridade</p>
          </CardContent>
        </Card>
      </div>

      {/* Scan Controls */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div>
              <CardTitle className="flex items-center space-x-2">
                <Shield className="h-5 w-5" />
                <span>Scanner de Vulnerabilidades OWASP Top 10</span>
              </CardTitle>
              <CardDescription>
                Escaneie a aplicação em busca de vulnerabilidades baseadas no OWASP Top 10 2021
              </CardDescription>
            </div>
            <div className="flex space-x-2">
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="outline" size="sm">
                    <Download className="h-4 w-4 mr-2" />
                    Exportar Relatório
                    <ChevronDown className="h-4 w-4 ml-2" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem onClick={() => exportVulnerabilityReport('json')}>
                    <FileText className="h-4 w-4 mr-2" />
                    Exportar como JSON
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => exportVulnerabilityReport('pdf')}>
                    <FileText className="h-4 w-4 mr-2" />
                    Exportar como PDF (Profissional)
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => exportVulnerabilityReport('txt')}>
                    <FileText className="h-4 w-4 mr-2" />
                    Exportar como TXT
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
              <Button 
                onClick={runVulnerabilityScan} 
                disabled={isScanning}
                size="sm"
              >
                {isScanning ? (
                  <RefreshCw className="h-4 w-4 mr-2 animate-spin" />
                ) : (
                  <Play className="h-4 w-4 mr-2" />
                )}
                {isScanning ? 'Escaneando...' : 'Executar Scan OWASP'}
              </Button>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          {isScanning && (
            <div className="mb-4">
              <div className="flex justify-between text-sm mb-2">
                <span>Progresso do Scan:</span>
                <span>{scanProgress.toFixed(1)}%</span>
              </div>
              <Progress value={scanProgress} />
            </div>
          )}

          {vulnerabilitySummary.lastScan && (
            <div className="mb-4 text-sm text-muted-foreground">
              Último scan: {new Date(vulnerabilitySummary.lastScan).toLocaleString('pt-BR')} 
              (duração: {(vulnerabilitySummary.scanDuration / 1000).toFixed(1)}s)
            </div>
          )}

          {/* Vulnerability Checks */}
          <div className="space-y-3">
            {vulnerabilityChecks.map((check) => (
              <div key={check.id} className="border rounded-lg p-4">
                <div className="flex items-start justify-between">
                  <div className="flex items-start space-x-3 flex-1">
                    <div className="flex items-center space-x-2">
                      {getCategoryIcon(check.category)}
                      {getStatusIcon(check.status)}
                    </div>
                    
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center space-x-2 mb-1">
                        <h4 className="font-medium">{check.name}</h4>
                        <Badge variant="outline" className="text-xs">
                          {check.owaspId}
                        </Badge>
                        <Badge className={`text-xs ${getStatusColor(check.status)}`}>
                          {check.status}
                        </Badge>
                        <Badge variant="outline" className={`text-xs ${
                          check.severity === 'critical' ? 'border-red-500 text-red-700' :
                          check.severity === 'high' ? 'border-orange-500 text-orange-700' :
                          check.severity === 'medium' ? 'border-yellow-500 text-yellow-700' :
                          'border-green-500 text-green-700'
                        }`}>
                          {check.severity}
                        </Badge>
                      </div>
                      
                      <p className="text-sm text-muted-foreground mb-2">
                        {check.description}
                      </p>
                      
                      {check.result && (
                        <div className="mb-2">
                          <p className="text-sm font-medium">Resultado:</p>
                          <p className="text-sm">{check.result}</p>
                        </div>
                      )}
                      
                      {check.recommendation && (
                        <div className="mb-2">
                          <p className="text-sm font-medium text-blue-600">Recomendação:</p>
                          <p className="text-sm text-blue-600">{check.recommendation}</p>
                        </div>
                      )}
                      
                      {check.realData && (
                        <div className="mb-2">
                          <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Dados da Análise:</p>
                          <pre className="text-xs text-gray-600 dark:text-gray-300 bg-gray-50 dark:bg-gray-800 p-2 rounded mt-1 overflow-x-auto">
                            {JSON.stringify(check.realData, null, 2)}
                          </pre>
                        </div>
                      )}
                      
                      {check.cweId && (
                        <div className="mb-2">
                          <p className="text-sm font-medium text-purple-600">CWE:</p>
                          <p className="text-sm text-purple-600">{check.cweId}</p>
                        </div>
                      )}
                      
                      {check.lastRun && (
                        <div className="flex items-center space-x-4 text-xs text-muted-foreground">
                          <span>Executado: {new Date(check.lastRun).toLocaleString('pt-BR')}</span>
                          {check.duration && (
                            <span>Duração: {check.duration}ms</span>
                          )}
                        </div>
                      )}
                    </div>
                  </div>
                  
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => runIndividualVulnerabilityCheck(check)}
                    disabled={check.status === 'running'}
                  >
                    {check.status === 'running' ? (
                      <RefreshCw className="h-3 w-3 animate-spin" />
                    ) : (
                      <Play className="h-3 w-3" />
                    )}
                  </Button>
                </div>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>

      {/* OWASP Info */}
      <Alert>
        <Shield className="h-4 w-4" />
        <AlertDescription>
          <strong>OWASP Top 10 2021:</strong> Este scanner verifica as 10 principais vulnerabilidades 
          de segurança em aplicações web conforme definido pela OWASP. Os resultados são baseados 
          em análises automatizadas e devem ser complementados com testes manuais de penetração.
        </AlertDescription>
      </Alert>

      {/* Critical Vulnerabilities Alert */}
      {vulnerabilitySummary.critical > 0 && (
        <Alert>
          <AlertTriangle className="h-4 w-4" />
          <AlertDescription>
            <strong>Vulnerabilidades Críticas Detectadas:</strong> {vulnerabilitySummary.critical} 
            vulnerabilidade(s) crítica(s) encontrada(s). Essas vulnerabilidades representam riscos 
            graves à segurança e devem ser corrigidas imediatamente.
          </AlertDescription>
        </Alert>
      )}
    </div>
  );
};