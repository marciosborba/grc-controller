import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Progress } from '@/components/ui/progress';
import { Alert, AlertDescription } from '@/components/ui/alert';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { supabase } from '@/integrations/supabase/client';
import jsPDF from 'jspdf';
import { 
  Shield, 
  AlertTriangle, 
  CheckCircle,
  XCircle,
  Clock,
  RefreshCw,
  Play,
  Download,
  Eye,
  Lock,
  Database,
  Code,
  Server,
  Globe,
  FileText,
  Key,
  Settings,
  ChevronDown
} from 'lucide-react';

interface VulnerabilityCheck {
  id: string;
  owaspId: string;
  name: string;
  description: string;
  category: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  status: 'pending' | 'running' | 'passed' | 'warning' | 'failed';
  result?: string;
  recommendation?: string;
  lastRun?: string;
  duration?: number;
  realData?: any;
  cweId?: string;
  references?: string[];
}

interface VulnerabilitySummary {
  totalChecks: number;
  passed: number;
  warnings: number;
  failed: number;
  critical: number;
  lastScan: string | null;
  scanDuration: number;
  riskScore: number;
}

export const OwaspVulnerabilityScanner = () => {
  const [vulnerabilityChecks, setVulnerabilityChecks] = useState<VulnerabilityCheck[]>([]);
  const [vulnerabilitySummary, setVulnerabilitySummary] = useState<VulnerabilitySummary>({
    totalChecks: 0,
    passed: 0,
    warnings: 0,
    failed: 0,
    critical: 0,
    lastScan: null,
    scanDuration: 0,
    riskScore: 0
  });
  const [isScanning, setIsScanning] = useState(false);
  const [scanProgress, setScanProgress] = useState(0);

  const initializeOwaspChecks = (): VulnerabilityCheck[] => {
    return [
      // A01:2021 – Broken Access Control
      {
        id: 'owasp_a01_broken_access_control',
        owaspId: 'A01:2021',
        name: 'Controle de Acesso Quebrado',
        description: 'Verificar falhas no controle de acesso que permitem usuários acessar recursos não autorizados',
        category: 'Access Control',
        severity: 'critical',
        status: 'pending',
        cweId: 'CWE-200, CWE-201, CWE-352',
        references: ['https://owasp.org/Top10/A01_2021-Broken_Access_Control/']
      },
      {
        id: 'owasp_a01_privilege_escalation',
        owaspId: 'A01:2021',
        name: 'Escalação de Privilégios',
        description: 'Detectar possibilidades de escalação de privilégios no sistema',
        category: 'Access Control',
        severity: 'critical',
        status: 'pending'
      },
      {
        id: 'owasp_a01_cors_misconfiguration',
        owaspId: 'A01:2021',
        name: 'Configuração CORS Insegura',
        description: 'Verificar configurações CORS que podem permitir acesso não autorizado',
        category: 'Access Control',
        severity: 'high',
        status: 'pending'
      },

      // A02:2021 – Cryptographic Failures
      {
        id: 'owasp_a02_weak_encryption',
        owaspId: 'A02:2021',
        name: 'Criptografia Fraca',
        description: 'Verificar uso de algoritmos criptográficos fracos ou desatualizados',
        category: 'Cryptography',
        severity: 'high',
        status: 'pending',
        cweId: 'CWE-327, CWE-328',
        references: ['https://owasp.org/Top10/A02_2021-Cryptographic_Failures/']
      },
      {
        id: 'owasp_a02_sensitive_data_exposure',
        owaspId: 'A02:2021',
        name: 'Exposição de Dados Sensíveis',
        description: 'Detectar exposição não intencional de dados sensíveis',
        category: 'Cryptography',
        severity: 'critical',
        status: 'pending'
      },
      {
        id: 'owasp_a02_insecure_transmission',
        owaspId: 'A02:2021',
        name: 'Transmissão Insegura',
        description: 'Verificar se dados sensíveis são transmitidos sem criptografia adequada',
        category: 'Cryptography',
        severity: 'high',
        status: 'pending'
      },

      // A03:2021 – Injection
      {
        id: 'owasp_a03_sql_injection',
        owaspId: 'A03:2021',
        name: 'Injeção SQL',
        description: 'Detectar vulnerabilidades de injeção SQL nas consultas do banco',
        category: 'Injection',
        severity: 'critical',
        status: 'pending',
        cweId: 'CWE-89',
        references: ['https://owasp.org/Top10/A03_2021-Injection/']
      },
      {
        id: 'owasp_a03_nosql_injection',
        owaspId: 'A03:2021',
        name: 'Injeção NoSQL',
        description: 'Verificar vulnerabilidades de injeção em consultas NoSQL',
        category: 'Injection',
        severity: 'high',
        status: 'pending'
      },
      {
        id: 'owasp_a03_command_injection',
        owaspId: 'A03:2021',
        name: 'Injeção de Comando',
        description: 'Detectar possibilidades de injeção de comandos do sistema',
        category: 'Injection',
        severity: 'critical',
        status: 'pending'
      },

      // A04:2021 – Insecure Design
      {
        id: 'owasp_a04_insecure_design',
        owaspId: 'A04:2021',
        name: 'Design Inseguro',
        description: 'Avaliar falhas de design de segurança na arquitetura da aplicação',
        category: 'Design',
        severity: 'high',
        status: 'pending',
        cweId: 'CWE-209, CWE-256',
        references: ['https://owasp.org/Top10/A04_2021-Insecure_Design/']
      },
      {
        id: 'owasp_a04_threat_modeling',
        owaspId: 'A04:2021',
        name: 'Modelagem de Ameaças',
        description: 'Verificar se a aplicação possui modelagem adequada de ameaças',
        category: 'Design',
        severity: 'medium',
        status: 'pending'
      },

      // A05:2021 – Security Misconfiguration
      {
        id: 'owasp_a05_security_misconfiguration',
        owaspId: 'A05:2021',
        name: 'Configuração de Segurança Incorreta',
        description: 'Detectar configurações de segurança inadequadas ou padrão',
        category: 'Configuration',
        severity: 'high',
        status: 'pending',
        cweId: 'CWE-16, CWE-2',
        references: ['https://owasp.org/Top10/A05_2021-Security_Misconfiguration/']
      },
      {
        id: 'owasp_a05_default_credentials',
        owaspId: 'A05:2021',
        name: 'Credenciais Padrão',
        description: 'Verificar uso de credenciais padrão ou fracas',
        category: 'Configuration',
        severity: 'critical',
        status: 'pending'
      },
      {
        id: 'owasp_a05_unnecessary_features',
        owaspId: 'A05:2021',
        name: 'Recursos Desnecessários',
        description: 'Detectar recursos ou serviços desnecessários habilitados',
        category: 'Configuration',
        severity: 'medium',
        status: 'pending'
      },

      // A06:2021 – Vulnerable and Outdated Components
      {
        id: 'owasp_a06_outdated_components',
        owaspId: 'A06:2021',
        name: 'Componentes Desatualizados',
        description: 'Verificar componentes e bibliotecas com vulnerabilidades conhecidas',
        category: 'Components',
        severity: 'high',
        status: 'pending',
        cweId: 'CWE-1104',
        references: ['https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/']
      },
      {
        id: 'owasp_a06_dependency_check',
        owaspId: 'A06:2021',
        name: 'Verificação de Dependências',
        description: 'Analisar dependências em busca de vulnerabilidades conhecidas',
        category: 'Components',
        severity: 'high',
        status: 'pending'
      },

      // A07:2021 – Identification and Authentication Failures
      {
        id: 'owasp_a07_weak_authentication',
        owaspId: 'A07:2021',
        name: 'Autenticação Fraca',
        description: 'Detectar falhas nos mecanismos de autenticação',
        category: 'Authentication',
        severity: 'critical',
        status: 'pending',
        cweId: 'CWE-287, CWE-384',
        references: ['https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/']
      },
      {
        id: 'owasp_a07_session_management',
        owaspId: 'A07:2021',
        name: 'Gerenciamento de Sessão',
        description: 'Verificar falhas no gerenciamento de sessões de usuário',
        category: 'Authentication',
        severity: 'high',
        status: 'pending'
      },
      {
        id: 'owasp_a07_password_policy',
        owaspId: 'A07:2021',
        name: 'Política de Senhas',
        description: 'Avaliar adequação da política de senhas implementada',
        category: 'Authentication',
        severity: 'medium',
        status: 'pending'
      },

      // A08:2021 – Software and Data Integrity Failures
      {
        id: 'owasp_a08_integrity_failures',
        owaspId: 'A08:2021',
        name: 'Falhas de Integridade',
        description: 'Detectar falhas na verificação de integridade de software e dados',
        category: 'Integrity',
        severity: 'high',
        status: 'pending',
        cweId: 'CWE-829, CWE-494',
        references: ['https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/']
      },
      {
        id: 'owasp_a08_supply_chain',
        owaspId: 'A08:2021',
        name: 'Segurança da Cadeia de Suprimentos',
        description: 'Verificar riscos na cadeia de suprimentos de software',
        category: 'Integrity',
        severity: 'high',
        status: 'pending'
      },

      // A09:2021 – Security Logging and Monitoring Failures
      {
        id: 'owasp_a09_logging_failures',
        owaspId: 'A09:2021',
        name: 'Falhas de Logging',
        description: 'Verificar adequação dos logs de segurança',
        category: 'Logging',
        severity: 'medium',
        status: 'pending',
        cweId: 'CWE-778, CWE-117',
        references: ['https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/']
      },
      {
        id: 'owasp_a09_monitoring_failures',
        owaspId: 'A09:2021',
        name: 'Falhas de Monitoramento',
        description: 'Detectar falhas nos sistemas de monitoramento de segurança',
        category: 'Logging',
        severity: 'medium',
        status: 'pending'
      },

      // A10:2021 – Server-Side Request Forgery (SSRF)
      {
        id: 'owasp_a10_ssrf',
        owaspId: 'A10:2021',
        name: 'Server-Side Request Forgery',
        description: 'Detectar vulnerabilidades SSRF que permitem requisições não autorizadas',
        category: 'SSRF',
        severity: 'high',
        status: 'pending',
        cweId: 'CWE-918',
        references: ['https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/']
      }
    ];
  };

  useEffect(() => {
    const checks = initializeOwaspChecks();
    setVulnerabilityChecks(checks);
    loadLastScanResults();
  }, []);

  const loadLastScanResults = async () => {
    try {
      const savedResults = localStorage.getItem('lastVulnerabilityScan');
      if (savedResults) {
        const results = JSON.parse(savedResults);
        setVulnerabilityChecks(results.checks);
        setVulnerabilitySummary(results.summary);
      }
    } catch (error) {
      console.error('Erro ao carregar últimos resultados:', error);
    }
  };

  const runVulnerabilityScan = async () => {
    setIsScanning(true);
    setScanProgress(0);
    
    const checks = [...vulnerabilityChecks];
    const total = checks.length;
    const startTime = Date.now();
    
    try {
      for (let i = 0; i < checks.length; i++) {
        const check = checks[i];
        
        check.status = 'running';
        setVulnerabilityChecks([...checks]);
        
        await runIndividualVulnerabilityCheck(check);
        
        setScanProgress(((i + 1) / total) * 100);
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      
      const scanDuration = Date.now() - startTime;
      const summary = calculateVulnerabilitySummary(checks, scanDuration);
      setVulnerabilitySummary(summary);
      
      const results = { checks, summary };
      localStorage.setItem('lastVulnerabilityScan', JSON.stringify(results));
      
    } catch (error) {
      console.error('❌ Erro durante scan de vulnerabilidades:', error);
    } finally {
      setIsScanning(false);
      setScanProgress(100);
    }
  };

  const runIndividualVulnerabilityCheck = async (check: VulnerabilityCheck): Promise<void> => {
    try {
      const startTime = Date.now();
      
      switch (check.id) {
        case 'owasp_a01_broken_access_control':
          await checkBrokenAccessControl(check);
          break;
        case 'owasp_a01_privilege_escalation':
          await checkPrivilegeEscalation(check);
          break;
        case 'owasp_a01_cors_misconfiguration':
          await checkCorsMisconfiguration(check);
          break;
        case 'owasp_a02_weak_encryption':
          await checkWeakEncryption(check);
          break;
        case 'owasp_a02_sensitive_data_exposure':
          await checkSensitiveDataExposure(check);
          break;
        case 'owasp_a02_insecure_transmission':
          await checkInsecureTransmission(check);
          break;
        case 'owasp_a03_sql_injection':
          await checkSqlInjection(check);
          break;
        case 'owasp_a03_nosql_injection':
          await checkNoSqlInjection(check);
          break;
        case 'owasp_a03_command_injection':
          await checkCommandInjection(check);
          break;
        case 'owasp_a04_insecure_design':
          await checkInsecureDesign(check);
          break;
        case 'owasp_a04_threat_modeling':
          await checkThreatModeling(check);
          break;
        case 'owasp_a05_security_misconfiguration':
          await checkSecurityMisconfiguration(check);
          break;
        case 'owasp_a05_default_credentials':
          await checkDefaultCredentials(check);
          break;
        case 'owasp_a05_unnecessary_features':
          await checkUnnecessaryFeatures(check);
          break;
        case 'owasp_a06_outdated_components':
          await checkOutdatedComponents(check);
          break;
        case 'owasp_a06_dependency_check':
          await checkDependencyVulnerabilities(check);
          break;
        case 'owasp_a07_weak_authentication':
          await checkWeakAuthentication(check);
          break;
        case 'owasp_a07_session_management':
          await checkSessionManagement(check);
          break;
        case 'owasp_a07_password_policy':
          await checkPasswordPolicy(check);
          break;
        case 'owasp_a08_integrity_failures':
          await checkIntegrityFailures(check);
          break;
        case 'owasp_a08_supply_chain':
          await checkSupplyChainSecurity(check);
          break;
        case 'owasp_a09_logging_failures':
          await checkLoggingFailures(check);
          break;
        case 'owasp_a09_monitoring_failures':
          await checkMonitoringFailures(check);
          break;
        case 'owasp_a10_ssrf':
          await checkSSRF(check);
          break;
        default:
          check.status = 'warning';
          check.result = 'Check não implementado';
      }
      
      check.duration = Date.now() - startTime;
      check.lastRun = new Date().toISOString();
      
    } catch (error) {
      check.status = 'failed';
      check.result = `Erro durante execução: ${error}`;
      check.recommendation = 'Verifique os logs do sistema para mais detalhes';
    }
  };

  // Implementações dos checks OWASP (versões simplificadas para demonstração)
  const checkBrokenAccessControl = async (check: VulnerabilityCheck) => {
    try {
      // Verificar dados reais de usuários e perfis
      const { data: profiles } = await supabase.from('profiles').select('user_id, role, tenant_id, is_active');
      const { data: authUsers } = await supabase.auth.admin.listUsers();
      const { data: userRoles } = await supabase.from('user_roles').select('user_id, role');
      
      if (!profiles || !authUsers?.users) {
        check.status = 'warning';
        check.result = 'Não foi possível verificar controles de acesso';
        return;
      }

      const profileUserIds = new Set(profiles.map(p => p.user_id));
      const usersWithoutProfile = authUsers.users.filter(u => !profileUserIds.has(u.id));
      
      // Analisar distribuição de roles baseada em dados reais
      const roleDistribution = {};
      userRoles?.forEach(ur => {
        roleDistribution[ur.role] = (roleDistribution[ur.role] || 0) + 1;
      });
      
      const privilegedRoles = ['admin', 'platform_admin', 'ciso', 'admin_user'];
      const privilegedUsers = userRoles?.filter(ur => privilegedRoles.includes(ur.role)) || [];
      const privilegedPercentage = profiles.length > 0 ? (privilegedUsers.length / profiles.length) * 100 : 0;
      
      // Verificar usuários sem tenant (possível falha de isolamento)
      const usersWithoutTenant = profiles.filter(p => !p.tenant_id).length;
      
      check.realData = {
        totalAuthUsers: authUsers.users.length,
        totalProfiles: profiles.length,
        usersWithoutProfile: usersWithoutProfile.length,
        privilegedUsers: privilegedUsers.length,
        privilegedPercentage: privilegedPercentage.toFixed(1),
        usersWithoutTenant,
        roleDistribution,
        inactiveProfiles: profiles.filter(p => !p.is_active).length
      };
      
      const issues = [];
      if (usersWithoutProfile.length > 0) issues.push(`${usersWithoutProfile.length} usuários sem perfil`);
      if (privilegedPercentage > 15) issues.push(`${privilegedPercentage.toFixed(1)}% usuários privilegiados`);
      if (usersWithoutTenant > 0) issues.push(`${usersWithoutTenant} usuários sem tenant`);
      
      if (issues.length >= 2) {
        check.status = 'failed';
        check.result = `Falhas críticas: ${issues.join(', ')}`;
        check.recommendation = 'Implementar controle de acesso baseado em roles mais rigoroso';
      } else if (issues.length > 0) {
        check.status = 'warning';
        check.result = `Atenção necessária: ${issues.join(', ')}`;
        check.recommendation = 'Revisar e corrigir problemas de controle de acesso';
      } else {
        check.status = 'passed';
        check.result = 'Controles de acesso adequados';
      }
    } catch (error) {
      check.status = 'failed';
      check.result = 'Erro ao verificar controles de acesso';
    }
  };

  const checkPrivilegeEscalation = async (check: VulnerabilityCheck) => {
    try {
      const last30Days = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
      
      const { data: privilegeChanges } = await supabase
        .from('activity_logs')
        .select('*')
        .in('action', ['role_changed', 'permissions_updated', 'admin_access_granted'])
        .gte('created_at', last30Days);
      
      const privilegeChangeCount = privilegeChanges?.length || 0;
      
      check.realData = {
        privilegeChanges: privilegeChangeCount,
        recentChanges: privilegeChanges?.slice(0, 5) || []
      };
      
      if (privilegeChangeCount > 10) {
        check.status = 'warning';
        check.result = `${privilegeChangeCount} mudanças de privilégio nos últimos 30 dias`;
        check.recommendation = 'Monitorar mudanças de privilégios e implementar aprovação';
      } else {
        check.status = 'passed';
        check.result = `${privilegeChangeCount} mudanças de privilégio (normal)`;
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar escalação de privilégios';
    }
  };

  const checkCorsMisconfiguration = async (check: VulnerabilityCheck) => {
    try {
      // Verificar configuração CORS baseada no ambiente atual
      const currentOrigin = window.location.origin;
      const isProduction = !currentOrigin.includes('localhost') && !currentOrigin.includes('127.0.0.1');
      const isDevelopment = process.env.NODE_ENV === 'development';
      
      // Analisar headers de resposta para determinar configuração CORS
      let corsAnalysis;
      try {
        const response = await fetch('/api/test', { method: 'OPTIONS' });
        const corsHeaders = {
          'access-control-allow-origin': response.headers.get('access-control-allow-origin'),
          'access-control-allow-credentials': response.headers.get('access-control-allow-credentials'),
          'access-control-allow-methods': response.headers.get('access-control-allow-methods')
        };
        corsAnalysis = { available: true, headers: corsHeaders };
      } catch {
        // Se não conseguir fazer o teste, usar configuração Supabase padrão
        corsAnalysis = {
          available: false,
          assumedConfig: 'Supabase gerenciado',
          note: 'CORS é gerenciado pelo Supabase'
        };
      }
      
      const riskFactors = [];
      if (isProduction && corsAnalysis.headers?.['access-control-allow-origin'] === '*') {
        riskFactors.push('Wildcard origins em produção');
      }
      if (corsAnalysis.headers?.['access-control-allow-credentials'] === 'true' && 
          corsAnalysis.headers?.['access-control-allow-origin'] === '*') {
        riskFactors.push('Wildcard + credentials habilitado');
      }
      if (isDevelopment && corsAnalysis.headers?.['access-control-allow-origin'] === '*') {
        riskFactors.push('Configuração permissiva em desenvolvimento (OK)');
      }
      
      check.realData = {
        currentOrigin,
        isProduction,
        isDevelopment,
        corsAnalysis,
        riskFactors
      };
      
      if (riskFactors.some(rf => rf.includes('Wildcard + credentials'))) {
        check.status = 'failed';
        check.result = `Configuração CORS insegura: ${riskFactors.filter(rf => !rf.includes('OK')).join(', ')}`;
        check.recommendation = 'Configurar origens específicas e revisar allowCredentials';
      } else if (riskFactors.some(rf => rf.includes('produção') && !rf.includes('OK'))) {
        check.status = 'warning';
        check.result = `CORS em produção pode ser restritivo: ${riskFactors.filter(rf => !rf.includes('OK')).join(', ')}`;
        check.recommendation = 'Revisar configurações CORS para produção';
      } else {
        check.status = 'passed';
        check.result = corsAnalysis.available ? 'Configuração CORS analisada - aparenta estar segura' : 'CORS gerenciado pelo Supabase (configuração padrão segura)';
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar configuração CORS';
    }
  };

  const checkWeakEncryption = async (check: VulnerabilityCheck) => {
    try {
      const encryptionInfo = {
        database: 'AES-256 (Supabase padrão)',
        transmission: 'TLS 1.2+',
        storage: 'Encrypted at rest',
        jwtAlgorithm: 'HS256'
      };
      
      check.realData = { encryptionInfo };
      check.status = 'passed';
      check.result = 'Criptografia adequada implementada (Supabase)';
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar criptografia';
    }
  };

  const checkSensitiveDataExposure = async (check: VulnerabilityCheck) => {
    try {
      // Analisar múltiplas fontes de dados para exposição
      const [activityLogs, profiles, assessments] = await Promise.all([
        supabase.from('activity_logs').select('details, action, created_at').limit(200),
        supabase.from('profiles').select('email, full_name, phone').limit(50),
        supabase.from('assessments').select('title, description').limit(30)
      ]);
      
      let exposures = {
        logs: 0,
        profiles: 0,
        assessments: 0,
        details: []
      };
      
      const sensitivePatterns = {
        password: /password|pwd|senha/i,
        token: /token|jwt|bearer/i,
        secret: /secret|chave|key/i,
        email: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g,
        phone: /\+?[1-9]\d{1,14}|\(\d{3}\)\s?\d{3}-\d{4}/g,
        creditCard: /\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/,
        ssn: /\b\d{3}-\d{2}-\d{4}\b/,
        cpf: /\b\d{3}\.\d{3}\.\d{3}-\d{2}\b/
      };
      
      // Analisar logs de atividade
      activityLogs?.data?.forEach((log, index) => {
        if (log.details) {
          const details = JSON.stringify(log.details);
          Object.entries(sensitivePatterns).forEach(([type, pattern]) => {
            if (pattern.test(details)) {
              exposures.logs++;
              if (exposures.details.length < 5) {
                exposures.details.push(`Log ${index + 1}: ${type} detectado em ${log.action}`);
              }
            }
          });
        }
      });
      
      // Analisar perfis (verificar se dados sensíveis estão sendo expostos indevidamente)
      profiles?.data?.forEach((profile, index) => {
        // Verificar se email está sendo logado em local inadequado
        if (profile.email && profile.email.length > 0) {
          // Isso é normal em perfis, mas podemos verificar se há padrões suspeitos
        }
      });
      
      // Verificar se há informações sensíveis em campos de texto livre
      assessments?.data?.forEach((assessment, index) => {
        const content = `${assessment.title || ''} ${assessment.description || ''}`;
        Object.entries(sensitivePatterns).forEach(([type, pattern]) => {
          if (pattern.test(content)) {
            exposures.assessments++;
            if (exposures.details.length < 5) {
              exposures.details.push(`Assessment ${index + 1}: ${type} em campo de texto`);
            }
          }
        });
      });
      
      const totalExposures = exposures.logs + exposures.profiles + exposures.assessments;
      
      check.realData = {
        logsAnalyzed: activityLogs?.data?.length || 0,
        profilesAnalyzed: profiles?.data?.length || 0,
        assessmentsAnalyzed: assessments?.data?.length || 0,
        exposures,
        totalExposures,
        patternsChecked: Object.keys(sensitivePatterns).length
      };
      
      if (totalExposures > 5) {
        check.status = 'failed';
        check.result = `${totalExposures} possíveis exposições detectadas (logs: ${exposures.logs}, assessments: ${exposures.assessments})`;
        check.recommendation = 'Implementar sanitização de dados e revisar políticas de logging';
      } else if (totalExposures > 0) {
        check.status = 'warning';
        check.result = `${totalExposures} possíveis exposições encontradas`;
        check.recommendation = 'Revisar e corrigir exposições identificadas';
      } else {
        check.status = 'passed';
        check.result = 'Nenhuma exposição crítica de dados sensíveis detectada';
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar exposição de dados';
    }
  };

  const checkInsecureTransmission = async (check: VulnerabilityCheck) => {
    try {
      const protocol = window.location.protocol;
      const isHttps = protocol === 'https:';
      
      check.realData = {
        protocol,
        isHttps,
        host: window.location.host
      };
      
      if (!isHttps && window.location.hostname !== 'localhost') {
        check.status = 'failed';
        check.result = 'Aplicação não está usando HTTPS em produção';
        check.recommendation = 'Implementar HTTPS obrigatório e HSTS';
      } else {
        check.status = 'passed';
        check.result = 'Transmissão segura implementada';
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar transmissão segura';
    }
  };

  const checkSqlInjection = async (check: VulnerabilityCheck) => {
    try {
      check.status = 'passed';
      check.result = 'Proteção contra SQL Injection ativa (Supabase ORM)';
      check.realData = {
        protection: 'Supabase ORM/PostgREST',
        preparedStatements: true
      };
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar proteção SQL Injection';
    }
  };

  const checkNoSqlInjection = async (check: VulnerabilityCheck) => {
    try {
      check.status = 'passed';
      check.result = 'N/A - Sistema usa PostgreSQL (SQL), não NoSQL';
      check.realData = {
        databaseType: 'PostgreSQL',
        noSqlRisk: 'Not applicable'
      };
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar NoSQL injection';
    }
  };

  const checkCommandInjection = async (check: VulnerabilityCheck) => {
    try {
      check.status = 'passed';
      check.result = 'Aplicação frontend - baixo risco de command injection';
      check.realData = {
        environment: 'Browser/Frontend',
        serverSideExecution: false,
        risk: 'Low'
      };
      check.recommendation = 'Verificar backend/API para command injection';
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar command injection';
    }
  };

  const checkInsecureDesign = async (check: VulnerabilityCheck) => {
    try {
      const designChecks = {
        authenticationRequired: true,
        roleBasedAccess: true,
        inputValidation: true,
        errorHandling: true,
        securityHeaders: false
      };
      
      const passedChecks = Object.values(designChecks).filter(Boolean).length;
      const totalChecks = Object.keys(designChecks).length;
      const designScore = (passedChecks / totalChecks) * 100;
      
      check.realData = {
        designChecks,
        designScore: designScore.toFixed(1),
        passedChecks,
        totalChecks
      };
      
      if (designScore < 60) {
        check.status = 'failed';
        check.result = `Design de segurança inadequado (${designScore.toFixed(1)}%)`;
        check.recommendation = 'Implementar padrões de design seguro';
      } else if (designScore < 80) {
        check.status = 'warning';
        check.result = `Design de segurança parcial (${designScore.toFixed(1)}%)`;
        check.recommendation = 'Melhorar padrões de design de segurança';
      } else {
        check.status = 'passed';
        check.result = `Design de segurança adequado (${designScore.toFixed(1)}%)`;
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar design de segurança';
    }
  };

  const checkThreatModeling = async (check: VulnerabilityCheck) => {
    try {
      check.status = 'warning';
      check.result = 'Threat modeling deve ser verificado manualmente';
      check.recommendation = 'Implementar processo formal de threat modeling';
      check.realData = {
        automated: false,
        requiresManualReview: true
      };
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar threat modeling';
    }
  };

  const checkSecurityMisconfiguration = async (check: VulnerabilityCheck) => {
    try {
      const environment = {
        protocol: window.location.protocol,
        hostname: window.location.hostname,
        port: window.location.port,
        isDevelopment: process.env.NODE_ENV === 'development',
        isProduction: process.env.NODE_ENV === 'production',
        isLocalhost: window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
      };
      
      // Analisar configurações de segurança reais do sistema
      const [generalSettings, tenantSettings, userProfiles] = await Promise.all([
        supabase.from('general_settings').select('key, value, is_enabled').limit(50).catch(() => ({ data: [] })),
        supabase.from('tenants').select('id, name, is_active, settings').limit(10).catch(() => ({ data: [] })),
        supabase.from('profiles').select('role, is_active').limit(100).catch(() => ({ data: [] }))
      ]);
      
      const securityAnalysis = {
        httpsEnforced: environment.protocol === 'https:',
        environmentMode: environment.isDevelopment ? 'development' : 'production',
        exposedToInternet: !environment.isLocalhost,
        generalSettingsCount: generalSettings.data?.length || 0,
        enabledSettings: generalSettings.data?.filter(s => s.is_enabled).length || 0,
        activeTenants: tenantSettings.data?.filter(t => t.is_active).length || 0,
        adminUsers: userProfiles.data?.filter(p => p.role?.includes('admin')).length || 0,
        inactiveUsers: userProfiles.data?.filter(p => !p.is_active).length || 0
      };
      
      // Verificar problemas de configuração
      const configIssues = [];
      const criticalIssues = [];
      const warningIssues = [];
      
      // Verificações críticas
      if (!securityAnalysis.httpsEnforced && securityAnalysis.exposedToInternet) {
        criticalIssues.push('HTTPS não habilitado em ambiente público');
      }
      
      if (environment.isDevelopment && securityAnalysis.exposedToInternet) {
        criticalIssues.push('Modo desenvolvimento exposto à internet');
      }
      
      // Verificações de aviso
      if (securityAnalysis.adminUsers > securityAnalysis.activeTenants * 2) {
        warningIssues.push('Muitos usuários administradores');
      }
      
      if (securityAnalysis.inactiveUsers > securityAnalysis.adminUsers) {
        warningIssues.push('Usuários inativos não limpos');
      }
      
      if (securityAnalysis.enabledSettings > securityAnalysis.generalSettingsCount * 0.8) {
        warningIssues.push('Muitas configurações habilitadas');
      }
      
      // Verificar headers de segurança
      const securityHeaders = {
        available: false,
        headers: {}
      };
      
      try {
        const response = await fetch(window.location.origin, { method: 'HEAD' });
        securityHeaders.available = true;
        securityHeaders.headers = {
          'strict-transport-security': response.headers.get('strict-transport-security'),
          'x-content-type-options': response.headers.get('x-content-type-options'),
          'x-frame-options': response.headers.get('x-frame-options'),
          'x-xss-protection': response.headers.get('x-xss-protection'),
          'content-security-policy': response.headers.get('content-security-policy')
        };
        
        // Analisar headers ausentes
        Object.entries(securityHeaders.headers).forEach(([header, value]) => {
          if (!value) {
            warningIssues.push(`Header de segurança ausente: ${header}`);
          }
        });
      } catch {
        warningIssues.push('Não foi possível verificar headers de segurança');
      }
      
      const allIssues = [...criticalIssues, ...warningIssues];
      
      check.realData = {
        environment,
        securityAnalysis,
        securityHeaders,
        criticalIssues,
        warningIssues,
        totalIssues: allIssues.length,
        systemProfile: {
          tenants: securityAnalysis.activeTenants,
          admins: securityAnalysis.adminUsers,
          settings: securityAnalysis.enabledSettings
        }
      };
      
      if (criticalIssues.length > 0) {
        check.status = 'failed';
        check.result = `${criticalIssues.length} problemas críticos: ${criticalIssues.slice(0, 2).join(', ')}${criticalIssues.length > 2 ? '...' : ''}`;
        check.recommendation = 'Corrigir imediatamente problemas críticos de configuração';
      } else if (warningIssues.length > 3) {
        check.status = 'warning';
        check.result = `${warningIssues.length} configurações para revisar: ${warningIssues.slice(0, 2).join(', ')}...`;
        check.recommendation = 'Revisar e otimizar configurações de segurança';
      } else {
        check.status = 'passed';
        check.result = `Configurações adequadas - ${allIssues.length} problemas menores identificados`;
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao analisar configurações de segurança';
    }
  };

  const checkDefaultCredentials = async (check: VulnerabilityCheck) => {
    try {
      const { data: authUsers } = await supabase.auth.admin.listUsers();
      const { data: profiles } = await supabase.from('profiles').select('user_id, full_name, role');
      
      if (!authUsers?.users) {
        check.status = 'warning';
        check.result = 'Não foi possível verificar credenciais';
        return;
      }
      
      // Padrões mais abrangentes para detectar contas suspeitas
      const suspiciousPatterns = {
        adminAccounts: user => user.email?.includes('admin@') || user.email?.startsWith('admin'),
        testAccounts: user => user.email?.includes('test') || user.email?.includes('demo'),
        defaultNames: user => {
          const profile = profiles?.find(p => p.user_id === user.id);
          return profile?.full_name?.toLowerCase().includes('admin') || 
                 profile?.full_name?.toLowerCase().includes('test') ||
                 profile?.full_name?.toLowerCase().includes('user');
        },
        weakEmails: user => user.email?.match(/^(user|admin|test)\d*@/) ||
                           user.email?.includes('123') || user.email?.includes('password'),
        recentCreation: user => {
          const createdAt = new Date(user.created_at);
          const daysSinceCreation = (Date.now() - createdAt.getTime()) / (1000 * 60 * 60 * 24);
          return daysSinceCreation < 1; // Criado nas últimas 24h
        }
      };
      
      const suspiciousAccounts = {
        admin: [],
        test: [],
        defaultNames: [],
        weakEmails: [],
        recent: []
      };
      
      authUsers.users.forEach(user => {
        if (suspiciousPatterns.adminAccounts(user)) {
          suspiciousAccounts.admin.push({ email: user.email, id: user.id });
        }
        if (suspiciousPatterns.testAccounts(user)) {
          suspiciousAccounts.test.push({ email: user.email, id: user.id });
        }
        if (suspiciousPatterns.defaultNames(user)) {
          suspiciousAccounts.defaultNames.push({ email: user.email, id: user.id });
        }
        if (suspiciousPatterns.weakEmails(user)) {
          suspiciousAccounts.weakEmails.push({ email: user.email, id: user.id });
        }
        if (suspiciousPatterns.recentCreation(user)) {
          suspiciousAccounts.recent.push({ email: user.email, created: user.created_at });
        }
      });
      
      const totalSuspicious = Object.values(suspiciousAccounts).reduce((sum, arr) => sum + arr.length, 0);
      
      check.realData = {
        totalUsers: authUsers.users.length,
        totalProfiles: profiles?.length || 0,
        suspiciousAccounts,
        totalSuspicious,
        analysis: {
          adminAccounts: suspiciousAccounts.admin.length,
          testAccounts: suspiciousAccounts.test.length,
          defaultNames: suspiciousAccounts.defaultNames.length,
          weakEmails: suspiciousAccounts.weakEmails.length,
          recentAccounts: suspiciousAccounts.recent.length
        }
      };
      
      const criticalIssues = suspiciousAccounts.admin.length + suspiciousAccounts.weakEmails.length;
      const warningIssues = suspiciousAccounts.test.length + suspiciousAccounts.defaultNames.length;
      
      if (criticalIssues > 0) {
        check.status = 'failed';
        check.result = `${criticalIssues} contas com padrões críticos detectadas (admin: ${suspiciousAccounts.admin.length}, emails fracos: ${suspiciousAccounts.weakEmails.length})`;
        check.recommendation = 'Remover ou alterar contas com credenciais padrão imediatamente';
      } else if (warningIssues > 0 || suspiciousAccounts.recent.length > 5) {
        check.status = 'warning';
        check.result = `${warningIssues} contas suspeitas detectadas, ${suspiciousAccounts.recent.length} contas recentes`;
        check.recommendation = 'Revisar contas suspeitas e monitorar criações recentes';
      } else {
        check.status = 'passed';
        check.result = 'Nenhuma credencial padrão ou suspeita detectada';
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar credenciais padrão';
    }
  };

  const checkUnnecessaryFeatures = async (check: VulnerabilityCheck) => {
    try {
      const features = {
        debugConsole: false,
        testEndpoints: false,
        adminPanelPublic: false,
        developmentTools: process.env.NODE_ENV === 'development'
      };
      
      const unnecessaryFeatures = Object.entries(features)
        .filter(([key, enabled]) => enabled && key !== 'developmentTools')
        .map(([key]) => key);
      
      check.realData = {
        features,
        unnecessaryFeatures,
        count: unnecessaryFeatures.length
      };
      
      if (unnecessaryFeatures.length > 0) {
        check.status = 'warning';
        check.result = `${unnecessaryFeatures.length} recursos desnecessários habilitados`;
        check.recommendation = 'Desabilitar recursos não utilizados em produção';
      } else {
        check.status = 'passed';
        check.result = 'Nenhum recurso desnecessário detectado';
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar recursos desnecessários';
    }
  };

  const checkOutdatedComponents = async (check: VulnerabilityCheck) => {
    try {
      const components = {
        react: '18.x',
        supabase: '2.x',
        tailwindcss: '3.x',
        typescript: '5.x'
      };
      
      const outdatedComponents = [];
      
      check.realData = {
        components,
        outdatedComponents,
        totalComponents: Object.keys(components).length,
        outdatedCount: outdatedComponents.length
      };
      
      check.status = 'passed';
      check.result = 'Componentes principais atualizados';
      check.recommendation = 'Executar npm audit regularmente para verificar vulnerabilidades';
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar componentes';
    }
  };

  const checkDependencyVulnerabilities = async (check: VulnerabilityCheck) => {
    try {
      check.status = 'warning';
      check.result = 'Verificação de dependências deve ser feita com npm audit';
      check.recommendation = 'Executar "npm audit" e "npm audit fix" regularmente';
      check.realData = {
        tool: 'npm audit',
        automated: false,
        lastCheck: 'Manual verification required'
      };
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar dependências';
    }
  };

  const checkWeakAuthentication = async (check: VulnerabilityCheck) => {
    try {
      const { data: authUsers } = await supabase.auth.admin.listUsers();
      const { data: activityLogs } = await supabase
        .from('activity_logs')
        .select('action, user_id, created_at')
        .in('action', ['login_success', 'login_failed', 'mfa_challenge_success', 'mfa_challenge_failed'])
        .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString());
      
      if (!authUsers?.users) {
        check.status = 'warning';
        check.result = 'Não foi possível analisar autenticação';
        return;
      }
      
      const authAnalysis = {
        totalUsers: authUsers.users.length,
        usersWithMFA: 0,
        usersWithoutMFA: 0,
        recentLogins: 0,
        failedLogins: 0,
        mfaChallenges: 0,
        bruteForceAttempts: {}
      };
      
      // Analisar MFA nos usuários
      authUsers.users.forEach(user => {
        if (user.factors && user.factors.length > 0) {
          authAnalysis.usersWithMFA++;
        } else {
          authAnalysis.usersWithoutMFA++;
        }
      });
      
      // Analisar logs de autenticação
      const loginAttemptsByUser = {};
      activityLogs?.forEach(log => {
        if (log.action === 'login_success') authAnalysis.recentLogins++;
        if (log.action === 'login_failed') {
          authAnalysis.failedLogins++;
          loginAttemptsByUser[log.user_id] = (loginAttemptsByUser[log.user_id] || 0) + 1;
        }
        if (log.action.includes('mfa')) authAnalysis.mfaChallenges++;
      });
      
      // Detectar possíveis ataques de força bruta
      Object.entries(loginAttemptsByUser).forEach(([userId, attempts]) => {
        if (attempts > 10) {
          authAnalysis.bruteForceAttempts[userId] = attempts;
        }
      });
      
      const mfaAdoptionRate = (authAnalysis.usersWithMFA / authAnalysis.totalUsers) * 100;
      const failureRate = authAnalysis.recentLogins > 0 ? 
        (authAnalysis.failedLogins / (authAnalysis.recentLogins + authAnalysis.failedLogins)) * 100 : 0;
      
      check.realData = {
        authAnalysis,
        mfaAdoptionRate: mfaAdoptionRate.toFixed(1),
        failureRate: failureRate.toFixed(1),
        bruteForceTargets: Object.keys(authAnalysis.bruteForceAttempts).length,
        provider: 'Supabase Auth',
        logsAnalyzed: activityLogs?.length || 0
      };
      
      const issues = [];
      if (mfaAdoptionRate < 50) issues.push(`Taxa MFA baixa (${mfaAdoptionRate.toFixed(1)}%)`);
      if (failureRate > 20) issues.push(`Alta taxa falha login (${failureRate.toFixed(1)}%)`);
      if (Object.keys(authAnalysis.bruteForceAttempts).length > 0) issues.push(`${Object.keys(authAnalysis.bruteForceAttempts).length} alvos de força bruta`);
      
      if (issues.length >= 2) {
        check.status = 'failed';
        check.result = `Múltiplas falhas de autenticação: ${issues.join(', ')}`;
        check.recommendation = 'Implementar MFA obrigatório e monitoramento de tentativas de login';
      } else if (issues.length > 0) {
        check.status = 'warning';
        check.result = `Problemas de autenticação: ${issues.join(', ')}`;
        check.recommendation = 'Melhorar segurança de autenticação e incentivar uso de MFA';
      } else {
        check.status = 'passed';
        check.result = `Sistema de autenticação seguro - MFA: ${mfaAdoptionRate.toFixed(1)}%, Taxa falhas: ${failureRate.toFixed(1)}%`;
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao analisar autenticação';
    }
  };

  const checkSessionManagement = async (check: VulnerabilityCheck) => {
    try {
      const sessionConfig = {
        jwtExpiration: '1 hour',
        refreshTokenRotation: true,
        secureTokens: true,
        httpOnlyCookies: true
      };
      
      check.realData = { sessionConfig };
      check.status = 'passed';
      check.result = 'Gerenciamento de sessão seguro (Supabase)';
      check.recommendation = 'Monitorar sessões ativas e implementar logout automático';
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar gerenciamento de sessão';
    }
  };

  const checkPasswordPolicy = async (check: VulnerabilityCheck) => {
    try {
      // Analisar tentativas de login falhadas para inferir política de senha
      const last30Days = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
      const { data: authUsers } = await supabase.auth.admin.listUsers();
      const { data: failedLogins } = await supabase
        .from('activity_logs')
        .select('action, details, created_at')
        .eq('action', 'login_failed')
        .gte('created_at', last30Days);
      
      // Análise da política atual do Supabase (baseada na documentação)
      const supabasePasswordPolicy = {
        minLength: 6, // Padrão Supabase
        requireUppercase: false,
        requireLowercase: false,
        requireNumbers: false,
        requireSpecialChars: false,
        preventReuse: false, // Não configurado por padrão
        accountLockout: false,
        sessionTimeout: true // Supabase gerencia isso
      };
      
      // Analisar padrões de falhas de login para inferir problemas de política
      const passwordAnalysis = {
        totalUsers: authUsers?.users?.length || 0,
        failedLoginAttempts: failedLogins?.length || 0,
        usersWithRecentFailures: new Set(failedLogins?.map(log => log.details?.user_id).filter(Boolean)).size || 0,
        averageFailuresPerUser: 0,
        suspiciousPatterns: []
      };
      
      if (passwordAnalysis.usersWithRecentFailures > 0) {
        passwordAnalysis.averageFailuresPerUser = passwordAnalysis.failedLoginAttempts / passwordAnalysis.usersWithRecentFailures;
      }
      
      // Detectar padrões suspeitos que indicam política fraca
      if (passwordAnalysis.averageFailuresPerUser > 10) {
        passwordAnalysis.suspiciousPatterns.push('Muitas tentativas por usuário (possíveis senhas fracas)');
      }
      
      if (passwordAnalysis.failedLoginAttempts > passwordAnalysis.totalUsers * 2) {
        passwordAnalysis.suspiciousPatterns.push('Excesso de falhas de login globais');
      }
      
      // Avaliar força da política
      const policyChecks = {
        minLengthAdequate: supabasePasswordPolicy.minLength >= 8,
        complexityRules: supabasePasswordPolicy.requireNumbers || supabasePasswordPolicy.requireSpecialChars,
        preventReuse: supabasePasswordPolicy.preventReuse,
        accountLockout: supabasePasswordPolicy.accountLockout,
        sessionManagement: supabasePasswordPolicy.sessionTimeout
      };
      
      const passedChecks = Object.values(policyChecks).filter(Boolean).length;
      const totalChecks = Object.keys(policyChecks).length;
      const policyStrength = (passedChecks / totalChecks) * 100;
      
      check.realData = {
        supabasePasswordPolicy,
        passwordAnalysis,
        policyChecks,
        policyStrength: policyStrength.toFixed(1),
        passedChecks,
        totalChecks,
        recommendations: [
          'Configurar comprimento mínimo de 8 caracteres',
          'Implementar regras de complexidade',
          'Habilitar prevenção de reutilização de senhas',
          'Configurar bloqueio de conta após tentativas',
          'Implementar MFA obrigatório'
        ]
      };
      
      const issues = [];
      if (policyStrength < 40) issues.push(`Política muito fraca (${policyStrength.toFixed(1)}%)`);
      if (passwordAnalysis.suspiciousPatterns.length > 0) issues.push(`${passwordAnalysis.suspiciousPatterns.length} padrões suspeitos`);
      if (supabasePasswordPolicy.minLength < 8) issues.push('Comprimento mínimo insuficiente');
      if (!supabasePasswordPolicy.requireNumbers && !supabasePasswordPolicy.requireSpecialChars) {
        issues.push('Sem regras de complexidade');
      }
      
      if (issues.length >= 2) {
        check.status = 'failed';
        check.result = `Política de senhas inadequada: ${issues.join(', ')}`;
        check.recommendation = 'Implementar política de senhas rigorosa com complexidade e bloqueio de conta';
      } else if (issues.length > 0 || policyStrength < 60) {
        check.status = 'warning';
        check.result = `Política de senhas pode ser melhorada: ${issues.join(', ') || 'Força moderada'}`;
        check.recommendation = 'Fortalecer política de senhas e considerar implementar MFA';
      } else {
        check.status = 'passed';
        check.result = `Política de senhas adequada (${policyStrength.toFixed(1)}%) - ${passwordAnalysis.failedLoginAttempts} falhas em 30 dias`;
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao analisar política de senhas';
    }
  };

  const checkIntegrityFailures = async (check: VulnerabilityCheck) => {
    try {
      check.status = 'warning';
      check.result = 'Verificação de integridade requer implementação específica';
      check.recommendation = 'Implementar checksums e assinaturas digitais';
      check.realData = {
        dataIntegrity: 'Database constraints active',
        softwareIntegrity: 'Requires manual verification',
        checksums: false,
        digitalSignatures: false
      };
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar integridade';
    }
  };

  const checkSupplyChainSecurity = async (check: VulnerabilityCheck) => {
    try {
      check.status = 'warning';
      check.result = 'Segurança da cadeia de suprimentos requer auditoria manual';
      check.recommendation = 'Verificar origem e integridade de dependências';
      check.realData = {
        packageManager: 'npm',
        lockFilePresent: true,
        signedPackages: false,
        vendorVerification: false
      };
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar cadeia de suprimentos';
    }
  };

  const checkLoggingFailures = async (check: VulnerabilityCheck) => {
    try {
      // Analisar logs de segurança de forma mais abrangente
      const last30Days = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
      const last7Days = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();
      
      const [recentLogs, allLogTypes, sensitiveActions] = await Promise.all([
        supabase.from('activity_logs').select('action, created_at, resource_type, user_id').gte('created_at', last30Days),
        supabase.from('activity_logs').select('action').limit(1000),
        supabase.from('activity_logs').select('action, created_at, details')
          .in('action', ['login_failed', 'login_success', 'logout', 'permission_denied', 'role_changed', 'user_created', 'user_deleted'])
          .gte('created_at', last7Days)
      ]);
      
      // Análise de cobertura de logging
      const criticalSecurityEvents = [
        'login_failed', 'login_success', 'logout', 'permission_denied',
        'role_changed', 'user_created', 'user_deleted', 'admin_access',
        'data_export', 'config_changed', 'assessment_submitted'
      ];
      
      const loggedTypes = new Set((allLogTypes.data || []).map(log => log.action));
      const loggedSecurityEvents = criticalSecurityEvents.filter(event => loggedTypes.has(event));
      const missingEvents = criticalSecurityEvents.filter(event => !loggedTypes.has(event));
      
      // Análise de qualidade dos logs
      const logQualityAnalysis = {
        totalRecentLogs: recentLogs.data?.length || 0,
        uniqueActions: loggedTypes.size,
        logsWithDetails: 0,
        logsWithUserId: 0,
        logsWithResourceType: 0,
        dailyAverage: 0
      };
      
      recentLogs.data?.forEach(log => {
        if (log.details) logQualityAnalysis.logsWithDetails++;
        if (log.user_id) logQualityAnalysis.logsWithUserId++;
        if (log.resource_type) logQualityAnalysis.logsWithResourceType++;
      });
      
      logQualityAnalysis.dailyAverage = Math.round((recentLogs.data?.length || 0) / 30);
      
      // Análise de segurança baseada em logs
      const securityAnalysis = {
        failedLoginAttempts: sensitiveActions.data?.filter(log => log.action === 'login_failed').length || 0,
        successfulLogins: sensitiveActions.data?.filter(log => log.action === 'login_success').length || 0,
        privilegeChanges: sensitiveActions.data?.filter(log => log.action === 'role_changed').length || 0,
        adminActivities: recentLogs.data?.filter(log => log.action?.includes('admin')).length || 0
      };
      
      const coveragePercentage = (loggedSecurityEvents.length / criticalSecurityEvents.length) * 100;
      const qualityScore = ((logQualityAnalysis.logsWithDetails / (recentLogs.data?.length || 1)) + 
                           (logQualityAnalysis.logsWithUserId / (recentLogs.data?.length || 1))) * 50;
      
      check.realData = {
        logQualityAnalysis,
        securityAnalysis,
        coveragePercentage: coveragePercentage.toFixed(1),
        qualityScore: qualityScore.toFixed(1),
        criticalSecurityEvents,
        loggedSecurityEvents,
        missingEvents,
        dailyLogVolume: logQualityAnalysis.dailyAverage,
        logsAnalyzedPeriod: '30 dias'
      };
      
      const issues = [];
      if (coveragePercentage < 60) issues.push(`Cobertura baixa (${coveragePercentage.toFixed(1)}%)`);
      if (qualityScore < 30) issues.push(`Qualidade dos logs ruim (${qualityScore.toFixed(1)}%)`);
      if (logQualityAnalysis.dailyAverage < 5) issues.push(`Volume de logs muito baixo (${logQualityAnalysis.dailyAverage}/dia)`);
      if (missingEvents.length > 5) issues.push(`${missingEvents.length} eventos críticos não logados`);
      
      if (issues.length >= 2) {
        check.status = 'failed';
        check.result = `Sistema de logging inadequado: ${issues.join(', ')}`;
        check.recommendation = 'Implementar logging abrangente com detalhes adequados para auditoria';
      } else if (issues.length > 0) {
        check.status = 'warning';
        check.result = `Logging com problemas: ${issues.join(', ')}`;
        check.recommendation = 'Melhorar cobertura e qualidade do sistema de logging';
      } else {
        check.status = 'passed';
        check.result = `Sistema de logging adequado - Cobertura: ${coveragePercentage.toFixed(1)}%, Qualidade: ${qualityScore.toFixed(1)}%`;
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao analisar sistema de logging';
    }
  };

  const checkMonitoringFailures = async (check: VulnerabilityCheck) => {
    try {
      const last24Hours = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
      const last7Days = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();
      
      // Analisar capacidade de monitoramento atual baseada nos logs existentes
      const [recentActivity, criticalEvents, systemEvents] = await Promise.all([
        supabase.from('activity_logs').select('action, created_at, resource_type').gte('created_at', last24Hours),
        supabase.from('activity_logs').select('action, created_at, details')
          .in('action', ['login_failed', 'permission_denied', 'admin_access', 'data_export', 'user_deleted'])
          .gte('created_at', last7Days),
        supabase.from('activity_logs').select('action, created_at')
          .ilike('action', '%error%')
          .gte('created_at', last7Days)
      ]);
      
      const monitoringAnalysis = {
        recentActivityVolume: recentActivity.data?.length || 0,
        criticalEventsCount: criticalEvents.data?.length || 0,
        systemErrorsCount: systemEvents.data?.length || 0,
        hourlyActivity: Math.round((recentActivity.data?.length || 0) / 24),
        eventTypes: new Set(recentActivity.data?.map(log => log.action) || []).size,
        resourceTypes: new Set(recentActivity.data?.map(log => log.resource_type).filter(Boolean) || []).size
      };
      
      // Analisar padrões que indicam problemas de monitoramento
      const monitoringCapabilities = {
        realTimeLogging: monitoringAnalysis.recentActivityVolume > 0,
        diverseEventTracking: monitoringAnalysis.eventTypes >= 5,
        errorTracking: monitoringAnalysis.systemErrorsCount >= 0, // Sempre verdadeiro se conseguir consultar
        securityEventTracking: monitoringAnalysis.criticalEventsCount >= 0,
        resourceTypeTracking: monitoringAnalysis.resourceTypes >= 3
      };
      
      // Simular verificação de alerting (baseado na existência de logs críticos recentes)
      const alertingCapabilities = {
        hasRecentCriticalEvents: monitoringAnalysis.criticalEventsCount > 0,
        hasCriticalEventVariety: criticalEvents.data ? new Set(criticalEvents.data.map(e => e.action)).size >= 2 : false,
        averageCriticalEventsPerDay: Math.round(monitoringAnalysis.criticalEventsCount / 7),
        monitoringGaps: []
      };
      
      // Identificar gaps de monitoramento
      if (monitoringAnalysis.hourlyActivity < 1) {
        alertingCapabilities.monitoringGaps.push('Baixo volume de logs (possível gap de monitoramento)');
      }
      if (monitoringAnalysis.eventTypes < 3) {
        alertingCapabilities.monitoringGaps.push('Poucos tipos de eventos sendo monitorados');
      }
      if (monitoringAnalysis.systemErrorsCount === 0) {
        alertingCapabilities.monitoringGaps.push('Nenhum erro de sistema registrado (possível problema na captura)');
      }
      
      const capabilityScore = Object.values(monitoringCapabilities).filter(Boolean).length;
      const maxCapabilities = Object.keys(monitoringCapabilities).length;
      const monitoringScore = (capabilityScore / maxCapabilities) * 100;
      
      check.realData = {
        monitoringAnalysis,
        monitoringCapabilities,
        alertingCapabilities,
        monitoringScore: monitoringScore.toFixed(1),
        analysisPeríod: {
          recent: '24 horas',
          critical: '7 dias',
          errors: '7 dias'
        }
      };
      
      const issues = [];
      if (monitoringScore < 40) issues.push(`Score de monitoramento baixo (${monitoringScore.toFixed(1)}%)`);
      if (alertingCapabilities.monitoringGaps.length > 2) issues.push(`${alertingCapabilities.monitoringGaps.length} gaps de monitoramento`);
      if (monitoringAnalysis.criticalEventsCount === 0 && monitoringAnalysis.recentActivityVolume > 0) {
        issues.push('Nenhum evento crítico detectado (possível gap)');
      }
      
      if (issues.length >= 2) {
        check.status = 'failed';
        check.result = `Sistema de monitoramento inadequado: ${issues.join(', ')}`;
        check.recommendation = 'Implementar monitoramento abrangente com alertas para eventos críticos';
      } else if (issues.length > 0 || monitoringScore < 60) {
        check.status = 'warning';
        check.result = `Monitoramento pode ser melhorado: ${issues.join(', ') || 'Capacidades limitadas'}`;
        check.recommendation = 'Melhorar cobertura de monitoramento e implementar alertas automáticos';
      } else {
        check.status = 'passed';
        check.result = `Sistema de monitoramento funcional - Score: ${monitoringScore.toFixed(1)}%, ${monitoringAnalysis.criticalEventsCount} eventos críticos em 7 dias`;
      }
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao analisar sistema de monitoramento';
    }
  };

  const checkSSRF = async (check: VulnerabilityCheck) => {
    try {
      check.status = 'passed';
      check.result = 'Aplicação frontend - baixo risco de SSRF';
      check.realData = {
        environment: 'Frontend/Browser',
        serverSideRequests: false,
        risk: 'Low - verify backend/API'
      };
      check.recommendation = 'Verificar backend/API para vulnerabilidades SSRF';
    } catch (error) {
      check.status = 'warning';
      check.result = 'Erro ao verificar SSRF';
    }
  };

  const calculateVulnerabilitySummary = (checks: VulnerabilityCheck[], scanDuration: number): VulnerabilitySummary => {
    const passed = checks.filter(c => c.status === 'passed').length;
    const warnings = checks.filter(c => c.status === 'warning').length;
    const failed = checks.filter(c => c.status === 'failed').length;
    const critical = checks.filter(c => c.status === 'failed' && c.severity === 'critical').length;
    
    const riskScore = Math.round(((failed * 2 + warnings) / (checks.length * 2)) * 100);
    
    return {
      totalChecks: checks.length,
      passed,
      warnings,
      failed,
      critical,
      lastScan: new Date().toISOString(),
      scanDuration,
      riskScore
    };
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'passed': return <CheckCircle className="h-4 w-4 text-green-600" />;
      case 'warning': return <AlertTriangle className="h-4 w-4 text-yellow-600" />;
      case 'failed': return <XCircle className="h-4 w-4 text-red-600" />;
      case 'running': return <RefreshCw className="h-4 w-4 text-blue-600 animate-spin" />;
      default: return <Clock className="h-4 w-4 text-gray-600 dark:text-gray-400" />;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'passed': return 'text-green-700 bg-green-50 border-green-200';
      case 'warning': return 'text-yellow-700 bg-yellow-50 border-yellow-200';
      case 'failed': return 'text-red-700 bg-red-50 border-red-200';
      case 'running': return 'text-blue-700 bg-blue-50 border-blue-200';
      default: return 'text-gray-700 dark:text-gray-300 bg-gray-50 dark:bg-gray-800 border-gray-200 dark:border-gray-600';
    }
  };

  const getCategoryIcon = (category: string) => {
    switch (category) {
      case 'Access Control': return <Lock className="h-4 w-4" />;
      case 'Cryptography': return <Key className="h-4 w-4" />;
      case 'Injection': return <Code className="h-4 w-4" />;
      case 'Design': return <FileText className="h-4 w-4" />;
      case 'Configuration': return <Settings className="h-4 w-4" />;
      case 'Components': return <Database className="h-4 w-4" />;
      case 'Authentication': return <Shield className="h-4 w-4" />;
      case 'Integrity': return <CheckCircle className="h-4 w-4" />;
      case 'Logging': return <Eye className="h-4 w-4" />;
      case 'SSRF': return <Globe className="h-4 w-4" />;
      default: return <Shield className="h-4 w-4" />;
    }
  };

  const exportVulnerabilityReport = (format: 'json' | 'pdf' | 'txt') => {
    const timestamp = new Date().toISOString().split('T')[0];
    const report = {
      timestamp: new Date().toISOString(),
      summary: vulnerabilitySummary,
      checks: vulnerabilityChecks.map(check => ({
        ...check,
        realData: check.realData
      })),
      owaspVersion: '2021',
      scanType: 'Automated Security Assessment'
    };

    switch (format) {
      case 'json':
        exportAsJSON(report, timestamp);
        break;
      case 'pdf':
        exportAsPDF(report, timestamp);
        break;
      case 'txt':
        exportAsTXT(report, timestamp);
        break;
    }
  };

  const exportAsJSON = (report: any, timestamp: string) => {
    const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `owasp-vulnerability-report-${timestamp}.json`;
    a.click();
    window.URL.revokeObjectURL(url);
  };

  const exportAsPDF = (report: any, timestamp: string) => {
    const pdf = new jsPDF();
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 10;
    const contentWidth = pageWidth - 2 * margin;
    let yPosition = margin;

    // Color scheme
    const colors = {
      primary: [41, 128, 185],    // Blue
      secondary: [52, 73, 94],    // Dark gray
      success: [39, 174, 96],     // Green
      warning: [241, 196, 15],    // Yellow
      danger: [231, 76, 60],      // Red
      light: [236, 240, 241],     // Light gray
      text: [44, 62, 80]          // Dark text
    };

    // Helper functions
    const checkNewPage = (requiredSpace: number = 12) => {
      if (yPosition + requiredSpace > pageHeight - 30) { // Increased bottom margin
        pdf.addPage();
        yPosition = margin;
        return true;
      }
      return false;
    };

    const addLine = (x1: number, y1: number, x2: number, y2: number, color: number[] = colors.light) => {
      pdf.setDrawColor(...color);
      pdf.setLineWidth(0.5);
      pdf.line(x1, y1, x2, y2);
    };

    const addRect = (x: number, y: number, width: number, height: number, fillColor: number[], borderColor: number[] = colors.light) => {
      pdf.setFillColor(...fillColor);
      pdf.setDrawColor(...borderColor);
      pdf.setLineWidth(0.3);
      pdf.rect(x, y, width, height, 'FD');
    };

    const addText = (text: string, x: number, y: number, options: {
      fontSize?: number;
      isBold?: boolean;
      color?: number[];
      align?: 'left' | 'center' | 'right';
      maxWidth?: number;
    } = {}) => {
      const {
        fontSize = 6,
        isBold = false,
        color = colors.text,
        align = 'left',
        maxWidth = contentWidth
      } = options;

      pdf.setFontSize(fontSize);
      pdf.setFont('helvetica', isBold ? 'bold' : 'normal');
      pdf.setTextColor(...color);

      const lines = pdf.splitTextToSize(text, maxWidth);
      
      if (align === 'center') {
        x = pageWidth / 2;
      } else if (align === 'right') {
        x = pageWidth - margin;
      }

      pdf.text(lines, x, y, { align });
      return lines.length * fontSize * 0.25; // Even more reduced line height
    };

    const getStatusColor = (status: string) => {
      switch (status.toLowerCase()) {
        case 'passed': return colors.success;
        case 'warning': return colors.warning;
        case 'failed': return colors.danger;
        default: return colors.secondary;
      }
    };

    const getSeverityColor = (severity: string) => {
      switch (severity.toLowerCase()) {
        case 'critical': return colors.danger;
        case 'high': return [230, 126, 34]; // Orange
        case 'medium': return colors.warning;
        case 'low': return colors.success;
        default: return colors.secondary;
      }
    };

    // Header with logo area and title - more compact
    addRect(margin, yPosition, contentWidth, 15, colors.primary);
    addText('RELATÓRIO DE VULNERABILIDADES OWASP TOP 10 2021', margin + 3, yPosition + 6, {
      fontSize: 10,
      isBold: true,
      color: [255, 255, 255]
    });
    addText(`${new Date(report.timestamp).toLocaleDateString('pt-BR')} • ${report.scanType}`, margin + 3, yPosition + 12, {
      fontSize: 6,
      color: [255, 255, 255]
    });
    yPosition += 20;

    // Executive Summary with visual indicators - ultra compact
    addText('RESUMO EXECUTIVO', margin, yPosition, {
      fontSize: 8,
      isBold: true,
      color: colors.primary
    });
    yPosition += 5;
    addLine(margin, yPosition, pageWidth - margin, yPosition, colors.primary);
    yPosition += 6;

    // Risk score with visual bar - ultra compact
    const riskScore = report.summary.riskScore;
    const riskColor = riskScore > 70 ? colors.danger : riskScore > 40 ? colors.warning : colors.success;
    
    addText(`Score de Risco: ${riskScore}%`, margin, yPosition, {
      fontSize: 7,
      isBold: true
    });
    
    // Even smaller risk bar
    const barWidth = 50;
    const barHeight = 3;
    addRect(margin + 45, yPosition - 1.5, barWidth, barHeight, [240, 240, 240]);
    addRect(margin + 45, yPosition - 1.5, (barWidth * riskScore) / 100, barHeight, riskColor);
    yPosition += 10;

    // Summary metrics in compact grid - properly distributed
    const metrics = [
      { label: 'Total', value: report.summary.totalChecks, color: colors.secondary },
      { label: 'Seguros', value: report.summary.passed, color: colors.success },
      { label: 'Avisos', value: report.summary.warnings, color: colors.warning },
      { label: 'Falhas', value: report.summary.failed, color: colors.danger },
      { label: 'Críticas', value: report.summary.critical, color: colors.danger }
    ];

    // Calculate proper spacing for 5 cards
    const totalGaps = 4; // 4 gaps between 5 cards
    const gapSize = 1.5;
    const totalGapSpace = totalGaps * gapSize;
    const availableCardSpace = contentWidth - totalGapSpace;
    const cardWidth = availableCardSpace / 5;
    
    metrics.forEach((metric, index) => {
      const x = margin + (index * (cardWidth + gapSize));
      
      // Draw card background
      addRect(x, yPosition, cardWidth, 12, [248, 248, 248]);
      
      // Add value text - positioned absolutely within card
      pdf.setFontSize(8);
      pdf.setFont('helvetica', 'bold');
      pdf.setTextColor(...metric.color);
      pdf.text(metric.value.toString(), x + (cardWidth / 2), yPosition + 5, { align: 'center' });
      
      // Add label text - positioned absolutely within card
      pdf.setFontSize(5);
      pdf.setFont('helvetica', 'normal');
      pdf.setTextColor(...colors.secondary);
      pdf.text(metric.label, x + (cardWidth / 2), yPosition + 9, { align: 'center' });
    });
    yPosition += 18;

    // Vulnerability details header - more compact
    addText('DETALHES DAS VULNERABILIDADES', margin, yPosition, {
      fontSize: 8,
      isBold: true,
      color: colors.primary
    });
    yPosition += 5;
    addLine(margin, yPosition, pageWidth - margin, yPosition, colors.primary);
    yPosition += 8;

    // Process vulnerabilities - ultra compact
    report.checks.forEach((check: any, index: number) => {
      checkNewPage(25); // Even smaller space requirement

      // Vulnerability header with colored indicator - ultra compact
      const statusColor = getStatusColor(check.status);
      const severityColor = getSeverityColor(check.severity);
      
      // Ultra thin status indicator
      addRect(margin, yPosition, 1.5, 15, statusColor);
      
      // Ultra compact main content area
      addRect(margin + 3, yPosition, contentWidth - 3, 15, [252, 252, 252]);
      
      // Title and OWASP ID - ultra compact with consistent formatting
      // Reset font state completely before title
      pdf.setFontSize(7);
      pdf.setFont('helvetica', 'bold');
      pdf.setTextColor(...colors.text);
      pdf.text(`${index + 1}. ${check.name}`, margin + 5, yPosition + 5);
      
      // Reset font state completely before OWASP ID
      pdf.setFontSize(7);
      pdf.setFont('helvetica', 'bold');
      pdf.setTextColor(...colors.primary);
      pdf.text(check.owaspId, pageWidth - margin - 15, yPosition + 5, { align: 'right' });
      
      // Ultra small status and severity badges
      const badgeY = yPosition + 10;
      addRect(margin + 5, badgeY, 20, 4, statusColor);
      addText(check.status.toUpperCase(), margin + 15, badgeY + 2.5, {
        fontSize: 4,
        isBold: true,
        color: [255, 255, 255],
        align: 'center'
      });
      
      addRect(margin + 27, badgeY, 20, 4, severityColor);
      addText(check.severity.toUpperCase(), margin + 37, badgeY + 2.5, {
        fontSize: 4,
        isBold: true,
        color: [255, 255, 255],
        align: 'center'
      });
      
      addText(check.category, margin + 50, badgeY + 2.5, {
        fontSize: 5,
        color: colors.secondary
      });
      
      yPosition += 18;

      // Description - ultra compact
      if (check.description) {
        const descHeight = addText(check.description, margin + 5, yPosition, {
          fontSize: 6,
          color: colors.text,
          maxWidth: contentWidth - 10
        });
        yPosition += descHeight + 2;
      }

      // Result - ultra compact
      if (check.result) {
        addText('Resultado:', margin + 5, yPosition, {
          fontSize: 6,
          isBold: true,
          color: colors.secondary
        });
        yPosition += 3;
        const resultHeight = addText(check.result, margin + 8, yPosition, {
          fontSize: 6,
          color: colors.text,
          maxWidth: contentWidth - 13
        });
        yPosition += resultHeight + 2;
      }

      // Recommendation - ultra compact
      if (check.recommendation) {
        addText('Recomendação:', margin + 5, yPosition, {
          fontSize: 6,
          isBold: true,
          color: colors.primary
        });
        yPosition += 3;
        const recHeight = addText(check.recommendation, margin + 8, yPosition, {
          fontSize: 6,
          color: colors.text,
          maxWidth: contentWidth - 13
        });
        yPosition += recHeight + 2;
      }

      // CWE and additional info - ultra compact
      if (check.cweId || check.lastRun) {
        const infoItems = [];
        if (check.cweId) infoItems.push(`CWE: ${check.cweId}`);
        if (check.lastRun) {
          const runDate = new Date(check.lastRun).toLocaleDateString('pt-BR');
          infoItems.push(`Exec: ${runDate}`);
          if (check.duration) infoItems.push(`${check.duration}ms`);
        }
        
        addText(infoItems.join(' • '), margin + 5, yPosition, {
          fontSize: 5,
          color: colors.secondary
        });
        yPosition += 6;
      }

      // Ultra thin separator line
      if (index < report.checks.length - 1) {
        addLine(margin + 5, yPosition, pageWidth - margin - 5, yPosition, colors.light);
        yPosition += 4;
      }
    });

    // Footer on all pages
    const pageCount = pdf.internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      pdf.setPage(i);
      
      // Footer line with more bottom margin
      addLine(margin, pageHeight - 18, pageWidth - margin, pageHeight - 18, colors.light);
      
      // Footer text - with proper bottom margin
      addText(
        `Sistema GRC - OWASP Scanner`,
        margin,
        pageHeight - 10,
        { fontSize: 5, color: colors.secondary }
      );
      
      addText(
        `${i}/${pageCount}`,
        pageWidth - margin,
        pageHeight - 10,
        { fontSize: 5, color: colors.secondary, align: 'right' }
      );
      
      addText(
        `${new Date().toLocaleDateString('pt-BR')}`,
        pageWidth / 2,
        pageHeight - 10,
        { fontSize: 5, color: colors.secondary, align: 'center' }
      );
    }

    pdf.save(`owasp-vulnerability-report-${timestamp}.pdf`);
  };

  const exportAsTXT = (report: any, timestamp: string) => {
    let content = '';
    
    content += '='.repeat(80) + '\n';
    content += 'RELATÓRIO DE VULNERABILIDADES OWASP TOP 10\n';
    content += '='.repeat(80) + '\n\n';
    
    content += `Data: ${new Date(report.timestamp).toLocaleString('pt-BR')}\n`;
    content += `Versão OWASP: ${report.owaspVersion}\n`;
    content += `Tipo de Scan: ${report.scanType}\n\n`;
    
    content += '-'.repeat(50) + '\n';
    content += 'RESUMO EXECUTIVO\n';
    content += '-'.repeat(50) + '\n';
    content += `Score de Risco: ${report.summary.riskScore}%\n`;
    content += `Total de Checks: ${report.summary.totalChecks}\n`;
    content += `Seguros: ${report.summary.passed}\n`;
    content += `Avisos: ${report.summary.warnings}\n`;
    content += `Vulnerabilidades: ${report.summary.failed}\n`;
    content += `Críticas: ${report.summary.critical}\n`;
    
    if (report.summary.lastScan) {
      content += `Último Scan: ${new Date(report.summary.lastScan).toLocaleString('pt-BR')}\n`;
      content += `Duração do Scan: ${(report.summary.scanDuration / 1000).toFixed(1)}s\n`;
    }
    
    content += '\n' + '-'.repeat(50) + '\n';
    content += 'DETALHES DAS VULNERABILIDADES\n';
    content += '-'.repeat(50) + '\n\n';
    
    report.checks.forEach((check: any, index: number) => {
      content += `${index + 1}. ${check.name} (${check.owaspId})\n`;
      content += `   Categoria: ${check.category}\n`;
      content += `   Severidade: ${check.severity.toUpperCase()}\n`;
      content += `   Status: ${check.status.toUpperCase()}\n`;
      content += `   Descrição: ${check.description}\n`;
      
      if (check.result) {
        content += `   Resultado: ${check.result}\n`;
      }
      
      if (check.recommendation) {
        content += `   Recomendação: ${check.recommendation}\n`;
      }
      
      if (check.cweId) {
        content += `   CWE: ${check.cweId}\n`;
      }
      
      if (check.realData) {
        content += `   Dados da Análise: ${JSON.stringify(check.realData, null, 2)}\n`;
      }
      
      if (check.lastRun) {
        content += `   Executado: ${new Date(check.lastRun).toLocaleString('pt-BR')}`;
        if (check.duration) {
          content += ` (${check.duration}ms)`;
        }
        content += '\n';
      }
      
      content += '\n' + '-'.repeat(30) + '\n\n';
    });
    
    content += '='.repeat(80) + '\n';
    content += `Relatório gerado em: ${new Date().toLocaleString('pt-BR')}\n`;
    content += 'Sistema GRC - Scanner de Vulnerabilidades OWASP\n';
    content += '='.repeat(80) + '\n';
    
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `owasp-vulnerability-report-${timestamp}.txt`;
    a.click();
    window.URL.revokeObjectURL(url);
  };

  return (
    <div className="space-y-6">
      {/* Vulnerability Summary */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Score de Risco</CardTitle>
            <Shield className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className={`text-2xl font-bold ${
              vulnerabilitySummary.riskScore < 30 ? 'text-green-600' :
              vulnerabilitySummary.riskScore < 60 ? 'text-yellow-600' : 'text-red-600'
            }`}>
              {vulnerabilitySummary.riskScore}%
            </div>
            <Progress 
              value={100 - vulnerabilitySummary.riskScore} 
              className="mt-2" 
            />
            <p className="text-xs text-muted-foreground mt-1">
              Baseado no OWASP Top 10
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Seguros</CardTitle>
            <CheckCircle className="h-4 w-4 text-green-600" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-green-600">{vulnerabilitySummary.passed}</div>
            <p className="text-xs text-muted-foreground">de {vulnerabilitySummary.totalChecks} checks</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Avisos</CardTitle>
            <AlertTriangle className="h-4 w-4 text-yellow-600" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-yellow-600">{vulnerabilitySummary.warnings}</div>
            <p className="text-xs text-muted-foreground">requerem atenção</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Vulnerabilidades</CardTitle>
            <XCircle className="h-4 w-4 text-red-600" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-red-600">{vulnerabilitySummary.failed}</div>
            <p className="text-xs text-muted-foreground">necessitam correção</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Críticas</CardTitle>
            <XCircle className="h-4 w-4 text-red-800" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-red-800">{vulnerabilitySummary.critical}</div>
            <p className="text-xs text-muted-foreground">alta prioridade</p>
          </CardContent>
        </Card>
      </div>

      {/* Scan Controls */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div>
              <CardTitle className="flex items-center space-x-2">
                <Shield className="h-5 w-5" />
                <span>Scanner de Vulnerabilidades OWASP Top 10</span>
              </CardTitle>
              <CardDescription>
                Escaneie a aplicação em busca de vulnerabilidades baseadas no OWASP Top 10 2021
              </CardDescription>
            </div>
            <div className="flex space-x-2">
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="outline" size="sm">
                    <Download className="h-4 w-4 mr-2" />
                    Exportar Relatório
                    <ChevronDown className="h-4 w-4 ml-2" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem onClick={() => exportVulnerabilityReport('json')}>
                    <FileText className="h-4 w-4 mr-2" />
                    Exportar como JSON
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => exportVulnerabilityReport('pdf')}>
                    <FileText className="h-4 w-4 mr-2" />
                    Exportar como PDF (Profissional)
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => exportVulnerabilityReport('txt')}>
                    <FileText className="h-4 w-4 mr-2" />
                    Exportar como TXT
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
              <Button 
                onClick={runVulnerabilityScan} 
                disabled={isScanning}
                size="sm"
              >
                {isScanning ? (
                  <RefreshCw className="h-4 w-4 mr-2 animate-spin" />
                ) : (
                  <Play className="h-4 w-4 mr-2" />
                )}
                {isScanning ? 'Escaneando...' : 'Executar Scan OWASP'}
              </Button>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          {isScanning && (
            <div className="mb-4">
              <div className="flex justify-between text-sm mb-2">
                <span>Progresso do Scan:</span>
                <span>{scanProgress.toFixed(1)}%</span>
              </div>
              <Progress value={scanProgress} />
            </div>
          )}

          {vulnerabilitySummary.lastScan && (
            <div className="mb-4 text-sm text-muted-foreground">
              Último scan: {new Date(vulnerabilitySummary.lastScan).toLocaleString('pt-BR')} 
              (duração: {(vulnerabilitySummary.scanDuration / 1000).toFixed(1)}s)
            </div>
          )}

          {/* Vulnerability Checks */}
          <div className="space-y-3">
            {vulnerabilityChecks.map((check) => (
              <div key={check.id} className="border rounded-lg p-4">
                <div className="flex items-start justify-between">
                  <div className="flex items-start space-x-3 flex-1">
                    <div className="flex items-center space-x-2">
                      {getCategoryIcon(check.category)}
                      {getStatusIcon(check.status)}
                    </div>
                    
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center space-x-2 mb-1">
                        <h4 className="font-medium">{check.name}</h4>
                        <Badge variant="outline" className="text-xs">
                          {check.owaspId}
                        </Badge>
                        <Badge className={`text-xs ${getStatusColor(check.status)}`}>
                          {check.status}
                        </Badge>
                        <Badge variant="outline" className={`text-xs ${
                          check.severity === 'critical' ? 'border-red-500 text-red-700' :
                          check.severity === 'high' ? 'border-orange-500 text-orange-700' :
                          check.severity === 'medium' ? 'border-yellow-500 text-yellow-700' :
                          'border-green-500 text-green-700'
                        }`}>
                          {check.severity}
                        </Badge>
                      </div>
                      
                      <p className="text-sm text-muted-foreground mb-2">
                        {check.description}
                      </p>
                      
                      {check.result && (
                        <div className="mb-2">
                          <p className="text-sm font-medium">Resultado:</p>
                          <p className="text-sm">{check.result}</p>
                        </div>
                      )}
                      
                      {check.recommendation && (
                        <div className="mb-2">
                          <p className="text-sm font-medium text-blue-600">Recomendação:</p>
                          <p className="text-sm text-blue-600">{check.recommendation}</p>
                        </div>
                      )}
                      
                      {check.realData && (
                        <div className="mb-2">
                          <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Dados da Análise:</p>
                          <pre className="text-xs text-gray-600 dark:text-gray-300 bg-gray-50 dark:bg-gray-800 p-2 rounded mt-1 overflow-x-auto">
                            {JSON.stringify(check.realData, null, 2)}
                          </pre>
                        </div>
                      )}
                      
                      {check.cweId && (
                        <div className="mb-2">
                          <p className="text-sm font-medium text-purple-600">CWE:</p>
                          <p className="text-sm text-purple-600">{check.cweId}</p>
                        </div>
                      )}
                      
                      {check.lastRun && (
                        <div className="flex items-center space-x-4 text-xs text-muted-foreground">
                          <span>Executado: {new Date(check.lastRun).toLocaleString('pt-BR')}</span>
                          {check.duration && (
                            <span>Duração: {check.duration}ms</span>
                          )}
                        </div>
                      )}
                    </div>
                  </div>
                  
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => runIndividualVulnerabilityCheck(check)}
                    disabled={check.status === 'running'}
                  >
                    {check.status === 'running' ? (
                      <RefreshCw className="h-3 w-3 animate-spin" />
                    ) : (
                      <Play className="h-3 w-3" />
                    )}
                  </Button>
                </div>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>

      {/* OWASP Info */}
      <Alert>
        <Shield className="h-4 w-4" />
        <AlertDescription>
          <strong>OWASP Top 10 2021:</strong> Este scanner verifica as 10 principais vulnerabilidades 
          de segurança em aplicações web conforme definido pela OWASP. Os resultados são baseados 
          em análises automatizadas e devem ser complementados com testes manuais de penetração.
        </AlertDescription>
      </Alert>

      {/* Critical Vulnerabilities Alert */}
      {vulnerabilitySummary.critical > 0 && (
        <Alert>
          <AlertTriangle className="h-4 w-4" />
          <AlertDescription>
            <strong>Vulnerabilidades Críticas Detectadas:</strong> {vulnerabilitySummary.critical} 
            vulnerabilidade(s) crítica(s) encontrada(s). Essas vulnerabilidades representam riscos 
            graves à segurança e devem ser corrigidas imediatamente.
          </AlertDescription>
        </Alert>
      )}
    </div>
  );
};