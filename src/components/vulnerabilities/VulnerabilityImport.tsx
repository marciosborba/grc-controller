import React, { useState, useCallback, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { Progress } from '@/components/ui/progress';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Separator } from '@/components/ui/separator';
import { 
  Upload, 
  FileText, 
  Download, 
  CheckCircle, 
  AlertTriangle, 
  X,
  Eye,
  Settings,
  Play,
  Pause,
  RotateCcw,
  ArrowRight,
  FileSpreadsheet,
  Code,
  Globe,
  Shield,
  Bug,
  Server,
  Cloud,
  Users,
  Target,
  ChevronDown,
  ArrowLeft,
  Info,
  RefreshCw,
  HelpCircle,
  Database,
  Monitor,
  Layers,
  Network,
  Smartphone,
  HardDrive,
  Cpu,
  GitBranch,
  Zap
} from 'lucide-react';
// import { useDropzone } from 'react-dropzone';
import { toast } from 'sonner';
import { useAuth } from '@/contexts/AuthContextOptimized';
import { useCurrentTenantId } from '@/contexts/TenantSelectorContext';
import { useNavigate } from 'react-router-dom';
// import VulnerabilityImportDropdown from './import/VulnerabilityImportDropdown';
// import { ImportSource } from './import/types/import';

// Types
interface ImportPreview {
  fileName: string;
  fileType: string;
  totalRecords: number;
  validRecords: number;
  invalidRecords: number;
  preview: any[];
  mapping: { [key: string]: string };
  errors: string[];
  warnings: string[];
}

interface ImportJob {
  id: string;
  fileName: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress: number;
  totalRecords: number;
  processedRecords: number;
  successfulImports: number;
  failedImports: number;
  errors: string[];
  startTime: Date;
  endTime?: Date;
  source: string;
  entityType: 'vulnerabilities' | 'assets' | 'applications';
}

interface ApiConfig {
  url: string;
  apiKey: string;
  username: string;
  password: string;
  additionalParams: string;
  testConnection: boolean;
}

// Entity Types Configuration
const ENTITY_TYPES = [
  {
    id: 'vulnerabilities',
    name: 'Vulnerabilidades',
    description: 'Importar vulnerabilidades de ferramentas de segurança',
    icon: Shield,
    color: 'bg-red-50 dark:bg-red-950/20 border-red-200 dark:border-red-800/30 hover:bg-red-100 dark:hover:bg-red-900/30',
    iconColor: 'text-red-600 dark:text-red-400'
  },
  {
    id: 'assets',
    name: 'Ativos (CMDB)',
    description: 'Importar ativos de infraestrutura e rede',
    icon: Server,
    color: 'bg-blue-50 dark:bg-blue-950/20 border-blue-200 dark:border-blue-800/30 hover:bg-blue-100 dark:hover:bg-blue-900/30',
    iconColor: 'text-blue-600 dark:text-blue-400'
  },
  {
    id: 'applications',
    name: 'Aplicações',
    description: 'Importar inventário de aplicações',
    icon: Layers,
    color: 'bg-green-50 dark:bg-green-950/20 border-green-200 dark:border-green-800/30 hover:bg-green-100 dark:hover:bg-green-900/30',
    iconColor: 'text-green-600 dark:text-green-400'
  }
];

// Import Tools by Entity Type
const IMPORT_TOOLS = {
  vulnerabilities: [
    { value: 'nessus', label: 'Nessus', icon: Shield, category: 'scanner', description: 'Tenable Nessus vulnerability scanner' },
    { value: 'openvas', label: 'OpenVAS', icon: Shield, category: 'scanner', description: 'Open source vulnerability scanner' },
    { value: 'qualys', label: 'Qualys VMDR', icon: Shield, category: 'scanner', description: 'Qualys vulnerability management' },
    { value: 'rapid7', label: 'Rapid7 Nexpose', icon: Shield, category: 'scanner', description: 'Rapid7 vulnerability management' },
    { value: 'burp', label: 'Burp Suite', icon: Bug, category: 'dast', description: 'Web application security testing' },
    { value: 'owasp_zap', label: 'OWASP ZAP', icon: Zap, category: 'dast', description: 'Web application security scanner' },
    { value: 'sonarqube', label: 'SonarQube', icon: Code, category: 'sast', description: 'Static code analysis' },
    { value: 'checkmarx', label: 'Checkmarx', icon: Code, category: 'sast', description: 'Static application security testing' },
    { value: 'veracode', label: 'Veracode', icon: Code, category: 'sast', description: 'Application security platform' },
    { value: 'aws_inspector', label: 'AWS Inspector', icon: Cloud, category: 'cloud', description: 'AWS security assessment' },
    { value: 'azure_defender', label: 'Azure Defender', icon: Cloud, category: 'cloud', description: 'Microsoft cloud security' },
    { value: 'gcp_security', label: 'GCP Security', icon: Cloud, category: 'cloud', description: 'Google Cloud security' }
  ],
  assets: [
    { value: 'servicenow', label: 'ServiceNow CMDB', icon: Database, category: 'cmdb', description: 'ServiceNow Configuration Management Database' },
    { value: 'lansweeper', label: 'Lansweeper', icon: Network, category: 'discovery', description: 'Network discovery and asset management' },
    { value: 'sccm', label: 'Microsoft SCCM', icon: Monitor, category: 'management', description: 'System Center Configuration Manager' },
    { value: 'aws_config', label: 'AWS Config', icon: Cloud, category: 'cloud', description: 'AWS resource configuration service' },
    { value: 'azure_resource', label: 'Azure Resource Graph', icon: Cloud, category: 'cloud', description: 'Azure resource management' },
    { value: 'gcp_asset', label: 'GCP Asset Inventory', icon: Cloud, category: 'cloud', description: 'Google Cloud asset inventory' },
    { value: 'active_directory', label: 'Active Directory', icon: Users, category: 'directory', description: 'Microsoft Active Directory' },
    { value: 'snmp', label: 'SNMP Discovery', icon: Network, category: 'discovery', description: 'Simple Network Management Protocol' }
  ],
  applications: [
    { value: 'servicenow_app', label: 'ServiceNow CMDB', icon: Database, category: 'cmdb', description: 'ServiceNow application inventory' },
    { value: 'jira', label: 'Atlassian Jira', icon: FileText, category: 'project', description: 'Jira projects as applications' },
    { value: 'github', label: 'GitHub', icon: GitBranch, category: 'repository', description: 'GitHub repositories' },
    { value: 'gitlab', label: 'GitLab', icon: GitBranch, category: 'repository', description: 'GitLab projects' },
    { value: 'azure_devops', label: 'Azure DevOps', icon: Cloud, category: 'devops', description: 'Azure DevOps projects' },
    { value: 'kubernetes', label: 'Kubernetes', icon: Database, category: 'container', description: 'Kubernetes applications' },
    { value: 'docker', label: 'Docker', icon: Database, category: 'container', description: 'Docker containers' },
    { value: 'aws_ecs', label: 'AWS ECS', icon: Cloud, category: 'cloud', description: 'AWS Elastic Container Service' }
  ]
};

// Field Mappings by Entity Type
const FIELD_MAPPINGS = {
  vulnerabilities: {
    title: 'Title',
    description: 'Description',
    severity: 'Severity',
    cvss_score: 'CVSS Score',
    cve_id: 'CVE ID',
    asset_name: 'Asset Name',
    asset_ip: 'Asset IP',
    source_tool: 'Source Tool',
  },
  assets: {
    name: 'Name',
    type: 'Type',
    ip_address: 'IP Address',
    os: 'Operating System',
    location: 'Location',
    owner: 'Owner',
    status: 'Status',
    serial_number: 'Serial Number',
  },
  applications: {
    name: 'Name',
    type: 'Type',
    url: 'URL',
    technology: 'Technology',
    owner: 'Owner',
    status: 'Status',
    environment: 'Environment',
    version: 'Version',
  }
};



export default function VulnerabilityImport() {
  const { user } = useAuth();
  const effectiveTenantId = useCurrentTenantId();
  const navigate = useNavigate();
  
  // State management
  const [selectedEntityType, setSelectedEntityType] = useState<'vulnerabilities' | 'assets' | 'applications'>('vulnerabilities');
  const [selectedTool, setSelectedTool] = useState('');
  const [importMethod, setImportMethod] = useState<'file' | 'api'>('file');
  const [preview, setPreview] = useState<ImportPreview | null>(null);
  const [importJobs, setImportJobs] = useState<ImportJob[]>([]);
  const [isProcessing, setIsProcessing] = useState(false);
  const [fieldMapping, setFieldMapping] = useState(FIELD_MAPPINGS.vulnerabilities);
  const [showAdvancedOptions, setShowAdvancedOptions] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<'idle' | 'testing' | 'success' | 'error'>('idle');
  
  // API Configuration
  const [apiConfig, setApiConfig] = useState<ApiConfig>({
    url: '',
    apiKey: '',
    username: '',
    password: '',
    additionalParams: '',
    testConnection: false
  });

  // Effects
  useEffect(() => {
    // Load saved import jobs from localStorage
    const savedJobs = localStorage.getItem('import-center-jobs');
    if (savedJobs) {
      try {
        const jobs = JSON.parse(savedJobs).map((job: any) => ({
          ...job,
          startTime: new Date(job.startTime),
          endTime: job.endTime ? new Date(job.endTime) : undefined
        }));
        setImportJobs(jobs);
      } catch (error) {
        console.error('Error loading import jobs:', error);
      }
    }
  }, []);

  useEffect(() => {
    // Save import jobs to localStorage
    localStorage.setItem('import-center-jobs', JSON.stringify(importJobs));
  }, [importJobs]);

  useEffect(() => {
    // Update field mapping when entity type changes
    setFieldMapping(FIELD_MAPPINGS[selectedEntityType]);
    setSelectedTool('');
    setPreview(null);
  }, [selectedEntityType]);

  // Handlers
  const handleImportSelect = (source: any) => {
    console.log('Fonte de importação selecionada:', source);
    setSelectedTool(source.type);
    
    // Set import method based on source type
    if (source.type.includes('_api') || source.category === 'api') {
      setImportMethod('api');
    } else {
      setImportMethod('file');
    }
    
    toast.success(`Fonte selecionada: ${source.name}`);
  };



  const handleEntityTypeChange = (entityType: 'vulnerabilities' | 'assets' | 'applications') => {
    setSelectedEntityType(entityType);
    toast.info(`Modo alterado para: ${ENTITY_TYPES.find(e => e.id === entityType)?.name}`);
  };

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    // Validate file type
    const allowedTypes = ['.csv', '.xml', '.json', '.txt', '.nessus'];
    const fileExtension = '.' + file.name.split('.').pop()?.toLowerCase();
    
    if (!allowedTypes.includes(fileExtension)) {
      toast.error('Tipo de arquivo não suportado. Use CSV, XML, JSON, TXT ou .nessus');
      return;
    }

    // Validate file size (50MB limit)
    if (file.size > 50 * 1024 * 1024) {
      toast.error('Arquivo muito grande. Limite de 50MB.');
      return;
    }

    // Read and preview file
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const content = e.target?.result as string;
        const previewData = parseFileContent(content, fileExtension, file.name);
        setPreview(previewData);
        toast.success(`Arquivo processado: ${previewData.validRecords} registros válidos encontrados`);
      } catch (error) {
        toast.error('Erro ao processar arquivo: ' + (error as Error).message);
      }
    };
    reader.readAsText(file);
  };

  const parseFileContent = (content: string, fileType: string, fileName: string): ImportPreview => {
    let data: any[] = [];
    let errors: string[] = [];
    let warnings: string[] = [];

    try {
      switch (fileType) {
        case '.csv':
          data = parseCSV(content);
          break;
        case '.xml':
        case '.nessus':
          data = parseXML(content);
          break;
        case '.json':
          data = parseJSON(content);
          break;
        case '.txt':
          data = parseTXT(content);
          break;
        default:
          throw new Error('Formato de arquivo não suportado');
      }
    } catch (error) {
      errors.push('Erro ao analisar arquivo: ' + (error as Error).message);
    }

    // Validate records based on entity type
    const validRecords = data.filter(record => validateRecord(record));
    const invalidRecords = data.length - validRecords.length;

    // Generate warnings
    if (invalidRecords > 0) {
      warnings.push(`${invalidRecords} registros não possuem campos obrigatórios`);
    }
    
    if (data.length > 1000) {
      warnings.push('Arquivo grande detectado. A importação pode demorar alguns minutos.');
    }

    return {
      fileName,
      fileType,
      totalRecords: data.length,
      validRecords: validRecords.length,
      invalidRecords,
      preview: data.slice(0, 10),
      mapping: fieldMapping,
      errors,
      warnings
    };
  };

  const parseCSV = (content: string): any[] => {
    const lines = content.split('\n').filter(line => line.trim());
    if (lines.length < 2) throw new Error('Arquivo CSV deve ter pelo menos um cabeçalho e uma linha de dados');
    
    const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
    const data = [];
    
    for (let i = 1; i < lines.length; i++) {
      const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
      const record: any = {};
      headers.forEach((header, index) => {
        record[header] = values[index] || '';
      });
      data.push(record);
    }
    
    return data;
  };

  const parseJSON = (content: string): any[] => {
    const parsed = JSON.parse(content);
    if (Array.isArray(parsed)) {
      return parsed;
    } else if (parsed[selectedEntityType] && Array.isArray(parsed[selectedEntityType])) {
      return parsed[selectedEntityType];
    } else if (parsed.data && Array.isArray(parsed.data)) {
      return parsed.data;
    } else {
      return [parsed];
    }
  };

  const parseXML = (content: string): any[] => {
    const data: any[] = [];
    const entityRegex = new RegExp(`<${selectedEntityType.slice(0, -1)}[^>]*>(.*?)<\\/${selectedEntityType.slice(0, -1)}>`, 'gs');
    let match;
    
    while ((match = entityRegex.exec(content)) !== null) {
      const entityContent = match[1];
      const record: any = {};
      
      // Extract common fields based on entity type
      Object.keys(fieldMapping).forEach(field => {
        const fieldRegex = new RegExp(`<${field}[^>]*>(.*?)<\\/${field}>`, 's');
        const fieldMatch = entityContent.match(fieldRegex);
        if (fieldMatch) record[field] = fieldMatch[1].trim();
      });
      
      data.push(record);
    }
    
    return data;
  };

  const parseTXT = (content: string): any[] => {
    const lines = content.split('\n').filter(line => line.trim());
    return lines.map((line, index) => {
      const record: any = {};
      
      // Create basic record based on entity type
      switch (selectedEntityType) {
        case 'vulnerabilities':
          record.title = line.trim();
          record.description = `Vulnerabilidade importada da linha ${index + 1}`;
          record.severity = 'Medium';
          break;
        case 'assets':
          record.name = line.trim();
          record.type = 'Unknown';
          record.status = 'Active';
          break;
        case 'applications':
          record.name = line.trim();
          record.type = 'Application';
          record.status = 'Active';
          break;
      }
      
      record.source_tool = selectedTool || 'Manual';
      return record;
    });
  };

  const validateRecord = (record: any): boolean => {
    // Validation rules based on entity type
    switch (selectedEntityType) {
      case 'vulnerabilities':
        return record.title && record.severity;
      case 'assets':
        return record.name && record.type;
      case 'applications':
        return record.name && record.type;
      default:
        return false;
    }
  };

  const handleImport = async () => {
    if (!preview || !effectiveTenantId || !user) {
      toast.error('Dados insuficientes para importação');
      return;
    }

    if (preview.validRecords === 0) {
      toast.error('Nenhum registro válido encontrado para importação');
      return;
    }

    setIsProcessing(true);
    
    const jobId = Date.now().toString();
    const newJob: ImportJob = {
      id: jobId,
      fileName: preview.fileName,
      status: 'processing',
      progress: 0,
      totalRecords: preview.validRecords,
      processedRecords: 0,
      successfulImports: 0,
      failedImports: 0,
      errors: [],
      startTime: new Date(),
      source: selectedTool || 'file',
      entityType: selectedEntityType
    };

    setImportJobs(prev => [newJob, ...prev]);

    try {
      // Simulate import process with realistic timing
      for (let i = 0; i < preview.validRecords; i++) {
        await new Promise(resolve => setTimeout(resolve, 50));
        
        const progress = Math.round(((i + 1) / preview.validRecords) * 100);
        
        setImportJobs(prev => prev.map(job => 
          job.id === jobId 
            ? { 
                ...job, 
                progress, 
                processedRecords: i + 1,
                successfulImports: i + 1
              }
            : job
        ));
      }

      // Complete the job
      setImportJobs(prev => prev.map(job => 
        job.id === jobId 
          ? { 
              ...job, 
              status: 'completed',
              endTime: new Date()
            }
          : job
      ));

      const entityName = ENTITY_TYPES.find(e => e.id === selectedEntityType)?.name.toLowerCase();
      toast.success(`Importação concluída: ${preview.validRecords} ${entityName} importadas`);
      setPreview(null);
      
      // Redirect based on entity type
      setTimeout(() => {
        switch (selectedEntityType) {
          case 'vulnerabilities':
            navigate('/vulnerabilities/list');
            break;
          case 'assets':
            navigate('/vulnerabilities/cmdb');
            break;
          case 'applications':
            navigate('/vulnerabilities/applications');
            break;
        }
      }, 2000);
      
    } catch (error) {
      setImportJobs(prev => prev.map(job => 
        job.id === jobId 
          ? { 
              ...job, 
              status: 'failed',
              errors: [(error as Error).message],
              endTime: new Date()
            }
          : job
      ));
      toast.error('Erro na importação: ' + (error as Error).message);
    } finally {
      setIsProcessing(false);
    }
  };

  const handleApiImport = async () => {
    if (!apiConfig.url || !selectedTool) {
      toast.error('Configure a URL da API e selecione a ferramenta');
      return;
    }

    setIsProcessing(true);
    
    try {
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      const jobId = Date.now().toString();
      const newJob: ImportJob = {
        id: jobId,
        fileName: `API Import - ${selectedTool}`,
        status: 'completed',
        progress: 100,
        totalRecords: 25,
        processedRecords: 25,
        successfulImports: 23,
        failedImports: 2,
        errors: [],
        startTime: new Date(),
        endTime: new Date(),
        source: selectedTool,
        entityType: selectedEntityType
      };

      setImportJobs(prev => [newJob, ...prev]);
      const entityName = ENTITY_TYPES.find(e => e.id === selectedEntityType)?.name.toLowerCase();
      toast.success(`Importação via API concluída: 23 ${entityName} importadas`);
      
      // Reset API config
      setApiConfig({
        url: '',
        apiKey: '',
        username: '',
        password: '',
        additionalParams: '',
        testConnection: false
      });
      
    } catch (error) {
      toast.error('Erro na importação via API: ' + (error as Error).message);
    } finally {
      setIsProcessing(false);
    }
  };

  const testApiConnection = async () => {
    if (!apiConfig.url) {
      toast.error('Informe a URL da API');
      return;
    }

    setConnectionStatus('testing');
    
    try {
      await new Promise(resolve => setTimeout(resolve, 1500));
      setConnectionStatus('success');
      toast.success('Conexão testada com sucesso');
    } catch (error) {
      setConnectionStatus('error');
      toast.error('Falha na conexão com a API');
    }
  };

  const getToolIcon = (toolValue: string) => {
    const allTools = [...IMPORT_TOOLS.vulnerabilities, ...IMPORT_TOOLS.assets, ...IMPORT_TOOLS.applications];
    const tool = allTools.find(t => t.value === toolValue);
    const IconComponent = tool?.icon || FileText;
    return <IconComponent className="h-4 w-4" />;
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'completed': return 'bg-green-100 dark:bg-green-950/30 text-green-800 dark:text-green-300 border-green-200 dark:border-green-800/50';
      case 'failed': return 'bg-red-100 dark:bg-red-950/30 text-red-800 dark:text-red-300 border-red-200 dark:border-red-800/50';
      case 'processing': return 'bg-blue-100 dark:bg-blue-950/30 text-blue-800 dark:text-blue-300 border-blue-200 dark:border-blue-800/50';
      default: return 'bg-gray-100 dark:bg-gray-950/30 text-gray-800 dark:text-gray-300 border-gray-200 dark:border-gray-800/50';
    }
  };

  const getEntityIcon = (entityType: string) => {
    const entity = ENTITY_TYPES.find(e => e.id === entityType);
    const IconComponent = entity?.icon || FileText;
    return <IconComponent className="h-4 w-4" />;
  };

  const clearImportHistory = () => {
    setImportJobs([]);
    localStorage.removeItem('import-center-jobs');
    toast.info('Histórico de importações limpo');
  };

  const currentTools = IMPORT_TOOLS[selectedEntityType] || [];

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
        <div className="flex items-center gap-4">
          <Button variant="ghost" onClick={() => navigate('/vulnerabilities')}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Voltar
          </Button>
          <div>
            <h1 className="text-3xl font-bold flex items-center gap-2">
              <Upload className="h-8 w-8 text-primary" />
              Central de Importações
            </h1>
            <p className="text-muted-foreground">
              Importe vulnerabilidades, ativos e aplicações de forma centralizada
            </p>
          </div>
        </div>
        <div className="flex gap-2">
          <Button 
            variant="outline" 
            onClick={() => {
              switch (selectedEntityType) {
                case 'vulnerabilities':
                  navigate('/vulnerabilities/list');
                  break;
                case 'assets':
                  navigate('/vulnerabilities/cmdb');
                  break;
                case 'applications':
                  navigate('/vulnerabilities/applications');
                  break;
              }
            }}
          >
            <Eye className="h-4 w-4 mr-2" />
            Ver Lista
          </Button>
        </div>
      </div>

      {/* Entity Type Selection */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Target className="h-5 w-5" />
            Tipo de Entidade
          </CardTitle>
          <CardDescription>
            Selecione o tipo de dados que deseja importar
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {ENTITY_TYPES.map((entityType) => (
              <Card 
                key={entityType.id}
                className={`cursor-pointer transition-all hover:shadow-md ${
                  selectedEntityType === entityType.id 
                    ? 'ring-2 ring-primary bg-primary/5 border-primary/20' 
                    : entityType.color
                }`}
                onClick={() => handleEntityTypeChange(entityType.id as any)}
              >
                <CardContent className="p-6 text-center">
                  <entityType.icon className={`h-8 w-8 mx-auto mb-3 ${
                    selectedEntityType === entityType.id ? 'text-primary' : entityType.iconColor
                  }`} />
                  <h3 className={`font-semibold mb-1 ${
                    selectedEntityType === entityType.id ? 'text-primary' : ''
                  }`}>{entityType.name}</h3>
                  <p className="text-sm text-muted-foreground">{entityType.description}</p>
                </CardContent>
              </Card>
            ))}
          </div>
        </CardContent>
      </Card>



      {/* Main Import Interface */}
      <Tabs value={importMethod} onValueChange={(value) => setImportMethod(value as 'file' | 'api')}>
        <TabsList className="grid w-full grid-cols-2">
          <TabsTrigger value="file" className="flex items-center gap-2">
            <FileText className="h-4 w-4" />
            Importação por Arquivo
          </TabsTrigger>
          <TabsTrigger value="api" className="flex items-center gap-2">
            <Globe className="h-4 w-4" />
            Importação via API
          </TabsTrigger>
        </TabsList>

        <TabsContent value="file" className="space-y-6">
          {/* Tool Selection */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center justify-between">
                <span>Selecionar Ferramenta - {ENTITY_TYPES.find(e => e.id === selectedEntityType)?.name}</span>
                {selectedTool && (
                  <Badge variant="outline" className="flex items-center gap-1">
                    {getToolIcon(selectedTool)}
                    {currentTools.find(t => t.value === selectedTool)?.label || selectedTool}
                  </Badge>
                )}
              </CardTitle>
              <CardDescription>
                Escolha a ferramenta de origem para otimizar o processamento
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                {currentTools.map((tool) => (
                  <Card 
                    key={tool.value}
                    className={`cursor-pointer transition-all hover:shadow-md ${
                      selectedTool === tool.value 
                        ? 'ring-2 ring-primary bg-primary/5 border-primary/20' 
                        : 'hover:bg-muted/50'
                    }`}
                    onClick={() => setSelectedTool(tool.value)}
                  >
                    <CardContent className="p-4 text-center">
                      <tool.icon className={`h-8 w-8 mx-auto mb-2 ${
                        selectedTool === tool.value ? 'text-primary' : 'text-muted-foreground'
                      }`} />
                      <p className={`text-sm font-medium mb-1 ${
                        selectedTool === tool.value ? 'text-primary' : ''
                      }`}>{tool.label}</p>
                      <p className="text-xs text-muted-foreground">{tool.description}</p>
                    </CardContent>
                  </Card>
                ))}
              </div>
            </CardContent>
          </Card>

          {/* File Upload */}
          <Card>
            <CardHeader>
              <CardTitle>Upload de Arquivo</CardTitle>
              <CardDescription>
                Arraste e solte ou clique para selecionar arquivos (CSV, XML, JSON, TXT, .nessus)
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="border-2 border-dashed rounded-lg p-8 text-center transition-all border-muted-foreground/25 hover:border-primary/50 hover:bg-muted/25 dark:hover:bg-muted/10">
                <Upload className="h-12 w-12 mx-auto mb-4 text-muted-foreground" />
                <div>
                  <p className="text-lg font-medium mb-2 text-foreground">
                    Selecione um arquivo para importar
                  </p>
                  <p className="text-sm text-muted-foreground mb-4">
                    Suporta CSV, XML, JSON, TXT e .nessus (máx. 50MB)
                  </p>
                  <div className="relative">
                    <input
                      type="file"
                      accept=".csv,.xml,.json,.txt,.nessus"
                      onChange={handleFileUpload}
                      disabled={isProcessing}
                      className="absolute inset-0 w-full h-full opacity-0 cursor-pointer disabled:cursor-not-allowed"
                    />
                    <Button variant="outline" disabled={isProcessing}>
                      <FileText className="h-4 w-4 mr-2" />
                      Selecionar Arquivo
                    </Button>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Preview */}
          {preview && (
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center justify-between">
                  <span>Preview da Importação</span>
                  <Button variant="outline" size="sm" onClick={() => setPreview(null)}>
                    <X className="h-4 w-4" />
                  </Button>
                </CardTitle>
                <CardDescription>
                  Arquivo: {preview.fileName} ({preview.fileType}) - {ENTITY_TYPES.find(e => e.id === selectedEntityType)?.name}
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-6">
                {/* Summary */}
                <div className="grid grid-cols-3 gap-4">
                  <div className="text-center p-4 bg-muted/50 rounded-lg">
                    <p className="text-2xl font-bold">{preview.totalRecords}</p>
                    <p className="text-sm text-muted-foreground">Total de Registros</p>
                  </div>
                  <div className="text-center p-4 bg-green-50 dark:bg-green-950/20 border border-green-200 dark:border-green-800/30 rounded-lg">
                    <p className="text-2xl font-bold text-green-600 dark:text-green-400">{preview.validRecords}</p>
                    <p className="text-sm text-muted-foreground">Registros Válidos</p>
                  </div>
                  <div className="text-center p-4 bg-red-50 dark:bg-red-950/20 border border-red-200 dark:border-red-800/30 rounded-lg">
                    <p className="text-2xl font-bold text-red-600 dark:text-red-400">{preview.invalidRecords}</p>
                    <p className="text-sm text-muted-foreground">Registros Inválidos</p>
                  </div>
                </div>

                {/* Errors and Warnings */}
                {(preview.errors.length > 0 || preview.warnings.length > 0) && (
                  <div className="space-y-3">
                    {preview.errors.length > 0 && (
                      <Alert>
                        <AlertTriangle className="h-4 w-4" />
                        <AlertDescription>
                          <div className="space-y-1">
                            <p className="font-medium">Erros encontrados:</p>
                            {preview.errors.map((error, index) => (
                              <p key={index} className="text-sm">• {error}</p>
                            ))}
                          </div>
                        </AlertDescription>
                      </Alert>
                    )}
                    
                    {preview.warnings.length > 0 && (
                      <Alert>
                        <Info className="h-4 w-4" />
                        <AlertDescription>
                          <div className="space-y-1">
                            <p className="font-medium">Avisos:</p>
                            {preview.warnings.map((warning, index) => (
                              <p key={index} className="text-sm">• {warning}</p>
                            ))}
                          </div>
                        </AlertDescription>
                      </Alert>
                    )}
                  </div>
                )}

                {/* Advanced Options Toggle */}
                <div className="flex items-center justify-between">
                  <h4 className="font-medium">Opções Avançadas</h4>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setShowAdvancedOptions(!showAdvancedOptions)}
                  >
                    {showAdvancedOptions ? 'Ocultar' : 'Mostrar'}
                    <ChevronDown className={`h-4 w-4 ml-1 transition-transform ${
                      showAdvancedOptions ? 'rotate-180' : ''
                    }`} />
                  </Button>
                </div>

                {/* Field Mapping - Advanced */}
                {showAdvancedOptions && (
                  <div className="space-y-4 p-4 bg-muted/25 dark:bg-muted/10 border border-muted-foreground/10 rounded-lg">
                    <h4 className="font-medium">Mapeamento de Campos</h4>
                    <div className="grid grid-cols-2 gap-4">
                      {Object.entries(fieldMapping).map(([targetField, sourceField]) => (
                        <div key={targetField} className="space-y-2">
                          <Label>{targetField.replace('_', ' ').toUpperCase()}</Label>
                          <Select 
                            value={sourceField} 
                            onValueChange={(value) => 
                              setFieldMapping(prev => ({ ...prev, [targetField]: value }))
                            }
                          >
                            <SelectTrigger>
                              <SelectValue />
                            </SelectTrigger>
                            <SelectContent>
                              {preview.preview.length > 0 && 
                                Object.keys(preview.preview[0]).map(field => (
                                  <SelectItem key={field} value={field}>{field}</SelectItem>
                                ))
                              }
                            </SelectContent>
                          </Select>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {/* Preview Table */}
                <div>
                  <h4 className="font-medium mb-3">Preview dos Dados (primeiros 5 registros)</h4>
                  <div className="border rounded-lg overflow-hidden">
                    <Table>
                      <TableHeader>
                        <TableRow>
                          {preview.preview.length > 0 && 
                            Object.keys(preview.preview[0]).slice(0, 6).map(field => (
                              <TableHead key={field}>{field}</TableHead>
                            ))
                          }
                        </TableRow>
                      </TableHeader>
                      <TableBody>
                        {preview.preview.slice(0, 5).map((record, index) => (
                          <TableRow key={index}>
                            {Object.values(record).slice(0, 6).map((value: any, cellIndex) => (
                              <TableCell key={cellIndex} className="max-w-xs truncate">
                                {String(value)}
                              </TableCell>
                            ))}
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  </div>
                </div>

                {/* Import Actions */}
                <div className="flex items-center justify-between pt-4 border-t">
                  <div className="text-sm text-muted-foreground">
                    {preview.validRecords > 0 ? (
                      <span className="text-green-600 dark:text-green-400">
                        ✓ Pronto para importar {preview.validRecords} {ENTITY_TYPES.find(e => e.id === selectedEntityType)?.name.toLowerCase()}
                      </span>
                    ) : (
                      <span className="text-red-600 dark:text-red-400">
                        ✗ Nenhum registro válido encontrado
                      </span>
                    )}
                  </div>
                  <div className="flex gap-2">
                    <Button variant="outline" onClick={() => setPreview(null)}>
                      Cancelar
                    </Button>
                    <Button 
                      onClick={handleImport} 
                      disabled={isProcessing || preview.validRecords === 0}
                      className="min-w-32"
                    >
                      {isProcessing ? (
                        <>
                          <RefreshCw className="h-4 w-4 mr-2 animate-spin" />
                          Importando...
                        </>
                      ) : (
                        <>
                          <Play className="h-4 w-4 mr-2" />
                          Importar {preview.validRecords} {ENTITY_TYPES.find(e => e.id === selectedEntityType)?.name}
                        </>
                      )}
                    </Button>
                  </div>
                </div>
              </CardContent>
            </Card>
          )}
        </TabsContent>

        <TabsContent value="api" className="space-y-6">
          {/* API Configuration */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center justify-between">
                <span>Configuração da API - {ENTITY_TYPES.find(e => e.id === selectedEntityType)?.name}</span>
                {selectedTool && (
                  <Badge variant="outline" className="flex items-center gap-1">
                    {getToolIcon(selectedTool)}
                    {currentTools.find(t => t.value === selectedTool)?.label || selectedTool}
                  </Badge>
                )}
              </CardTitle>
              <CardDescription>
                Configure a conexão com a API da ferramenta selecionada
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
              {/* Tool Selection for API */}
              <div className="space-y-2">
                <Label>Ferramenta</Label>
                <Select value={selectedTool} onValueChange={setSelectedTool}>
                  <SelectTrigger>
                    <SelectValue placeholder="Selecione a ferramenta" />
                  </SelectTrigger>
                  <SelectContent>
                    {currentTools.map(tool => (
                      <SelectItem key={tool.value} value={tool.value}>
                        <div className="flex items-center gap-2">
                          <tool.icon className="h-4 w-4" />
                          <span>{tool.label}</span>
                        </div>
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              <Separator />

              {/* Connection Configuration */}
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label>URL da API *</Label>
                  <Input 
                    placeholder="https://api.exemplo.com"
                    value={apiConfig.url}
                    onChange={(e) => setApiConfig(prev => ({ ...prev, url: e.target.value }))}
                  />
                </div>

                <div className="space-y-2">
                  <Label>API Key *</Label>
                  <Input 
                    type="password"
                    placeholder="Sua chave de API"
                    value={apiConfig.apiKey}
                    onChange={(e) => setApiConfig(prev => ({ ...prev, apiKey: e.target.value }))}
                  />
                </div>

                <div className="space-y-2">
                  <Label>Usuário (opcional)</Label>
                  <Input 
                    placeholder="Nome de usuário"
                    value={apiConfig.username}
                    onChange={(e) => setApiConfig(prev => ({ ...prev, username: e.target.value }))}
                  />
                </div>

                <div className="space-y-2">
                  <Label>Senha (opcional)</Label>
                  <Input 
                    type="password"
                    placeholder="Senha"
                    value={apiConfig.password}
                    onChange={(e) => setApiConfig(prev => ({ ...prev, password: e.target.value }))}
                  />
                </div>
              </div>

              {/* Advanced Parameters */}
              <div className="space-y-2">
                <Label>Parâmetros Adicionais (JSON)</Label>
                <Textarea 
                  placeholder='{"filters": {"type": "active"}, "limit": 1000}'
                  value={apiConfig.additionalParams}
                  onChange={(e) => setApiConfig(prev => ({ ...prev, additionalParams: e.target.value }))}
                  rows={3}
                />
              </div>

              {/* Connection Test */}
              <div className="flex items-center justify-between p-4 bg-muted/25 dark:bg-muted/10 border border-muted-foreground/10 rounded-lg">
                <div className="flex items-center gap-2">
                  <div className={`w-3 h-3 rounded-full ${
                    connectionStatus === 'success' ? 'bg-green-500' :
                    connectionStatus === 'error' ? 'bg-red-500' :
                    connectionStatus === 'testing' ? 'bg-yellow-500 animate-pulse' :
                    'bg-gray-300'
                  }`} />
                  <span className="text-sm">
                    {connectionStatus === 'success' ? 'Conexão OK' :
                     connectionStatus === 'error' ? 'Falha na conexão' :
                     connectionStatus === 'testing' ? 'Testando...' :
                     'Não testado'}
                  </span>
                </div>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={testApiConnection}
                  disabled={!apiConfig.url || connectionStatus === 'testing'}
                >
                  {connectionStatus === 'testing' ? (
                    <RefreshCw className="h-4 w-4 mr-2 animate-spin" />
                  ) : (
                    <Globe className="h-4 w-4 mr-2" />
                  )}
                  Testar Conexão
                </Button>
              </div>

              {/* Import Actions */}
              <div className="flex items-center justify-between pt-4 border-t">
                <div className="text-sm text-muted-foreground flex items-center gap-2">
                  <HelpCircle className="h-4 w-4" />
                  <span>Use o botão "Importar" no header para configuração guiada</span>
                </div>
                <Button 
                  onClick={handleApiImport} 
                  disabled={isProcessing || !apiConfig.url || !selectedTool}
                >
                  {isProcessing ? (
                    <>
                      <RefreshCw className="h-4 w-4 mr-2 animate-spin" />
                      Conectando...
                    </>
                  ) : (
                    <>
                      <Globe className="h-4 w-4 mr-2" />
                      Importar via API
                    </>
                  )}
                </Button>
              </div>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>

      {/* Import Jobs History */}
      {importJobs.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center justify-between">
              <span>Histórico de Importações</span>
              <Button variant="outline" size="sm" onClick={clearImportHistory}>
                <RotateCcw className="h-4 w-4 mr-2" />
                Limpar Histórico
              </Button>
            </CardTitle>
            <CardDescription>
              Acompanhe o progresso e resultados das importações de todas as entidades
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              {importJobs.slice(0, 5).map((job) => (
                <div key={job.id} className="border rounded-lg p-4 space-y-3">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-3">
                      <div className="flex items-center gap-2">
                        {getEntityIcon(job.entityType)}
                        {getToolIcon(job.source)}
                        <span className="font-medium">{job.fileName}</span>
                      </div>
                      <Badge className={getStatusColor(job.status)}>
                        {job.status === 'completed' ? 'Concluído' :
                         job.status === 'failed' ? 'Falhou' :
                         job.status === 'processing' ? 'Processando' : 'Pendente'}
                      </Badge>
                      <Badge variant="outline">
                        {ENTITY_TYPES.find(e => e.id === job.entityType)?.name}
                      </Badge>
                    </div>
                    <span className="text-sm text-muted-foreground">
                      {job.startTime.toLocaleString()}
                    </span>
                  </div>
                  
                  {job.status === 'processing' && (
                    <div className="space-y-2">
                      <Progress value={job.progress} className="h-2" />
                      <p className="text-sm text-muted-foreground">
                        {job.processedRecords} de {job.totalRecords} registros processados ({job.progress}%)
                      </p>
                    </div>
                  )}
                  
                  {job.status === 'completed' && (
                    <div className="flex items-center gap-6 text-sm">
                      <span className="text-green-600 dark:text-green-400 flex items-center gap-1">
                        <CheckCircle className="h-4 w-4" />
                        {job.successfulImports} importados
                      </span>
                      {job.failedImports > 0 && (
                        <span className="text-red-600 dark:text-red-400 flex items-center gap-1">
                          <X className="h-4 w-4" />
                          {job.failedImports} falharam
                        </span>
                      )}
                      <span className="text-muted-foreground">
                        Concluído em {job.endTime?.toLocaleString()}
                      </span>
                    </div>
                  )}
                  
                  {job.status === 'failed' && job.errors.length > 0 && (
                    <Alert>
                      <AlertTriangle className="h-4 w-4" />
                      <AlertDescription>
                        {job.errors.join(', ')}
                      </AlertDescription>
                    </Alert>
                  )}
                </div>
              ))}
              
              {importJobs.length > 5 && (
                <div className="text-center">
                  <Button variant="ghost" size="sm">
                    Ver todos ({importJobs.length} importações)
                  </Button>
                </div>
              )}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}