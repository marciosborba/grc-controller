import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useCurrentTenantId } from '@/contexts/TenantSelectorContext';
import { VulnerabilityMetrics } from '../types/vulnerability';

export interface DashboardMetrics {
    riskScore: number;
    riskLevel: 'Critical' | 'High' | 'Medium' | 'Low' | 'Safe';
    totalVulnerabilities: number;
    totalApplications: number;
    totalAssets: number;
    vulnerabilityMetrics: VulnerabilityMetrics | null;
    loading: boolean;
}

export const useVulnerabilityDashboard = () => {
    const tenantId = useCurrentTenantId();
    const [metrics, setMetrics] = useState<DashboardMetrics>({
        riskScore: 0,
        riskLevel: 'Safe',
        totalVulnerabilities: 0,
        totalApplications: 0,
        totalAssets: 0,
        vulnerabilityMetrics: null,
        loading: true
    });

    const loadDashboardData = useCallback(async () => {
        if (!tenantId) return;

        setMetrics(prev => ({ ...prev, loading: true }));

        try {
            // 1. Fetch Vulnerability Metrics (reusing the logic from useVulnerabilities roughly)
            const { data: vulnData, error: vulnError } = await supabase
                .from('vulnerabilities')
                .select('severity, status')
                .eq('tenant_id', tenantId);

            if (vulnError) throw vulnError;

            const vulns = vulnData || [];
            const totalVulns = vulns.length;

            const criticalCount = vulns.filter(v => v.severity === 'Critical' && v.status === 'Open').length;
            const highCount = vulns.filter(v => v.severity === 'High' && v.status === 'Open').length;
            const mediumCount = vulns.filter(v => v.severity === 'Medium' && v.status === 'Open').length;
            const lowCount = vulns.filter(v => v.severity === 'Low' && v.status === 'Open').length;

            // 2. Fetch Applications and Assets from 'sistemas'
            let appCount = 0;
            let assetCount = 0;

            try {
                // Fetch ALL columns to maximize compatibility
                const { data: sistemas, error: sistemasError } = await supabase
                    .from('sistemas')
                    .select('*')
                    .eq('tenant_id', tenantId);

                if (sistemasError) throw sistemasError;

                // Debug log (if you could see it)
                console.log('Dashboard fetched systems:', sistemas?.length, sistemas);

                if (sistemas) {
                    // EXCLUSION Logic: Count everything as App unless it is definitely Infrastructure
                    const infraTypes = ['Server', 'Workstation', 'Network Device', 'Firewall', 'Switch', 'Router', 'Printer', 'IoT', 'Servidor', 'Estação de Trabalho'];

                    appCount = sistemas.filter(s => {
                        const type = String(s.tipo || '');
                        // If type is empty, it's likely an app (legacy data)
                        if (!type) return true;
                        // If it's NOT in the infra list, it's an app
                        return !infraTypes.some(t => type.toLowerCase().includes(t.toLowerCase()));
                    }).length;

                    // Asset count is the rest
                    assetCount = sistemas.length - appCount;
                }
            } catch (e) {
                console.error('Error fetching systems:', e);
            }


            // 4. Calculate Risk Score
            // Simple formula: Critical*10 + High*5 + Medium*2 + Low*1
            let score = 0;
            if (totalVulns > 0) {
                score = (criticalCount * 10) + (highCount * 5) + (mediumCount * 2) + lowCount;
            }

            let level: 'Critical' | 'High' | 'Medium' | 'Low' | 'Safe' = 'Safe';
            if (criticalCount > 0 || score > 50) level = 'Critical';
            else if (highCount > 0 || score > 20) level = 'High';
            else if (mediumCount > 0 || score > 10) level = 'Medium';
            else if (lowCount > 0) level = 'Low';

            setMetrics({
                riskScore: score,
                riskLevel: level,
                totalVulnerabilities: totalVulns,
                totalApplications: appCount,
                totalAssets: assetCount,
                vulnerabilityMetrics: {
                    // Minimal metrics needed for other parts if any
                    total_vulnerabilities: totalVulns,
                    critical_open: criticalCount,
                    high_open: highCount,
                    by_severity: {
                        Critical: vulns.filter(v => v.severity === 'Critical').length,
                        High: vulns.filter(v => v.severity === 'High').length,
                        Medium: vulns.filter(v => v.severity === 'Medium').length,
                        Low: vulns.filter(v => v.severity === 'Low').length,
                        Info: vulns.filter(v => v.severity === 'Info').length,
                    },
                    // ... populate others empty or calculate if needed. 
                    // For dashboard simplicity we just need these.
                    by_status: {
                        Open: vulns.filter(v => v.status === 'Open').length,
                        In_Progress: vulns.filter(v => v.status === 'In_Progress').length,
                        Testing: vulns.filter(v => v.status === 'Testing').length,
                        Resolved: vulns.filter(v => v.status === 'Resolved').length,
                        Accepted: vulns.filter(v => v.status === 'Accepted').length,
                        False_Positive: vulns.filter(v => v.status === 'False_Positive').length,
                        Duplicate: vulns.filter(v => v.status === 'Duplicate').length
                    },
                    sla_compliance: 100, // Placeholder
                    avg_resolution_time: 0, // Placeholder
                    by_source: {}, // Placeholder
                    overdue_count: 0,
                    trend_data: []
                } as any,
                loading: false
            });

        } catch (error) {
            console.error('Error loading dashboard metrics:', error);
            setMetrics(prev => ({ ...prev, loading: false }));
        }
    }, [tenantId]);

    useEffect(() => {
        loadDashboardData();
    }, [loadDashboardData]);

    return { metrics, refresh: loadDashboardData };
};
