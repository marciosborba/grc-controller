import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useCurrentTenantId } from '@/contexts/TenantSelectorContext';
import { VulnerabilityMetrics } from '../types/vulnerability';

export interface DashboardMetrics {
    riskScore: number;
    riskLevel: 'Critical' | 'High' | 'Medium' | 'Low' | 'Safe';
    totalVulnerabilities: number;
    totalApplications: number;
    totalAssets: number;
    vulnerabilityMetrics: VulnerabilityMetrics | null;
    loading: boolean;
}

export const useVulnerabilityDashboard = () => {
    const tenantId = useCurrentTenantId();
    const [metrics, setMetrics] = useState<DashboardMetrics>({
        riskScore: 0,
        riskLevel: 'Safe',
        totalVulnerabilities: 0,
        totalApplications: 0,
        totalAssets: 0,
        vulnerabilityMetrics: null,
        loading: true
    });

    const loadDashboardData = useCallback(async () => {
        if (!tenantId) return;

        setMetrics(prev => ({ ...prev, loading: true }));

        try {
            // 1. Fetch Vulnerability Metrics (reusing the logic from useVulnerabilities roughly)
            const { data: vulnData, error: vulnError } = await supabase
                .from('vulnerabilities')
                .select('severity, status')
                .eq('tenant_id', tenantId);

            if (vulnError) throw vulnError;

            const vulns = vulnData || [];
            const totalVulns = vulns.length;

            const criticalCount = vulns.filter(v => v.severity === 'Critical' && v.status === 'Open').length;
            const highCount = vulns.filter(v => v.severity === 'High' && v.status === 'Open').length;
            const mediumCount = vulns.filter(v => v.severity === 'Medium' && v.status === 'Open').length;
            const lowCount = vulns.filter(v => v.severity === 'Low' && v.status === 'Open').length;

            // 2. Fetch Applications Count
            // Try to check if table exists first or just try query. We assume 'applications' table.
            // If it fails, we default to 0.
            let appCount = 0;
            try {
                const { count, error: appError } = await supabase
                    .from('applications')
                    .select('*', { count: 'exact', head: true })
                    .eq('tenant_id', tenantId);

                if (!appError) appCount = count || 0;
            } catch (e) {
                console.warn('Applications table might not exist', e);
            }

            // 3. Fetch CMDB Assets Count
            // We try 'assets' or 'cmdb_assets'. Based on db.md file list 'create-cmdb-assets-table.sql', it might be 'cmdb_assets' or 'assets'.
            // Let's try 'assets' first, then 'cmdb_assets' if needed (or check file).
            // Actually 'create-cmdb-assets-table.sql' suggests 'cmdb_assets' might be the intent, but standard is often 'assets'.
            // I will try BOTH names to be safe, or just 'assets' if I see it in `db.md` (I didn't see `db.md` fully).
            // I'll try 'assets' then 'cmdb_assets'.
            let assetCount = 0;
            try {
                const { count, error: assetError } = await supabase
                    .from('assets')
                    .select('*', { count: 'exact', head: true })
                    .eq('tenant_id', tenantId);

                if (!assetError) {
                    assetCount = count || 0;
                } else {
                    // Fallback to cmdb_assets
                    const { count: cmdbCount, error: cmdbError } = await supabase
                        .from('cmdb_assets')
                        .select('*', { count: 'exact', head: true })
                        .eq('tenant_id', tenantId);
                    if (!cmdbError) assetCount = cmdbCount || 0;
                }
            } catch (e) {
                console.warn('Assets table might not exist', e);
            }

            // 4. Calculate Risk Score
            // Simple formula: Critical*10 + High*5 + Medium*2 + Low*1
            let score = 0;
            if (totalVulns > 0) {
                score = (criticalCount * 10) + (highCount * 5) + (mediumCount * 2) + lowCount;
            }

            let level: 'Critical' | 'High' | 'Medium' | 'Low' | 'Safe' = 'Safe';
            if (criticalCount > 0 || score > 50) level = 'Critical';
            else if (highCount > 0 || score > 20) level = 'High';
            else if (mediumCount > 0 || score > 10) level = 'Medium';
            else if (lowCount > 0) level = 'Low';

            setMetrics({
                riskScore: score,
                riskLevel: level,
                totalVulnerabilities: totalVulns,
                totalApplications: appCount,
                totalAssets: assetCount,
                vulnerabilityMetrics: {
                    // Minimal metrics needed for other parts if any
                    total_vulnerabilities: totalVulns,
                    critical_open: criticalCount,
                    high_open: highCount,
                    by_severity: {
                        Critical: vulns.filter(v => v.severity === 'Critical').length,
                        High: vulns.filter(v => v.severity === 'High').length,
                        Medium: vulns.filter(v => v.severity === 'Medium').length,
                        Low: vulns.filter(v => v.severity === 'Low').length,
                        Info: vulns.filter(v => v.severity === 'Info').length,
                    },
                    // ... populate others empty or calculate if needed. 
                    // For dashboard simplicity we just need these.
                    by_status: {
                        Open: vulns.filter(v => v.status === 'Open').length,
                        In_Progress: vulns.filter(v => v.status === 'In_Progress').length,
                        Testing: vulns.filter(v => v.status === 'Testing').length,
                        Resolved: vulns.filter(v => v.status === 'Resolved').length,
                        Accepted: vulns.filter(v => v.status === 'Accepted').length,
                        False_Positive: vulns.filter(v => v.status === 'False_Positive').length,
                        Duplicate: vulns.filter(v => v.status === 'Duplicate').length
                    },
                    sla_compliance: 100, // Placeholder
                    avg_resolution_time: 0, // Placeholder
                    by_source: {}, // Placeholder
                    overdue_count: 0,
                    trend_data: []
                } as any,
                loading: false
            });

        } catch (error) {
            console.error('Error loading dashboard metrics:', error);
            setMetrics(prev => ({ ...prev, loading: false }));
        }
    }, [tenantId]);

    useEffect(() => {
        loadDashboardData();
    }, [loadDashboardData]);

    return { metrics, refresh: loadDashboardData };
};
