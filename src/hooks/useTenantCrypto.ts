/**\n * HOOK PARA GESTAO DE CRIPTOGRAFIA POR TENANT\n * \n * Hook personalizado que facilita o uso do sistema de criptografia\n * por tenant em componentes React.\n */\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { useAuth} from '@/contexts/AuthContextOptimized';\nimport { \n  tenantCrypto, \n  type TenantKeyInfo, \n  type EncryptionPurpose,\n  type EncryptionResult,\n  type DecryptionResult\n} from '@/utils/tenantCrypto';\nimport { toast } from 'sonner';\n\ninterface UseTenantCryptoOptions {\n  autoLoadKeys?: boolean;\n  autoLoadStats?: boolean;\n  statsDays?: number;\n}\n\ninterface CryptoStats {\n  operationType: string;\n  operationDate: string;\n  operationCount: number;\n  successCount: number;\n  errorCount: number;\n  avgPerformanceMs: number;\n  maxPerformanceMs: number;\n}\n\ninterface UseTenantCryptoReturn {\n  // Estados\n  keyInfo: TenantKeyInfo[];\n  cryptoStats: CryptoStats[];\n  cacheStats: any;\n  loading: boolean;\n  error: string | null;\n  \n  // Funcoes de criptografia\n  encrypt: (data: string, purpose?: EncryptionPurpose, options?: { tableName?: string; fieldName?: string }) => Promise<EncryptionResult>;\n  decrypt: (encryptedData: string, purpose?: EncryptionPurpose, options?: { tableName?: string; fieldName?: string }) => Promise<DecryptionResult>;\n  \n  // Funcoes de conveniencia\n  encryptPII: (data: string) => Promise<string | null>;\n  decryptPII: (encryptedData: string) => Promise<string | null>;\n  encryptFinancial: (data: string) => Promise<string | null>;\n  decryptFinancial: (encryptedData: string) => Promise<string | null>;\n  encryptAudit: (data: string) => Promise<string | null>;\n  decryptAudit: (encryptedData: string) => Promise<string | null>;\n  encryptCompliance: (data: string) => Promise<string | null>;\n  decryptCompliance: (encryptedData: string) => Promise<string | null>;\n  \n  // Funcoes de gerenciamento\n  loadKeyInfo: () => Promise<void>;\n  loadCryptoStats: () => Promise<void>;\n  rotateKey: (purpose: EncryptionPurpose, reason?: string) => Promise<boolean>;\n  createTenantKeys: () => Promise<boolean>;\n  clearCache: (purpose?: EncryptionPurpose) => void;\n  \n  // Funcoes de teste\n  testEncryption: (testData: string, purposes?: EncryptionPurpose[]) => Promise<any[]>;\n  \n  // Utilitarios\n  isEncrypted: (data: string) => boolean;\n  estimateEncryptedSize: (plaintext: string) => number;\n}\n\nexport const useTenantCrypto = (\n  tenantId?: string,\n  options: UseTenantCryptoOptions = {}\n): UseTenantCryptoReturn => {\n  const { user } = useAuth();\n  const {\n    autoLoadKeys = true,\n    autoLoadStats = true,\n    statsDays = 30\n  } = options;\n  \n  // Usar tenantId do usuario se nao fornecido\n  const effectiveTenantId = tenantId || user?.tenantId;\n  \n  // Estados\n  const [keyInfo, setKeyInfo] = useState<TenantKeyInfo[]>([]);\n  const [cryptoStats, setCryptoStats] = useState<CryptoStats[]>([]);\n  const [cacheStats, setCacheStats] = useState<any>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  \n  // Funcao para carregar informacoes das chaves\n  const loadKeyInfo = useCallback(async () => {\n    if (!effectiveTenantId) {\n      setError('Tenant ID nao fornecido');\n      return;\n    }\n    \n    try {\n      setLoading(true);\n      setError(null);\n      \n      const keys = await tenantCrypto.getTenantKeyInfo(effectiveTenantId);\n      setKeyInfo(keys);\n    } catch (err: any) {\n      const errorMessage = err.message || 'Erro ao carregar informacoes das chaves';\n      setError(errorMessage);\n      console.error('Erro ao carregar informacoes das chaves:', err);\n    } finally {\n      setLoading(false);\n    }\n  }, [effectiveTenantId]);\n  \n  // Funcao para carregar estatisticas\n  const loadCryptoStats = useCallback(async () => {\n    if (!effectiveTenantId) {\n      setError('Tenant ID nao fornecido');\n      return;\n    }\n    \n    try {\n      setError(null);\n      \n      const [stats, cache] = await Promise.all([\n        tenantCrypto.getCryptoStats(effectiveTenantId, statsDays),\n        Promise.resolve(tenantCrypto.getCacheStats())\n      ]);\n      \n      setCryptoStats(stats);\n      setCacheStats(cache);\n    } catch (err: any) {\n      const errorMessage = err.message || 'Erro ao carregar estatisticas';\n      setError(errorMessage);\n      console.error('Erro ao carregar estatisticas:', err);\n    }\n  }, [effectiveTenantId, statsDays]);\n  \n  // Funcoes de criptografia\n  const encrypt = useCallback(async (\n    data: string, \n    purpose: EncryptionPurpose = 'general',\n    options?: { tableName?: string; fieldName?: string }\n  ): Promise<EncryptionResult> => {\n    if (!effectiveTenantId) {\n      return {\n        success: false,\n        error: 'Tenant ID nao fornecido'\n      };\n    }\n    \n    return await tenantCrypto.encrypt(effectiveTenantId, data, purpose, options);\n  }, [effectiveTenantId]);\n  \n  const decrypt = useCallback(async (\n    encryptedData: string, \n    purpose: EncryptionPurpose = 'general',\n    options?: { tableName?: string; fieldName?: string }\n  ): Promise<DecryptionResult> => {\n    if (!effectiveTenantId) {\n      return {\n        success: false,\n        error: 'Tenant ID nao fornecido'\n      };\n    }\n    \n    return await tenantCrypto.decrypt(effectiveTenantId, encryptedData, purpose, options);\n  }, [effectiveTenantId]);\n  \n  // Funcoes de conveniencia\n  const encryptPII = useCallback(async (data: string): Promise<string | null> => {\n    if (!effectiveTenantId) return null;\n    \n    const result = await tenantCrypto.encrypt(effectiveTenantId, data, 'pii');\n    return result.success ? result.data! : null;\n  }, [effectiveTenantId]);\n  \n  const decryptPII = useCallback(async (encryptedData: string): Promise<string | null> => {\n    if (!effectiveTenantId) return null;\n    \n    const result = await tenantCrypto.decrypt(effectiveTenantId, encryptedData, 'pii');\n    return result.success ? result.data! : null;\n  }, [effectiveTenantId]);\n  \n  const encryptFinancial = useCallback(async (data: string): Promise<string | null> => {\n    if (!effectiveTenantId) return null;\n    \n    const result = await tenantCrypto.encrypt(effectiveTenantId, data, 'financial');\n    return result.success ? result.data! : null;\n  }, [effectiveTenantId]);\n  \n  const decryptFinancial = useCallback(async (encryptedData: string): Promise<string | null> => {\n    if (!effectiveTenantId) return null;\n    \n    const result = await tenantCrypto.decrypt(effectiveTenantId, encryptedData, 'financial');\n    return result.success ? result.data! : null;\n  }, [effectiveTenantId]);\n  \n  const encryptAudit = useCallback(async (data: string): Promise<string | null> => {\n    if (!effectiveTenantId) return null;\n    \n    const result = await tenantCrypto.encrypt(effectiveTenantId, data, 'audit');\n    return result.success ? result.data! : null;\n  }, [effectiveTenantId]);\n  \n  const decryptAudit = useCallback(async (encryptedData: string): Promise<string | null> => {\n    if (!effectiveTenantId) return null;\n    \n    const result = await tenantCrypto.decrypt(effectiveTenantId, encryptedData, 'audit');\n    return result.success ? result.data! : null;\n  }, [effectiveTenantId]);\n  \n  const encryptCompliance = useCallback(async (data: string): Promise<string | null> => {\n    if (!effectiveTenantId) return null;\n    \n    const result = await tenantCrypto.encrypt(effectiveTenantId, data, 'compliance');\n    return result.success ? result.data! : null;\n  }, [effectiveTenantId]);\n  \n  const decryptCompliance = useCallback(async (encryptedData: string): Promise<string | null> => {\n    if (!effectiveTenantId) return null;\n    \n    const result = await tenantCrypto.decrypt(effectiveTenantId, encryptedData, 'compliance');\n    return result.success ? result.data! : null;\n  }, [effectiveTenantId]);\n  \n  // Funcoes de gerenciamento\n  const rotateKey = useCallback(async (\n    purpose: EncryptionPurpose, \n    reason: string = 'manual'\n  ): Promise<boolean> => {\n    if (!effectiveTenantId) {\n      toast.error('Tenant ID nao fornecido');\n      return false;\n    }\n    \n    try {\n      const success = await tenantCrypto.rotateKey(effectiveTenantId, purpose, reason);\n      \n      if (success) {\n        // Recarregar informacoes apos rotacao\n        await loadKeyInfo();\n        await loadCryptoStats();\n      }\n      \n      return success;\n    } catch (err: any) {\n      console.error('Erro ao rotacionar chave:', err);\n      toast.error('Erro ao rotacionar chave');\n      return false;\n    }\n  }, [effectiveTenantId, loadKeyInfo, loadCryptoStats]);\n  \n  const createTenantKeys = useCallback(async (): Promise<boolean> => {\n    if (!effectiveTenantId) {\n      toast.error('Tenant ID nao fornecido');\n      return false;\n    }\n    \n    try {\n      const success = await tenantCrypto.createTenantKeys(effectiveTenantId);\n      \n      if (success) {\n        // Recarregar informacoes apos criacao\n        await loadKeyInfo();\n        await loadCryptoStats();\n      }\n      \n      return success;\n    } catch (err: any) {\n      console.error('Erro ao criar chaves:', err);\n      toast.error('Erro ao criar chaves criptograficas');\n      return false;\n    }\n  }, [effectiveTenantId, loadKeyInfo, loadCryptoStats]);\n  \n  const clearCache = useCallback((purpose?: EncryptionPurpose) => {\n    if (!effectiveTenantId) {\n      toast.error('Tenant ID nao fornecido');\n      return;\n    }\n    \n    try {\n      tenantCrypto.clearCache(effectiveTenantId, purpose);\n      \n      // Atualizar estatisticas do cache\n      const newCacheStats = tenantCrypto.getCacheStats();\n      setCacheStats(newCacheStats);\n      \n      toast.success(\n        purpose \n          ? `Cache da chave ${purpose} limpo` \n          : 'Cache do tenant limpo'\n      );\n    } catch (err: any) {\n      console.error('Erro ao limpar cache:', err);\n      toast.error('Erro ao limpar cache');\n    }\n  }, [effectiveTenantId]);\n  \n  // Funcao de teste\n  const testEncryption = useCallback(async (\n    testData: string,\n    purposes: EncryptionPurpose[] = ['general', 'pii', 'financial', 'audit', 'compliance']\n  ): Promise<any[]> => {\n    if (!effectiveTenantId) {\n      toast.error('Tenant ID nao fornecido');\n      return [];\n    }\n    \n    if (!testData.trim()) {\n      toast.error('Dados de teste sao obrigatorios');\n      return [];\n    }\n    \n    const results = [];\n    \n    for (const purpose of purposes) {\n      const startTime = performance.now();\n      \n      try {\n        // Testar criptografia\n        const encryptResult = await encrypt(testData, purpose, {\n          tableName: 'test',\n          fieldName: 'test_field'\n        });\n        \n        if (!encryptResult.success) {\n          throw new Error(encryptResult.error || 'Falha na criptografia');\n        }\n        \n        // Testar descriptografia\n        const decryptResult = await decrypt(encryptResult.data!, purpose, {\n          tableName: 'test',\n          fieldName: 'test_field'\n        });\n        \n        if (!decryptResult.success) {\n          throw new Error(decryptResult.error || 'Falha na descriptografia');\n        }\n        \n        const endTime = performance.now();\n        const performanceMs = Math.round(endTime - startTime);\n        \n        results.push({\n          purpose,\n          testData,\n          encrypted: encryptResult.data!,\n          decrypted: decryptResult.data!,\n          success: decryptResult.data === testData,\n          performanceMs\n        });\n        \n      } catch (error: any) {\n        const endTime = performance.now();\n        const performanceMs = Math.round(endTime - startTime);\n        \n        results.push({\n          purpose,\n          testData,\n          encrypted: '',\n          decrypted: '',\n          success: false,\n          performanceMs,\n          error: error.message\n        });\n      }\n    }\n    \n    const successCount = results.filter(r => r.success).length;\n    const totalCount = results.length;\n    \n    if (successCount === totalCount) {\n      toast.success(`Todos os testes passaram! (${successCount}/${totalCount})`);\n    } else {\n      toast.warning(`${successCount}/${totalCount} testes passaram`);\n    }\n    \n    return results;\n  }, [effectiveTenantId, encrypt, decrypt]);\n  \n  // Utilitarios\n  const isEncrypted = useCallback((data: string): boolean => {\n    return tenantCrypto.constructor.isEncrypted(data);\n  }, []);\n  \n  const estimateEncryptedSize = useCallback((plaintext: string): number => {\n    return tenantCrypto.constructor.estimateEncryptedSize(plaintext);\n  }, []);\n  \n  // Carregar dados iniciais\n  useEffect(() => {\n    if (effectiveTenantId) {\n      if (autoLoadKeys) {\n        loadKeyInfo();\n      }\n      \n      if (autoLoadStats) {\n        loadCryptoStats();\n      }\n    }\n  }, [effectiveTenantId, autoLoadKeys, autoLoadStats, loadKeyInfo, loadCryptoStats]);\n  \n  return {\n    // Estados\n    keyInfo,\n    cryptoStats,\n    cacheStats,\n    loading,\n    error,\n    \n    // Funcoes de criptografia\n    encrypt,\n    decrypt,\n    \n    // Funcoes de conveniencia\n    encryptPII,\n    decryptPII,\n    encryptFinancial,\n    decryptFinancial,\n    encryptAudit,\n    decryptAudit,\n    encryptCompliance,\n    decryptCompliance,\n    \n    // Funcoes de gerenciamento\n    loadKeyInfo,\n    loadCryptoStats,\n    rotateKey,\n    createTenantKeys,\n    clearCache,\n    \n    // Funcoes de teste\n    testEncryption,\n    \n    // Utilitarios\n    isEncrypted,\n    estimateEncryptedSize\n  };\n};\n\nexport default useTenantCrypto;\n"