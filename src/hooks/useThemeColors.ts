import { useEffect, useState } from 'react';\n\n// ============================================================================\n// HOOK PARA CORES DO TEMA\n// ============================================================================\n// Hook personalizado para acessar e usar as cores do tema configurável\n\ninterface ThemeColors {\n  // Cores principais\n  primary: string;\n  primaryForeground: string;\n  primaryHover: string;\n  primaryGlow: string;\n  \n  // Cores secundárias\n  secondary: string;\n  secondaryForeground: string;\n  \n  // Cores de destaque\n  accent: string;\n  accentForeground: string;\n  \n  // Cores de fundo\n  background: string;\n  foreground: string;\n  card: string;\n  cardForeground: string;\n  \n  // Cores de interface\n  border: string;\n  input: string;\n  ring: string;\n  muted: string;\n  mutedForeground: string;\n  popover: string;\n  popoverForeground: string;\n  \n  // Cores de estado\n  success: string;\n  successForeground: string;\n  successLight: string;\n  warning: string;\n  warningForeground: string;\n  warningLight: string;\n  danger: string;\n  dangerForeground: string;\n  dangerLight: string;\n  destructive: string;\n  destructiveForeground: string;\n  \n  // Cores de risco\n  riskCritical: string;\n  riskHigh: string;\n  riskMedium: string;\n  riskLow: string;\n  \n  // Cores do sidebar\n  sidebarBackground: string;\n  sidebarForeground: string;\n  sidebarPrimary: string;\n  sidebarPrimaryForeground: string;\n  sidebarAccent: string;\n  sidebarAccentForeground: string;\n  sidebarBorder: string;\n  sidebarRing: string;\n}\n\n// Função para obter valor de variável CSS\nconst getCSSVariable = (variable: string): string => {\n  if (typeof window === 'undefined') return '';\n  \n  const value = getComputedStyle(document.documentElement)\n    .getPropertyValue(variable)\n    .trim();\n  \n  return value;\n};\n\n// Função para converter HSL para formato utilizável\nconst formatHSLColor = (hslValue: string): string => {\n  if (!hslValue) return '';\n  return `hsl(${hslValue})`;\n};\n\nexport const useThemeColors = (): ThemeColors => {\n  const [colors, setColors] = useState<ThemeColors>({} as ThemeColors);\n\n  const updateColors = () => {\n    const newColors: ThemeColors = {\n      // Cores principais\n      primary: formatHSLColor(getCSSVariable('--primary')),\n      primaryForeground: formatHSLColor(getCSSVariable('--primary-foreground')),\n      primaryHover: formatHSLColor(getCSSVariable('--primary-hover')),\n      primaryGlow: formatHSLColor(getCSSVariable('--primary-glow')),\n      \n      // Cores secundárias\n      secondary: formatHSLColor(getCSSVariable('--secondary')),\n      secondaryForeground: formatHSLColor(getCSSVariable('--secondary-foreground')),\n      \n      // Cores de destaque\n      accent: formatHSLColor(getCSSVariable('--accent')),\n      accentForeground: formatHSLColor(getCSSVariable('--accent-foreground')),\n      \n      // Cores de fundo\n      background: formatHSLColor(getCSSVariable('--background')),\n      foreground: formatHSLColor(getCSSVariable('--foreground')),\n      card: formatHSLColor(getCSSVariable('--card')),\n      cardForeground: formatHSLColor(getCSSVariable('--card-foreground')),\n      \n      // Cores de interface\n      border: formatHSLColor(getCSSVariable('--border')),\n      input: formatHSLColor(getCSSVariable('--input')),\n      ring: formatHSLColor(getCSSVariable('--ring')),\n      muted: formatHSLColor(getCSSVariable('--muted')),\n      mutedForeground: formatHSLColor(getCSSVariable('--muted-foreground')),\n      popover: formatHSLColor(getCSSVariable('--popover')),\n      popoverForeground: formatHSLColor(getCSSVariable('--popover-foreground')),\n      \n      // Cores de estado\n      success: formatHSLColor(getCSSVariable('--success')),\n      successForeground: formatHSLColor(getCSSVariable('--success-foreground')),\n      successLight: formatHSLColor(getCSSVariable('--success-light')),\n      warning: formatHSLColor(getCSSVariable('--warning')),\n      warningForeground: formatHSLColor(getCSSVariable('--warning-foreground')),\n      warningLight: formatHSLColor(getCSSVariable('--warning-light')),\n      danger: formatHSLColor(getCSSVariable('--danger')),\n      dangerForeground: formatHSLColor(getCSSVariable('--danger-foreground')),\n      dangerLight: formatHSLColor(getCSSVariable('--danger-light')),\n      destructive: formatHSLColor(getCSSVariable('--destructive')),\n      destructiveForeground: formatHSLColor(getCSSVariable('--destructive-foreground')),\n      \n      // Cores de risco\n      riskCritical: formatHSLColor(getCSSVariable('--risk-critical')),\n      riskHigh: formatHSLColor(getCSSVariable('--risk-high')),\n      riskMedium: formatHSLColor(getCSSVariable('--risk-medium')),\n      riskLow: formatHSLColor(getCSSVariable('--risk-low')),\n      \n      // Cores do sidebar\n      sidebarBackground: formatHSLColor(getCSSVariable('--sidebar-background')),\n      sidebarForeground: formatHSLColor(getCSSVariable('--sidebar-foreground')),\n      sidebarPrimary: formatHSLColor(getCSSVariable('--sidebar-primary')),\n      sidebarPrimaryForeground: formatHSLColor(getCSSVariable('--sidebar-primary-foreground')),\n      sidebarAccent: formatHSLColor(getCSSVariable('--sidebar-accent')),\n      sidebarAccentForeground: formatHSLColor(getCSSVariable('--sidebar-accent-foreground')),\n      sidebarBorder: formatHSLColor(getCSSVariable('--sidebar-border')),\n      sidebarRing: formatHSLColor(getCSSVariable('--sidebar-ring')),\n    };\n    \n    setColors(newColors);\n  };\n\n  useEffect(() => {\n    // Atualizar cores na inicialização\n    updateColors();\n    \n    // Escutar mudanças de tema\n    const handleThemeChange = () => {\n      updateColors();\n    };\n    \n    // Escutar eventos de mudança de tema\n    window.addEventListener('themeChange', handleThemeChange);\n    window.addEventListener('globalThemeChanged', handleThemeChange);\n    window.addEventListener('tenantThemeUpdated', handleThemeChange);\n    \n    // Observer para mudanças nas variáveis CSS\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'style') {\n          updateColors();\n        }\n      });\n    });\n    \n    if (typeof window !== 'undefined') {\n      observer.observe(document.documentElement, {\n        attributes: true,\n        attributeFilter: ['style', 'class']\n      });\n    }\n    \n    return () => {\n      window.removeEventListener('themeChange', handleThemeChange);\n      window.removeEventListener('globalThemeChanged', handleThemeChange);\n      window.removeEventListener('tenantThemeUpdated', handleThemeChange);\n      observer.disconnect();\n    };\n  }, []);\n\n  return colors;\n};\n\n// ============================================================================\n// HOOK PARA CORES DE RISCO\n// ============================================================================\n\nexport const useRiskColors = () => {\n  const colors = useThemeColors();\n  \n  return {\n    critical: colors.riskCritical,\n    high: colors.riskHigh,\n    medium: colors.riskMedium,\n    low: colors.riskLow,\n    \n    // Função para obter cor baseada no nível de risco\n    getRiskColor: (level: 'critical' | 'high' | 'medium' | 'low') => {\n      switch (level) {\n        case 'critical': return colors.riskCritical;\n        case 'high': return colors.riskHigh;\n        case 'medium': return colors.riskMedium;\n        case 'low': return colors.riskLow;\n        default: return colors.muted;\n      }\n    },\n    \n    // Função para obter cor com opacidade\n    getRiskColorWithOpacity: (level: 'critical' | 'high' | 'medium' | 'low', opacity: number) => {\n      const color = colors[`risk${level.charAt(0).toUpperCase() + level.slice(1)}` as keyof ThemeColors] as string;\n      if (!color) return '';\n      \n      // Extrair valores HSL e adicionar opacidade\n      const hslMatch = color.match(/hsl\\(([^)]+)\\)/);\n      if (hslMatch) {\n        return `hsl(${hslMatch[1]} / ${opacity})`;\n      }\n      return color;\n    }\n  };\n};\n\n// ============================================================================\n// HOOK PARA CORES DE STATUS\n// ============================================================================\n\nexport const useStatusColors = () => {\n  const colors = useThemeColors();\n  \n  return {\n    success: colors.success,\n    warning: colors.warning,\n    danger: colors.danger,\n    info: colors.primary,\n    \n    // Função para obter cor baseada no status\n    getStatusColor: (status: 'success' | 'warning' | 'danger' | 'info') => {\n      switch (status) {\n        case 'success': return colors.success;\n        case 'warning': return colors.warning;\n        case 'danger': return colors.danger;\n        case 'info': return colors.primary;\n        default: return colors.muted;\n      }\n    },\n    \n    // Função para obter cor de fundo com opacidade\n    getStatusBackgroundColor: (status: 'success' | 'warning' | 'danger' | 'info', opacity: number = 0.1) => {\n      const color = colors[status === 'info' ? 'primary' : status] as string;\n      if (!color) return '';\n      \n      const hslMatch = color.match(/hsl\\(([^)]+)\\)/);\n      if (hslMatch) {\n        return `hsl(${hslMatch[1]} / ${opacity})`;\n      }\n      return color;\n    }\n  };\n};\n\n// ============================================================================\n// HOOK PARA CORES DE COMPLIANCE\n// ============================================================================\n\nexport const useComplianceColors = () => {\n  const colors = useThemeColors();\n  \n  return {\n    high: colors.success,\n    medium: colors.warning,\n    low: colors.danger,\n    \n    // Função para obter cor baseada no nível de compliance\n    getComplianceColor: (level: 'high' | 'medium' | 'low') => {\n      switch (level) {\n        case 'high': return colors.success;\n        case 'medium': return colors.warning;\n        case 'low': return colors.danger;\n        default: return colors.muted;\n      }\n    },\n    \n    // Função para obter cor baseada na porcentagem\n    getComplianceColorByPercentage: (percentage: number) => {\n      if (percentage >= 80) return colors.success;\n      if (percentage >= 60) return colors.warning;\n      return colors.danger;\n    }\n  };\n};\n\n// ============================================================================\n// HOOK PARA GRADIENTES\n// ============================================================================\n\nexport const useThemeGradients = () => {\n  const colors = useThemeColors();\n  \n  return {\n    primary: `linear-gradient(135deg, ${colors.primary}, ${colors.primaryGlow || colors.primary})`,\n    success: `linear-gradient(135deg, ${colors.success}, ${colors.successLight || colors.success})`,\n    hero: `linear-gradient(135deg, ${colors.primary} 0%, ${colors.accent} 100%)`,\n    \n    // Função para criar gradiente personalizado\n    createGradient: (color1: string, color2: string, direction: string = '135deg') => {\n      return `linear-gradient(${direction}, ${color1}, ${color2})`;\n    },\n    \n    // Gradientes com opacidade\n    primaryWithOpacity: (opacity: number = 0.1) => {\n      const hslMatch = colors.primary.match(/hsl\\(([^)]+)\\)/);\n      if (hslMatch) {\n        return `linear-gradient(135deg, hsl(${hslMatch[1]} / ${opacity}), hsl(${hslMatch[1]} / ${opacity * 0.5}))`;\n      }\n      return colors.primary;\n    }\n  };\n};\n\n// ============================================================================\n// HOOK PARA APLICAR CORES DINAMICAMENTE\n// ============================================================================\n\nexport const useApplyThemeColors = () => {\n  const colors = useThemeColors();\n  \n  return {\n    // Aplicar cor a um elemento\n    applyColor: (element: HTMLElement, property: string, colorKey: keyof ThemeColors) => {\n      if (element && colors[colorKey]) {\n        element.style.setProperty(property, colors[colorKey] as string);\n      }\n    },\n    \n    // Aplicar múltiplas cores\n    applyColors: (element: HTMLElement, colorMap: Record<string, keyof ThemeColors>) => {\n      if (!element) return;\n      \n      Object.entries(colorMap).forEach(([property, colorKey]) => {\n        if (colors[colorKey]) {\n          element.style.setProperty(property, colors[colorKey] as string);\n        }\n      });\n    },\n    \n    // Obter estilo inline para componentes\n    getInlineStyles: (colorMap: Record<string, keyof ThemeColors>): React.CSSProperties => {\n      const styles: React.CSSProperties = {};\n      \n      Object.entries(colorMap).forEach(([property, colorKey]) => {\n        if (colors[colorKey]) {\n          // Converter propriedades CSS para camelCase\n          const camelProperty = property.replace(/-([a-z])/g, (g) => g[1].toUpperCase());\n          (styles as any)[camelProperty] = colors[colorKey];\n        }\n      });\n      \n      return styles;\n    }\n  };\n};\n"