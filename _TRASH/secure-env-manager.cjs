#!/usr/bin/env node

/**\n * ğŸ” Secure Environment Manager\n * \n * Sistema de criptografia para credenciais sensÃ­veis\n * Uso: node secure-env-manager.cjs [comando]\n * \n * Comandos:\n * - encrypt: Criptografar arquivo .env\n * - decrypt: Descriptografar para uso\n * - rotate: Rotacionar chaves de criptografia\n * - verify: Verificar integridade\n */\n\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\n\nclass SecureEnvManager {\n  constructor() {\n    this.algorithm = 'aes-256-gcm';\n    this.keyFile = '.env.key';\n    this.encryptedFile = '.env.encrypted';\n    this.backupDir = 'backups/env';\n    this.saltLength = 32;\n    this.ivLength = 16;\n    this.tagLength = 16;\n    \n    // Criar diretÃ³rio de backup se nÃ£o existir\n    if (!fs.existsSync(this.backupDir)) {\n      fs.mkdirSync(this.backupDir, { recursive: true });\n    }\n  }\n\n  /**\n   * Gerar chave de criptografia segura\n   */\n  generateKey() {\n    console.log('ğŸ”‘ Gerando nova chave de criptografia...');\n    \n    const key = crypto.randomBytes(32);\n    const salt = crypto.randomBytes(this.saltLength);\n    \n    const keyData = {\n      key: key.toString('hex'),\n      salt: salt.toString('hex'),\n      created: new Date().toISOString(),\n      algorithm: this.algorithm,\n      version: '1.0'\n    };\n    \n    // Salvar chave com permissÃµes restritas\n    fs.writeFileSync(this.keyFile, JSON.stringify(keyData, null, 2), { mode: 0o600 });\n    \n    console.log('âœ… Chave gerada e salva em:', this.keyFile);\n    console.log('âš ï¸  IMPORTANTE: Mantenha este arquivo seguro e nÃ£o o commite!');\n    \n    return keyData;\n  }\n\n  /**\n   * Carregar chave de criptografia\n   */\n  loadKey() {\n    if (!fs.existsSync(this.keyFile)) {\n      throw new Error(`Arquivo de chave nÃ£o encontrado: ${this.keyFile}`);\n    }\n    \n    try {\n      const keyData = JSON.parse(fs.readFileSync(this.keyFile, 'utf8'));\n      \n      // Validar estrutura da chave\n      if (!keyData.key || !keyData.salt) {\n        throw new Error('Estrutura de chave invÃ¡lida');\n      }\n      \n      return keyData;\n    } catch (error) {\n      throw new Error(`Erro ao carregar chave: ${error.message}`);\n    }\n  }\n\n  /**\n   * Criptografar arquivo .env\n   */\n  encrypt() {\n    console.log('ğŸ”’ Criptografando arquivo .env...');\n    \n    // Verificar se .env existe\n    if (!fs.existsSync('.env')) {\n      throw new Error('Arquivo .env nÃ£o encontrado');\n    }\n    \n    // Carregar ou gerar chave\n    let keyData;\n    try {\n      keyData = this.loadKey();\n      console.log('ğŸ”‘ Usando chave existente');\n    } catch {\n      console.log('ğŸ”‘ Gerando nova chave...');\n      keyData = this.generateKey();\n    }\n    \n    // Ler conteÃºdo do .env\n    const envContent = fs.readFileSync('.env', 'utf8');\n    \n    // Criar backup do .env original\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);\n    const backupPath = path.join(this.backupDir, `.env.backup.${timestamp}`);\n    fs.writeFileSync(backupPath, envContent);\n    console.log('ğŸ’¾ Backup criado:', backupPath);\n    \n    // Criptografar\n    const key = Buffer.from(keyData.key, 'hex');\n    const iv = crypto.randomBytes(this.ivLength);\n    const cipher = crypto.createCipher(this.algorithm, key);\n    cipher.setAAD(Buffer.from(keyData.salt, 'hex'));\n    \n    let encrypted = cipher.update(envContent, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    \n    const authTag = cipher.getAuthTag();\n    \n    const encryptedData = {\n      encrypted,\n      iv: iv.toString('hex'),\n      authTag: authTag.toString('hex'),\n      salt: keyData.salt,\n      algorithm: this.algorithm,\n      created: new Date().toISOString(),\n      version: '1.0'\n    };\n    \n    // Salvar arquivo criptografado\n    fs.writeFileSync(this.encryptedFile, JSON.stringify(encryptedData, null, 2));\n    \n    // Remover .env original (opcional - comentado por seguranÃ§a)\n    // fs.unlinkSync('.env');\n    \n    console.log('âœ… Arquivo criptografado salvo em:', this.encryptedFile);\n    console.log('âš ï¸  Considere remover o .env original apÃ³s verificar que a criptografia funcionou');\n    \n    return encryptedData;\n  }\n\n  /**\n   * Descriptografar arquivo .env\n   */\n  decrypt(outputFile = '.env.decrypted') {\n    console.log('ğŸ”“ Descriptografando arquivo...');\n    \n    // Verificar se arquivo criptografado existe\n    if (!fs.existsSync(this.encryptedFile)) {\n      throw new Error(`Arquivo criptografado nÃ£o encontrado: ${this.encryptedFile}`);\n    }\n    \n    // Carregar chave\n    const keyData = this.loadKey();\n    \n    // Carregar dados criptografados\n    const encryptedData = JSON.parse(fs.readFileSync(this.encryptedFile, 'utf8'));\n    \n    // Validar dados\n    if (!encryptedData.encrypted || !encryptedData.iv || !encryptedData.authTag) {\n      throw new Error('Dados criptografados invÃ¡lidos');\n    }\n    \n    try {\n      // Descriptografar\n      const key = Buffer.from(keyData.key, 'hex');\n      const iv = Buffer.from(encryptedData.iv, 'hex');\n      const authTag = Buffer.from(encryptedData.authTag, 'hex');\n      \n      const decipher = crypto.createDecipher(this.algorithm, key);\n      decipher.setAAD(Buffer.from(encryptedData.salt, 'hex'));\n      decipher.setAuthTag(authTag);\n      \n      let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n      \n      // Salvar arquivo descriptografado\n      fs.writeFileSync(outputFile, decrypted, { mode: 0o600 });\n      \n      console.log('âœ… Arquivo descriptografado salvo em:', outputFile);\n      console.log('âš ï¸  Lembre-se de remover este arquivo apÃ³s o uso');\n      \n      return decrypted;\n    } catch (error) {\n      throw new Error(`Erro na descriptografia: ${error.message}`);\n    }\n  }\n\n  /**\n   * Verificar integridade dos arquivos\n   */\n  verify() {\n    console.log('ğŸ” Verificando integridade...');\n    \n    const checks = {\n      keyFile: fs.existsSync(this.keyFile),\n      encryptedFile: fs.existsSync(this.encryptedFile),\n      keyValid: false,\n      encryptedValid: false\n    };\n    \n    // Verificar chave\n    if (checks.keyFile) {\n      try {\n        const keyData = this.loadKey();\n        checks.keyValid = keyData.key && keyData.salt;\n      } catch {\n        checks.keyValid = false;\n      }\n    }\n    \n    // Verificar arquivo criptografado\n    if (checks.encryptedFile) {\n      try {\n        const encryptedData = JSON.parse(fs.readFileSync(this.encryptedFile, 'utf8'));\n        checks.encryptedValid = encryptedData.encrypted && encryptedData.iv && encryptedData.authTag;\n      } catch {\n        checks.encryptedValid = false;\n      }\n    }\n    \n    // RelatÃ³rio\n    console.log('ğŸ“‹ RelatÃ³rio de Integridade:');\n    console.log(`  Arquivo de chave: ${checks.keyFile ? 'âœ…' : 'âŒ'} ${checks.keyValid ? '(vÃ¡lido)' : '(invÃ¡lido)'}`);\n    console.log(`  Arquivo criptografado: ${checks.encryptedFile ? 'âœ…' : 'âŒ'} ${checks.encryptedValid ? '(vÃ¡lido)' : '(invÃ¡lido)'}`);\n    \n    const allValid = checks.keyFile && checks.encryptedFile && checks.keyValid && checks.encryptedValid;\n    console.log(`\\nğŸ¯ Status geral: ${allValid ? 'âœ… Tudo OK' : 'âŒ Problemas encontrados'}`);\n    \n    return checks;\n  }\n\n  /**\n   * Rotacionar chaves de criptografia\n   */\n  rotate() {\n    console.log('ğŸ”„ Rotacionando chaves de criptografia...');\n    \n    // Backup da chave atual\n    if (fs.existsSync(this.keyFile)) {\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);\n      const backupKeyPath = path.join(this.backupDir, `.env.key.backup.${timestamp}`);\n      fs.copyFileSync(this.keyFile, backupKeyPath);\n      console.log('ğŸ’¾ Backup da chave atual:', backupKeyPath);\n    }\n    \n    // Descriptografar com chave atual\n    let envContent;\n    try {\n      envContent = this.decrypt('.env.temp');\n      fs.unlinkSync('.env.temp'); // Remover arquivo temporÃ¡rio\n    } catch (error) {\n      console.error('âŒ Erro ao descriptografar com chave atual:', error.message);\n      return false;\n    }\n    \n    // Gerar nova chave\n    this.generateKey();\n    \n    // Criptografar novamente com nova chave\n    fs.writeFileSync('.env', envContent, { mode: 0o600 });\n    this.encrypt();\n    fs.unlinkSync('.env'); // Remover .env temporÃ¡rio\n    \n    console.log('âœ… RotaÃ§Ã£o de chaves concluÃ­da com sucesso!');\n    return true;\n  }\n\n  /**\n   * Limpar arquivos temporÃ¡rios\n   */\n  cleanup() {\n    console.log('ğŸ§¹ Limpando arquivos temporÃ¡rios...');\n    \n    const tempFiles = ['.env.decrypted', '.env.temp'];\n    let cleaned = 0;\n    \n    tempFiles.forEach(file => {\n      if (fs.existsSync(file)) {\n        fs.unlinkSync(file);\n        cleaned++;\n        console.log(`ğŸ—‘ï¸  Removido: ${file}`);\n      }\n    });\n    \n    console.log(`âœ… ${cleaned} arquivo(s) temporÃ¡rio(s) removido(s)`);\n  }\n\n  /**\n   * Mostrar status do sistema\n   */\n  status() {\n    console.log('ğŸ“Š Status do Sistema de Criptografia\\n');\n    \n    const stats = {\n      keyFile: fs.existsSync(this.keyFile),\n      encryptedFile: fs.existsSync(this.encryptedFile),\n      envFile: fs.existsSync('.env'),\n      backupCount: 0\n    };\n    \n    // Contar backups\n    if (fs.existsSync(this.backupDir)) {\n      const backups = fs.readdirSync(this.backupDir);\n      stats.backupCount = backups.length;\n    }\n    \n    console.log(`ğŸ”‘ Arquivo de chave: ${stats.keyFile ? 'âœ… Presente' : 'âŒ Ausente'}`);\n    console.log(`ğŸ”’ Arquivo criptografado: ${stats.encryptedFile ? 'âœ… Presente' : 'âŒ Ausente'}`);\n    console.log(`ğŸ“„ Arquivo .env: ${stats.envFile ? 'âš ï¸  Presente (considere criptografar)' : 'âœ… Ausente (seguro)'}`);\n    console.log(`ğŸ’¾ Backups disponÃ­veis: ${stats.backupCount}`);\n    \n    // InformaÃ§Ãµes da chave\n    if (stats.keyFile) {\n      try {\n        const keyData = this.loadKey();\n        console.log(`\\nğŸ”‘ InformaÃ§Ãµes da Chave:`);\n        console.log(`   Algoritmo: ${keyData.algorithm}`);\n        console.log(`   VersÃ£o: ${keyData.version}`);\n        console.log(`   Criada em: ${keyData.created}`);\n      } catch (error) {\n        console.log(`\\nâŒ Erro ao ler chave: ${error.message}`);\n      }\n    }\n    \n    return stats;\n  }\n}\n\n// CLI Interface\nasync function main() {\n  const args = process.argv.slice(2);\n  const command = args[0];\n  \n  if (!command) {\n    console.log(`\nğŸ” Secure Environment Manager\n\nğŸ“‹ Comandos disponÃ­veis:\n\nğŸ”’ Criptografia:\n  encrypt                    - Criptografar arquivo .env\n  decrypt [output]           - Descriptografar para arquivo (padrÃ£o: .env.decrypted)\n  rotate                     - Rotacionar chaves de criptografia\n  \nğŸ” VerificaÃ§Ã£o:\n  verify                     - Verificar integridade dos arquivos\n  status                     - Mostrar status do sistema\n  \nğŸ§¹ ManutenÃ§Ã£o:\n  cleanup                    - Limpar arquivos temporÃ¡rios\n  \nğŸ“ Exemplos:\n  node secure-env-manager.cjs encrypt\n  node secure-env-manager.cjs decrypt\n  node secure-env-manager.cjs verify\n  node secure-env-manager.cjs status\n  \nâš ï¸  IMPORTANTE:\n  - Mantenha o arquivo .env.key seguro\n  - NÃ£o commite arquivos de chave\n  - FaÃ§a backup das chaves regularmente\n    `);\n    return;\n  }\n\n  const manager = new SecureEnvManager();\n  \n  try {\n    switch (command) {\n      case 'encrypt':\n        await manager.encrypt();\n        break;\n        \n      case 'decrypt':\n        const outputFile = args[1] || '.env.decrypted';\n        await manager.decrypt(outputFile);\n        break;\n        \n      case 'verify':\n        await manager.verify();\n        break;\n        \n      case 'rotate':\n        await manager.rotate();\n        break;\n        \n      case 'cleanup':\n        await manager.cleanup();\n        break;\n        \n      case 'status':\n        await manager.status();\n        break;\n        \n      default:\n        console.error(`âŒ Comando desconhecido: ${command}`);\n        console.log('ğŸ’¡ Use sem argumentos para ver a lista de comandos');\n        process.exit(1);\n    }\n    \n  } catch (error) {\n    console.error('âŒ Erro durante execuÃ§Ã£o:', error.message);\n    process.exit(1);\n  }\n}\n\n// Executar apenas se chamado diretamente\nif (require.main === module) {\n  main().catch(console.error);\n}\n\nmodule.exports = SecureEnvManager;"