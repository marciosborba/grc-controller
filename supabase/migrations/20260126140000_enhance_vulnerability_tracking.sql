-- Migration: Enhance Vulnerability Tracking
-- description: Adds assigned_to column and cycle time tracking triggers

-- 1. Add assigned_to column if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'vulnerabilities' AND column_name = 'assigned_to') THEN
        ALTER TABLE vulnerabilities ADD COLUMN assigned_to UUID REFERENCES auth.users(id);
    END IF;
END $$;

-- 2. Create history table if it doesn't exist
CREATE TABLE IF NOT EXISTS vulnerability_status_history (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    vulnerability_id UUID REFERENCES vulnerabilities(id) ON DELETE CASCADE,
    old_status VARCHAR(50),
    new_status VARCHAR(50) NOT NULL,
    changed_at TIMESTAMPTZ DEFAULT NOW(),
    changed_by UUID REFERENCES auth.users(id)
);

-- 3. Enable RLS on history table
ALTER TABLE vulnerability_status_history ENABLE ROW LEVEL SECURITY;

-- 4. RLS Policies for history
DO $$
BEGIN
    DROP POLICY IF EXISTS "Users can view history of their tenant" ON vulnerability_status_history;
    CREATE POLICY "Users can view history of their tenant" ON vulnerability_status_history
        FOR SELECT USING (
            vulnerability_id IN (
                SELECT id FROM vulnerabilities 
                WHERE tenant_id IN (
                    SELECT tenant_id FROM profiles WHERE id = auth.uid()
                )
            )
        );
END $$;

-- 5. Helper function to record status changes
CREATE OR REPLACE FUNCTION log_vulnerability_status_change()
RETURNS TRIGGER AS $$
BEGIN
    IF (OLD.status IS DISTINCT FROM NEW.status) THEN
        INSERT INTO vulnerability_status_history (
            vulnerability_id,
            old_status,
            new_status,
            changed_at,
            changed_by
        ) VALUES (
            NEW.id,
            OLD.status,
            NEW.status,
            NOW(),
            auth.uid()
        );
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6. Trigger for status changes
DROP TRIGGER IF EXISTS on_vulnerability_status_change ON vulnerabilities;
CREATE TRIGGER on_vulnerability_status_change
    AFTER UPDATE ON vulnerabilities
    FOR EACH ROW
    EXECUTE FUNCTION log_vulnerability_status_change();

-- 7. Backfill history for creation (optional but good for consistency)
-- This is tricky for existing records, but ensuring future creations are logged:
CREATE OR REPLACE FUNCTION log_vulnerability_creation()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO vulnerability_status_history (
        vulnerability_id,
        old_status,
        new_status,
        changed_at,
        changed_by
    ) VALUES (
        NEW.id,
        NULL,
        NEW.status,
        NOW(),
        auth.uid()
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_vulnerability_creation ON vulnerabilities;
CREATE TRIGGER on_vulnerability_creation
    AFTER INSERT ON vulnerabilities
    FOR EACH ROW
    EXECUTE FUNCTION log_vulnerability_creation();
