#!/usr/bin/env node\n\n/**\n * üß™ TESTES DO SISTEMA DE CRIPTOGRAFIA POR TENANT\n * \n * Suite completa de testes para validar o sistema de criptografia.\n * Testa performance, seguran√ßa, isolamento e funcionalidade.\n */\n\nconst { Client } = require('pg');\nconst crypto = require('crypto');\nrequire('dotenv').config();\n\n// Configura√ß√£o do banco\nconst dbConfig = {\n  host: 'db.myxvxponlmulnjstbjwd.supabase.co',\n  port: 5432,\n  database: 'postgres',\n  user: 'postgres',\n  password: process.env.SUPABASE_DB_PASSWORD,\n  ssl: { rejectUnauthorized: false }\n};\n\n// ============================================================================\n// UTILIT√ÅRIOS DE TESTE\n// ============================================================================\n\nclass TestRunner {\n  constructor() {\n    this.tests = [];\n    this.results = {\n      passed: 0,\n      failed: 0,\n      total: 0,\n      errors: []\n    };\n  }\n\n  addTest(name, testFn) {\n    this.tests.push({ name, testFn });\n  }\n\n  async runAll() {\n    console.log('üß™ Iniciando suite de testes de criptografia...\\n');\n    \n    for (const test of this.tests) {\n      try {\n        console.log(`üîÑ Executando: ${test.name}`);\n        const startTime = performance.now();\n        \n        await test.testFn();\n        \n        const endTime = performance.now();\n        const duration = Math.round(endTime - startTime);\n        \n        console.log(`‚úÖ ${test.name} - ${duration}ms`);\n        this.results.passed++;\n        \n      } catch (error) {\n        console.log(`‚ùå ${test.name} - FALHOU`);\n        console.log(`   Erro: ${error.message}`);\n        this.results.failed++;\n        this.results.errors.push({ test: test.name, error: error.message });\n      }\n      \n      this.results.total++;\n      console.log('');\n    }\n    \n    this.printSummary();\n  }\n\n  printSummary() {\n    console.log('='.repeat(80));\n    console.log('üìä RESUMO DOS TESTES');\n    console.log('='.repeat(80));\n    console.log(`Total: ${this.results.total}`);\n    console.log(`‚úÖ Passou: ${this.results.passed}`);\n    console.log(`‚ùå Falhou: ${this.results.failed}`);\n    console.log(`üìà Taxa de sucesso: ${((this.results.passed / this.results.total) * 100).toFixed(1)}%`);\n    \n    if (this.results.errors.length > 0) {\n      console.log('\\n‚ùå ERROS:');\n      this.results.errors.forEach(({ test, error }) => {\n        console.log(`   ‚Ä¢ ${test}: ${error}`);\n      });\n    }\n    \n    console.log('='.repeat(80));\n  }\n}\n\n// ============================================================================\n// TESTES DE FUNCIONALIDADE B√ÅSICA\n// ============================================================================\n\nasync function testBasicEncryption(client) {\n  const tenants = await client.query('SELECT id FROM tenants LIMIT 2');\n  \n  if (tenants.rows.length === 0) {\n    throw new Error('Nenhum tenant encontrado para teste');\n  }\n  \n  const tenantId = tenants.rows[0].id;\n  const testData = 'Dados confidenciais de teste - ' + crypto.randomBytes(16).toString('hex');\n  \n  // Teste de criptografia\n  const encryptResult = await client.query(`\n    SELECT encrypt_tenant_data($1, $2, 'general') as encrypted\n  `, [tenantId, testData]);\n  \n  const encrypted = encryptResult.rows[0].encrypted;\n  \n  if (!encrypted || encrypted === testData) {\n    throw new Error('Criptografia falhou ou retornou dados n√£o criptografados');\n  }\n  \n  // Teste de descriptografia\n  const decryptResult = await client.query(`\n    SELECT decrypt_tenant_data($1, $2, 'general') as decrypted\n  `, [tenantId, encrypted]);\n  \n  const decrypted = decryptResult.rows[0].decrypted;\n  \n  if (decrypted !== testData) {\n    throw new Error('Descriptografia falhou - dados n√£o coincidem');\n  }\n}\n\nasync function testTenantIsolation(client) {\n  const tenants = await client.query('SELECT id FROM tenants LIMIT 2');\n  \n  if (tenants.rows.length < 2) {\n    throw new Error('Pelo menos 2 tenants s√£o necess√°rios para teste de isolamento');\n  }\n  \n  const tenant1 = tenants.rows[0].id;\n  const tenant2 = tenants.rows[1].id;\n  const testData = 'Dados secretos do tenant 1';\n  \n  // Criptografar com tenant 1\n  const encryptResult = await client.query(`\n    SELECT encrypt_tenant_data($1, $2, 'general') as encrypted\n  `, [tenant1, testData]);\n  \n  const encrypted = encryptResult.rows[0].encrypted;\n  \n  // Tentar descriptografar com tenant 2 (deve falhar)\n  try {\n    await client.query(`\n      SELECT decrypt_tenant_data($1, $2, 'general') as decrypted\n    `, [tenant2, encrypted]);\n    \n    throw new Error('FALHA DE SEGURAN√áA: Tenant 2 conseguiu descriptografar dados do Tenant 1');\n  } catch (error) {\n    if (error.message.includes('FALHA DE SEGURAN√áA')) {\n      throw error;\n    }\n    // Erro esperado - isolamento funcionando\n  }\n}\n\nasync function testMultiplePurposes(client) {\n  const tenants = await client.query('SELECT id FROM tenants LIMIT 1');\n  const tenantId = tenants.rows[0].id;\n  \n  const purposes = ['general', 'pii', 'financial', 'audit', 'compliance'];\n  const testData = 'Dados para teste de prop√≥sitos m√∫ltiplos';\n  \n  for (const purpose of purposes) {\n    // Criptografar\n    const encryptResult = await client.query(`\n      SELECT encrypt_tenant_data($1, $2, $3) as encrypted\n    `, [tenantId, testData, purpose]);\n    \n    const encrypted = encryptResult.rows[0].encrypted;\n    \n    // Descriptografar\n    const decryptResult = await client.query(`\n      SELECT decrypt_tenant_data($1, $2, $3) as decrypted\n    `, [tenantId, encrypted, purpose]);\n    \n    const decrypted = decryptResult.rows[0].decrypted;\n    \n    if (decrypted !== testData) {\n      throw new Error(`Falha na criptografia para prop√≥sito: ${purpose}`);\n    }\n  }\n}\n\n// ============================================================================\n// TESTES DE PERFORMANCE\n// ============================================================================\n\nasync function testEncryptionPerformance(client) {\n  const tenants = await client.query('SELECT id FROM tenants LIMIT 1');\n  const tenantId = tenants.rows[0].id;\n  \n  const testSizes = [\n    { name: 'Pequeno (100 chars)', data: 'x'.repeat(100) },\n    { name: 'M√©dio (1KB)', data: 'x'.repeat(1024) },\n    { name: 'Grande (10KB)', data: 'x'.repeat(10240) },\n    { name: 'Muito Grande (100KB)', data: 'x'.repeat(102400) }\n  ];\n  \n  console.log('   üìä Testando performance por tamanho:');\n  \n  for (const test of testSizes) {\n    const iterations = test.data.length > 10000 ? 5 : 10;\n    const times = [];\n    \n    for (let i = 0; i < iterations; i++) {\n      const startTime = performance.now();\n      \n      await client.query(`\n        SELECT encrypt_tenant_data($1, $2, 'general') as encrypted\n      `, [tenantId, test.data]);\n      \n      const endTime = performance.now();\n      times.push(endTime - startTime);\n    }\n    \n    const avgTime = times.reduce((a, b) => a + b, 0) / times.length;\n    const maxTime = Math.max(...times);\n    \n    console.log(`     ‚Ä¢ ${test.name}: ${avgTime.toFixed(1)}ms avg, ${maxTime.toFixed(1)}ms max`);\n    \n    if (avgTime > 1000) { // 1 segundo\n      throw new Error(`Performance muito lenta para ${test.name}: ${avgTime.toFixed(1)}ms`);\n    }\n  }\n}\n\nasync function testConcurrentOperations(client) {\n  const tenants = await client.query('SELECT id FROM tenants LIMIT 1');\n  const tenantId = tenants.rows[0].id;\n  \n  const concurrentOps = 10;\n  const testData = 'Dados para teste de concorr√™ncia';\n  \n  console.log(`   üîÑ Testando ${concurrentOps} opera√ß√µes concorrentes...`);\n  \n  const promises = [];\n  \n  for (let i = 0; i < concurrentOps; i++) {\n    const promise = client.query(`\n      SELECT \n        encrypt_tenant_data($1, $2, 'general') as encrypted,\n        decrypt_tenant_data($1, encrypt_tenant_data($1, $2, 'general'), 'general') as decrypted\n    `, [tenantId, testData + i]);\n    \n    promises.push(promise);\n  }\n  \n  const startTime = performance.now();\n  const results = await Promise.all(promises);\n  const endTime = performance.now();\n  \n  const totalTime = endTime - startTime;\n  const avgTimePerOp = totalTime / concurrentOps;\n  \n  console.log(`     ‚Ä¢ Tempo total: ${totalTime.toFixed(1)}ms`);\n  console.log(`     ‚Ä¢ Tempo m√©dio por opera√ß√£o: ${avgTimePerOp.toFixed(1)}ms`);\n  \n  // Verificar se todos os resultados est√£o corretos\n  results.forEach((result, index) => {\n    const expected = testData + index;\n    const actual = result.rows[0].decrypted;\n    \n    if (actual !== expected) {\n      throw new Error(`Falha na opera√ß√£o concorrente ${index}: esperado '${expected}', obtido '${actual}'`);\n    }\n  });\n}\n\n// ============================================================================\n// TESTES DE AUDITORIA\n// ============================================================================\n\nasync function testAuditLogging(client) {\n  const tenants = await client.query('SELECT id FROM tenants LIMIT 1');\n  const tenantId = tenants.rows[0].id;\n  \n  // Limpar logs antigos para este teste\n  await client.query(`\n    DELETE FROM crypto_audit_log \n    WHERE tenant_id = $1 AND created_at > NOW() - INTERVAL '1 minute'\n  `, [tenantId]);\n  \n  const testData = 'Dados para teste de auditoria';\n  \n  // Executar opera√ß√µes que devem gerar logs\n  await client.query(`\n    SELECT encrypt_tenant_data($1, $2, 'general')\n  `, [tenantId, testData]);\n  \n  await client.query(`\n    SELECT decrypt_tenant_data($1, encrypt_tenant_data($1, $2, 'general'), 'general')\n  `, [tenantId, testData]);\n  \n  // Verificar se logs foram criados\n  const auditResult = await client.query(`\n    SELECT operation_type, success, performance_ms\n    FROM crypto_audit_log \n    WHERE tenant_id = $1 AND created_at > NOW() - INTERVAL '1 minute'\n    ORDER BY created_at DESC\n  `, [tenantId]);\n  \n  if (auditResult.rows.length < 2) {\n    throw new Error(`Logs de auditoria insuficientes: esperado >= 2, encontrado ${auditResult.rows.length}`);\n  }\n  \n  // Verificar se todas as opera√ß√µes foram bem-sucedidas\n  const failedOps = auditResult.rows.filter(row => !row.success);\n  if (failedOps.length > 0) {\n    throw new Error(`Opera√ß√µes falharam na auditoria: ${failedOps.length}`);\n  }\n  \n  console.log(`     ‚Ä¢ ${auditResult.rows.length} entradas de auditoria criadas`);\n  \n  const avgPerformance = auditResult.rows\n    .filter(row => row.performance_ms)\n    .reduce((sum, row) => sum + row.performance_ms, 0) / auditResult.rows.length;\n  \n  console.log(`     ‚Ä¢ Performance m√©dia: ${avgPerformance.toFixed(1)}ms`);\n}\n\n// ============================================================================\n// TESTES DE ROTA√á√ÉO DE CHAVES\n// ============================================================================\n\nasync function testKeyRotation(client) {\n  const tenants = await client.query('SELECT id FROM tenants LIMIT 1');\n  const tenantId = tenants.rows[0].id;\n  \n  // Obter vers√£o atual da chave\n  const currentKeyResult = await client.query(`\n    SELECT encryption_version \n    FROM tenant_crypto_keys \n    WHERE tenant_id = $1 AND key_purpose = 'general' AND is_active = true\n  `, [tenantId]);\n  \n  const currentVersion = currentKeyResult.rows[0].encryption_version;\n  \n  // Criptografar dados com chave atual\n  const testData = 'Dados para teste de rota√ß√£o de chave';\n  const encryptResult = await client.query(`\n    SELECT encrypt_tenant_data($1, $2, 'general') as encrypted\n  `, [tenantId, testData]);\n  \n  const encryptedWithOldKey = encryptResult.rows[0].encrypted;\n  \n  // Rotacionar chave\n  await client.query(`\n    SELECT rotate_tenant_key($1, 'general', 'test_rotation')\n  `, [tenantId]);\n  \n  // Verificar nova vers√£o\n  const newKeyResult = await client.query(`\n    SELECT encryption_version \n    FROM tenant_crypto_keys \n    WHERE tenant_id = $1 AND key_purpose = 'general' AND is_active = true\n  `, [tenantId]);\n  \n  const newVersion = newKeyResult.rows[0].encryption_version;\n  \n  if (newVersion !== currentVersion + 1) {\n    throw new Error(`Vers√£o da chave n√£o incrementou: esperado ${currentVersion + 1}, obtido ${newVersion}`);\n  }\n  \n  // Verificar se ainda consegue descriptografar dados antigos\n  // (Nota: Em implementa√ß√£o real, isso pode n√£o funcionar dependendo da estrat√©gia)\n  try {\n    await client.query(`\n      SELECT decrypt_tenant_data($1, $2, 'general')\n    `, [tenantId, encryptedWithOldKey]);\n    \n    console.log('     ‚ö†Ô∏è Dados antigos ainda podem ser descriptografados (implementar migra√ß√£o)');\n  } catch (error) {\n    console.log('     ‚úì Dados antigos n√£o podem ser descriptografados com nova chave');\n  }\n  \n  // Testar criptografia com nova chave\n  const newEncryptResult = await client.query(`\n    SELECT encrypt_tenant_data($1, $2, 'general') as encrypted\n  `, [tenantId, testData]);\n  \n  const encryptedWithNewKey = newEncryptResult.rows[0].encrypted;\n  \n  if (encryptedWithNewKey === encryptedWithOldKey) {\n    throw new Error('Nova chave produziu o mesmo resultado que a chave antiga');\n  }\n  \n  // Verificar descriptografia com nova chave\n  const decryptResult = await client.query(`\n    SELECT decrypt_tenant_data($1, $2, 'general') as decrypted\n  `, [tenantId, encryptedWithNewKey]);\n  \n  if (decryptResult.rows[0].decrypted !== testData) {\n    throw new Error('Falha na descriptografia com nova chave');\n  }\n  \n  console.log(`     ‚Ä¢ Chave rotacionada: v${currentVersion} ‚Üí v${newVersion}`);\n}\n\n// ============================================================================\n// TESTES DE SEGURAN√áA\n// ============================================================================\n\nasync function testDataIntegrity(client) {\n  const tenants = await client.query('SELECT id FROM tenants LIMIT 1');\n  const tenantId = tenants.rows[0].id;\n  \n  const testData = 'Dados para teste de integridade';\n  \n  // Criptografar dados\n  const encryptResult = await client.query(`\n    SELECT encrypt_tenant_data($1, $2, 'general') as encrypted\n  `, [tenantId, testData]);\n  \n  let encrypted = encryptResult.rows[0].encrypted;\n  \n  // Corromper dados (alterar um caractere)\n  const corruptedData = encrypted.slice(0, -5) + 'XXXXX';\n  \n  // Tentar descriptografar dados corrompidos\n  try {\n    await client.query(`\n      SELECT decrypt_tenant_data($1, $2, 'general')\n    `, [tenantId, corruptedData]);\n    \n    throw new Error('FALHA DE SEGURAN√áA: Dados corrompidos foram descriptografados com sucesso');\n  } catch (error) {\n    if (error.message.includes('FALHA DE SEGURAN√áA')) {\n      throw error;\n    }\n    // Erro esperado - integridade funcionando\n    console.log('     ‚úì Dados corrompidos rejeitados corretamente');\n  }\n}\n\nasync function testInvalidInputs(client) {\n  const tenants = await client.query('SELECT id FROM tenants LIMIT 1');\n  const tenantId = tenants.rows[0].id;\n  \n  const invalidTests = [\n    {\n      name: 'Tenant ID inv√°lido',\n      tenantId: '00000000-0000-0000-0000-000000000000',\n      data: 'teste',\n      purpose: 'general'\n    },\n    {\n      name: 'Prop√≥sito inv√°lido',\n      tenantId: tenantId,\n      data: 'teste',\n      purpose: 'invalid_purpose'\n    },\n    {\n      name: 'Dados vazios',\n      tenantId: tenantId,\n      data: '',\n      purpose: 'general'\n    }\n  ];\n  \n  for (const test of invalidTests) {\n    try {\n      await client.query(`\n        SELECT encrypt_tenant_data($1, $2, $3)\n      `, [test.tenantId, test.data, test.purpose]);\n      \n      throw new Error(`FALHA DE VALIDA√á√ÉO: ${test.name} foi aceito`);\n    } catch (error) {\n      if (error.message.includes('FALHA DE VALIDA√á√ÉO')) {\n        throw error;\n      }\n      // Erro esperado - valida√ß√£o funcionando\n    }\n  }\n  \n  console.log('     ‚úì Todas as valida√ß√µes de entrada funcionaram');\n}\n\n// ============================================================================\n// FUN√á√ÉO PRINCIPAL\n// ============================================================================\n\nasync function main() {\n  const client = new Client(dbConfig);\n  const testRunner = new TestRunner();\n  \n  try {\n    await client.connect();\n    console.log('‚úÖ Conectado ao banco de dados\\n');\n    \n    // Adicionar todos os testes\n    testRunner.addTest('Criptografia B√°sica', () => testBasicEncryption(client));\n    testRunner.addTest('Isolamento entre Tenants', () => testTenantIsolation(client));\n    testRunner.addTest('M√∫ltiplos Prop√≥sitos', () => testMultiplePurposes(client));\n    testRunner.addTest('Performance de Criptografia', () => testEncryptionPerformance(client));\n    testRunner.addTest('Opera√ß√µes Concorrentes', () => testConcurrentOperations(client));\n    testRunner.addTest('Log de Auditoria', () => testAuditLogging(client));\n    testRunner.addTest('Rota√ß√£o de Chaves', () => testKeyRotation(client));\n    testRunner.addTest('Integridade de Dados', () => testDataIntegrity(client));\n    testRunner.addTest('Valida√ß√£o de Entradas', () => testInvalidInputs(client));\n    \n    // Executar todos os testes\n    await testRunner.runAll();\n    \n  } catch (error) {\n    console.error('‚ùå Erro durante os testes:', error.message);\n    process.exit(1);\n    \n  } finally {\n    await client.end();\n    console.log('üîå Desconectado do banco de dados');\n  }\n}\n\n// ============================================================================\n// EXECU√á√ÉO\n// ============================================================================\n\nif (require.main === module) {\n  main().catch(console.error);\n}\n\nmodule.exports = {\n  main,\n  TestRunner,\n  testBasicEncryption,\n  testTenantIsolation,\n  testEncryptionPerformance\n};\n"