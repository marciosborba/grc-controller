#!/usr/bin/env node\n\n/**\n * üîê Secure Database Manager - Executor seguro de comandos PostgreSQL\n * \n * Vers√£o segura com:\n * - Autentica√ß√£o obrigat√≥ria\n * - Valida√ß√£o de entrada\n * - Logs de auditoria\n * - Rate limiting\n * - SSL seguro\n * \n * Uso: node database-manager-secure.cjs [comando] [argumentos]\n */\n\nconst { Client } = require('pg');\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst path = require('path');\nconst readline = require('readline');\nrequire('dotenv').config();\n\nclass SecureLogger {\n  constructor() {\n    this.logDir = 'logs';\n    this.logFile = path.join(this.logDir, 'database-audit.log');\n    this.sensitiveFields = ['password', 'key', 'token', 'secret'];\n    \n    // Criar diret√≥rio de logs se n√£o existir\n    if (!fs.existsSync(this.logDir)) {\n      fs.mkdirSync(this.logDir, { recursive: true });\n    }\n  }\n\n  sanitizeLogData(data) {\n    if (typeof data !== 'object' || data === null) {\n      return data;\n    }\n    \n    const sanitized = { ...data };\n    this.sensitiveFields.forEach(field => {\n      Object.keys(sanitized).forEach(key => {\n        if (key.toLowerCase().includes(field)) {\n          sanitized[key] = '***REDACTED***';\n        }\n      });\n    });\n    return sanitized;\n  }\n\n  log(level, message, data = {}) {\n    const logEntry = {\n      timestamp: new Date().toISOString(),\n      level: level.toUpperCase(),\n      message,\n      data: this.sanitizeLogData(data),\n      user: process.env.USER || 'unknown',\n      pid: process.pid,\n      session: this.getSessionId()\n    };\n    \n    const logLine = JSON.stringify(logEntry) + '\\n';\n    \n    try {\n      fs.appendFileSync(this.logFile, logLine);\n    } catch (error) {\n      console.error('‚ùå Erro ao escrever log:', error.message);\n    }\n    \n    // Tamb√©m exibir no console com cores\n    const colors = {\n      INFO: '\\x1b[36m',    // Cyan\n      WARN: '\\x1b[33m',    // Yellow\n      ERROR: '\\x1b[31m',   // Red\n      SUCCESS: '\\x1b[32m', // Green\n      RESET: '\\x1b[0m'\n    };\n    \n    const color = colors[level.toUpperCase()] || colors.RESET;\n    console.log(`${color}[${level.toUpperCase()}]${colors.RESET} ${message}`);\n  }\n\n  getSessionId() {\n    if (!this.sessionId) {\n      this.sessionId = crypto.randomBytes(8).toString('hex');\n    }\n    return this.sessionId;\n  }\n}\n\nclass NetworkSecurity {\n  constructor() {\n    this.rateLimiter = new Map();\n    this.maxAttempts = 5;\n    this.windowMs = 900000; // 15 minutos\n    this.blockedIPs = new Set();\n  }\n\n  checkRateLimit(identifier = 'default') {\n    const now = Date.now();\n    const attempts = this.rateLimiter.get(identifier) || [];\n    \n    // Limpar tentativas antigas\n    const recentAttempts = attempts.filter(time => \n      now - time < this.windowMs\n    );\n    \n    if (recentAttempts.length >= this.maxAttempts) {\n      this.blockedIPs.add(identifier);\n      throw new Error(`Rate limit exceeded for ${identifier}. Try again in 15 minutes.`);\n    }\n    \n    recentAttempts.push(now);\n    this.rateLimiter.set(identifier, recentAttempts);\n  }\n\n  isBlocked(identifier) {\n    return this.blockedIPs.has(identifier);\n  }\n}\n\nclass DatabaseAuth {\n  constructor(logger) {\n    this.logger = logger;\n    this.sessionFile = '.db-session';\n    this.sessionTimeout = 3600000; // 1 hora\n    this.maxFailedAttempts = 3;\n    this.failedAttempts = 0;\n  }\n\n  async authenticate() {\n    // Verificar se h√° sess√£o v√°lida\n    if (this.hasValidSession()) {\n      this.logger.log('info', 'Sess√£o v√°lida encontrada');\n      return true;\n    }\n\n    this.logger.log('info', 'Iniciando processo de autentica√ß√£o');\n    \n    // Solicitar autentica√ß√£o\n    for (let attempt = 1; attempt <= this.maxFailedAttempts; attempt++) {\n      try {\n        const password = await this.promptPassword(`Tentativa ${attempt}/${this.maxFailedAttempts} - Digite a senha do database manager: `);\n        \n        if (this.validatePassword(password)) {\n          this.createSession();\n          this.logger.log('success', 'Autentica√ß√£o bem-sucedida');\n          return true;\n        } else {\n          this.logger.log('warn', `Tentativa de autentica√ß√£o falhou (${attempt}/${this.maxFailedAttempts})`);\n          console.log(`‚ùå Senha incorreta. Tentativas restantes: ${this.maxFailedAttempts - attempt}`);\n        }\n      } catch (error) {\n        this.logger.log('error', 'Erro durante autentica√ß√£o', { error: error.message });\n        throw error;\n      }\n    }\n\n    this.logger.log('error', 'M√°ximo de tentativas de autentica√ß√£o excedido');\n    throw new Error('Autentica√ß√£o falhou ap√≥s m√∫ltiplas tentativas');\n  }\n\n  validatePassword(password) {\n    // Hash da senha com salt\n    const salt = process.env.DB_AUTH_SALT || 'default-salt-change-me';\n    const hash = crypto.createHash('sha256')\n      .update(password + salt)\n      .digest('hex');\n\n    const expectedHash = process.env.DB_AUTH_HASH || \n      crypto.createHash('sha256').update('admin123' + salt).digest('hex'); // Senha padr√£o\n\n    return hash === expectedHash;\n  }\n\n  async promptPassword(message) {\n    const rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout\n    });\n\n    return new Promise((resolve) => {\n      rl.question(message, (password) => {\n        rl.close();\n        resolve(password);\n      });\n    });\n  }\n\n  hasValidSession() {\n    try {\n      if (!fs.existsSync(this.sessionFile)) {\n        return false;\n      }\n      \n      const session = JSON.parse(fs.readFileSync(this.sessionFile, 'utf8'));\n      const isValid = Date.now() - session.created < this.sessionTimeout;\n      \n      if (!isValid) {\n        fs.unlinkSync(this.sessionFile);\n      }\n      \n      return isValid;\n    } catch {\n      return false;\n    }\n  }\n\n  createSession() {\n    const session = {\n      created: Date.now(),\n      user: process.env.USER || 'unknown',\n      pid: process.pid\n    };\n    \n    fs.writeFileSync(this.sessionFile, JSON.stringify(session), { mode: 0o600 });\n  }\n\n  destroySession() {\n    if (fs.existsSync(this.sessionFile)) {\n      fs.unlinkSync(this.sessionFile);\n    }\n  }\n}\n\nclass SQLValidator {\n  constructor(logger) {\n    this.logger = logger;\n    this.dangerousCommands = [\n      'DROP', 'DELETE', 'TRUNCATE', 'UPDATE',\n      'INSERT', 'CREATE USER', 'GRANT', 'REVOKE',\n      'ALTER USER', 'DROP USER'\n    ];\n    this.allowedCommands = [\n      'SELECT', 'ALTER TABLE', 'CREATE TABLE',\n      'CREATE INDEX', 'COMMENT ON'\n    ];\n  }\n\n  validateSQL(sql) {\n    const upperSQL = sql.toUpperCase().trim();\n    \n    // Verificar comandos perigosos\n    const hasDangerous = this.dangerousCommands.some(cmd => \n      upperSQL.includes(cmd)\n    );\n    \n    if (hasDangerous) {\n      const foundCommand = this.dangerousCommands.find(cmd => upperSQL.includes(cmd));\n      this.logger.log('warn', `Comando perigoso detectado: ${foundCommand}`, { sql });\n      \n      // Permitir apenas se for explicitamente autorizado\n      if (!this.isExplicitlyAuthorized(upperSQL)) {\n        throw new Error(`Comando n√£o autorizado: ${foundCommand}`);\n      }\n    }\n    \n    // Verificar inje√ß√£o SQL b√°sica\n    this.checkSQLInjection(sql);\n    \n    this.logger.log('info', 'SQL validado com sucesso', { sqlLength: sql.length });\n  }\n\n  checkSQLInjection(sql) {\n    const injectionPatterns = [\n      /;\\s*(DROP|DELETE|UPDATE|INSERT)/i,\n      /UNION\\s+SELECT/i,\n      /--\\s*$/,\n      /\\/\\*.*\\*\\//,\n      /\\bOR\\s+1=1/i,\n      /\\bAND\\s+1=1/i\n    ];\n    \n    const foundPattern = injectionPatterns.find(pattern => pattern.test(sql));\n    if (foundPattern) {\n      this.logger.log('error', 'Poss√≠vel tentativa de SQL injection detectada', { pattern: foundPattern.toString() });\n      throw new Error('Padr√£o de SQL injection detectado');\n    }\n  }\n\n  isExplicitlyAuthorized(sql) {\n    // Comandos que s√£o permitidos mesmo sendo \"perigosos\"\n    const authorizedPatterns = [\n      /ALTER TABLE \\w+ ADD COLUMN/i,\n      /CREATE INDEX/i,\n      /UPDATE \\w+ SET settings/i // Permitir updates na coluna settings\n    ];\n    \n    return authorizedPatterns.some(pattern => pattern.test(sql));\n  }\n\n  sanitizeInput(input) {\n    if (typeof input !== 'string') {\n      return input;\n    }\n    \n    // Remover caracteres potencialmente perigosos\n    return input.replace(/[;'\"\\\\]/g, '');\n  }\n}\n\nclass SecureDatabaseManager {\n  constructor() {\n    this.logger = new SecureLogger();\n    this.networkSecurity = new NetworkSecurity();\n    this.auth = new DatabaseAuth(this.logger);\n    this.validator = new SQLValidator(this.logger);\n    \n    // Configura√ß√£o segura da conex√£o PostgreSQL\n    this.config = {\n      host: 'db.myxvxponlmulnjstbjwd.supabase.co',\n      port: 5432,\n      database: 'postgres',\n      user: 'postgres',\n      password: process.env.SUPABASE_DB_PASSWORD,\n      ssl: {\n        rejectUnauthorized: true,\n        // Adicionar certificado CA se dispon√≠vel\n        // ca: fs.readFileSync('supabase-ca-cert.pem')\n      },\n      connectionTimeoutMillis: 10000,\n      idleTimeoutMillis: 30000,\n      max: 1 // M√°ximo 1 conex√£o por inst√¢ncia\n    };\n    \n    this.client = null;\n    this.isAuthenticated = false;\n  }\n\n  async initialize() {\n    try {\n      // Verificar rate limiting\n      this.networkSecurity.checkRateLimit(process.env.USER || 'unknown');\n      \n      // Autenticar\n      await this.auth.authenticate();\n      this.isAuthenticated = true;\n      \n      this.logger.log('success', 'Database Manager inicializado com seguran√ßa');\n    } catch (error) {\n      this.logger.log('error', 'Falha na inicializa√ß√£o', { error: error.message });\n      throw error;\n    }\n  }\n\n  async connect() {\n    if (!this.isAuthenticated) {\n      throw new Error('Autentica√ß√£o necess√°ria antes de conectar');\n    }\n    \n    try {\n      this.client = new Client(this.config);\n      await this.client.connect();\n      \n      this.logger.log('success', 'Conectado ao PostgreSQL do Supabase');\n      return true;\n    } catch (error) {\n      this.logger.log('error', 'Erro ao conectar ao banco', { error: error.message });\n      throw new Error(`Erro de conex√£o: ${error.message}`);\n    }\n  }\n\n  async disconnect() {\n    if (this.client) {\n      await this.client.end();\n      this.logger.log('info', 'Desconectado do PostgreSQL');\n    }\n  }\n\n  async executeSQL(sql, description = '') {\n    if (!this.client) {\n      throw new Error('Conex√£o n√£o estabelecida');\n    }\n    \n    // Validar SQL\n    this.validator.validateSQL(sql);\n    \n    try {\n      this.logger.log('info', `Executando SQL: ${description || 'comando customizado'}`, {\n        sqlLength: sql.length,\n        description\n      });\n      \n      const startTime = Date.now();\n      const result = await this.client.query(sql);\n      const duration = Date.now() - startTime;\n      \n      this.logger.log('success', 'SQL executado com sucesso', {\n        rowCount: result.rowCount || 0,\n        duration: `${duration}ms`,\n        description\n      });\n      \n      return result;\n    } catch (error) {\n      this.logger.log('error', 'Erro na execu√ß√£o SQL', {\n        error: error.message,\n        description,\n        sqlLength: sql.length\n      });\n      throw error;\n    }\n  }\n\n  async testConnection() {\n    try {\n      const result = await this.client.query('SELECT version();');\n      this.logger.log('success', 'Teste de conex√£o bem-sucedido', {\n        version: result.rows[0].version.substring(0, 50) + '...'\n      });\n      \n      // Testar acesso √† tabela tenants\n      const tenants = await this.client.query('SELECT COUNT(*) FROM tenants;');\n      this.logger.log('success', 'Acesso √† tabela tenants confirmado', {\n        count: tenants.rows[0].count\n      });\n      \n      return true;\n    } catch (error) {\n      this.logger.log('error', 'Teste de conex√£o falhou', { error: error.message });\n      return false;\n    }\n  }\n\n  async addColumn(table, column, type, defaultValue = null) {\n    // Sanitizar entradas\n    table = this.validator.sanitizeInput(table);\n    column = this.validator.sanitizeInput(column);\n    type = this.validator.sanitizeInput(type);\n    \n    // Verificar se coluna j√° existe\n    const exists = await this.columnExists(table, column);\n    if (exists) {\n      this.logger.log('info', `Coluna ${column} j√° existe na tabela ${table}`);\n      return;\n    }\n\n    const defaultClause = defaultValue ? ` DEFAULT ${defaultValue}` : '';\n    const sql = `ALTER TABLE ${table} ADD COLUMN ${column} ${type}${defaultClause};`;\n    \n    return this.executeSQL(sql, `Adicionando coluna ${column} √† tabela ${table}`);\n  }\n\n  async columnExists(tableName, columnName) {\n    const sql = `\n      SELECT EXISTS (\n        SELECT FROM information_schema.columns \n        WHERE table_name = $1 AND column_name = $2\n      );\n    `;\n    const result = await this.client.query(sql, [tableName, columnName]);\n    return result.rows[0].exists;\n  }\n\n  async showTableStructure(tableName) {\n    tableName = this.validator.sanitizeInput(tableName);\n    \n    const sql = `\n      SELECT \n        column_name,\n        data_type,\n        is_nullable,\n        column_default\n      FROM information_schema.columns \n      WHERE table_name = $1\n      ORDER BY ordinal_position;\n    `;\n    \n    const result = await this.client.query(sql, [tableName]);\n    \n    this.logger.log('info', `Estrutura da tabela ${tableName} consultada`, {\n      columnCount: result.rows.length\n    });\n    \n    console.log(`\\nüìã Estrutura da tabela ${tableName}:`);\n    console.table(result.rows);\n    \n    return result.rows;\n  }\n\n  async backupTable(tableName) {\n    tableName = this.validator.sanitizeInput(tableName);\n    \n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);\n    const backupName = `${tableName}_backup_${timestamp}`;\n    \n    const sql = `CREATE TABLE ${backupName} AS SELECT * FROM ${tableName};`;\n    await this.executeSQL(sql, `Criando backup da tabela ${tableName}`);\n    \n    this.logger.log('success', 'Backup criado com sucesso', {\n      originalTable: tableName,\n      backupTable: backupName\n    });\n    \n    return backupName;\n  }\n\n  // M√©todo para limpar sess√£o\n  cleanup() {\n    this.auth.destroySession();\n    this.logger.log('info', 'Sess√£o limpa');\n  }\n}\n\n// CLI Interface\nasync function main() {\n  const args = process.argv.slice(2);\n  const command = args[0];\n  \n  if (!command) {\n    console.log(`\nüîê Secure Database Manager - Comandos dispon√≠veis:\n\nüìã Informa√ß√µes:\n  test-connection              - Testar conex√£o com o banco\n  show-structure <table>       - Mostrar estrutura de uma tabela\n  \nüîß Altera√ß√µes de Schema:\n  add-column <table> <column> <type> [default]  - Adicionar coluna\n  execute-sql \"<sql>\"                           - Executar SQL customizado\n  \nüè¢ Comandos Espec√≠ficos GRC:\n  backup-table <table>         - Criar backup de uma tabela\n  \nüîê Seguran√ßa:\n  cleanup                      - Limpar sess√£o e arquivos tempor√°rios\n  \nüìù Exemplos:\n  node database-manager-secure.cjs test-connection\n  node database-manager-secure.cjs add-column tenants settings JSONB '{}'\n  node database-manager-secure.cjs show-structure tenants\n  \nüîí Recursos de Seguran√ßa:\n  ‚úÖ Autentica√ß√£o obrigat√≥ria\n  ‚úÖ Valida√ß√£o de entrada SQL\n  ‚úÖ Logs de auditoria\n  ‚úÖ Rate limiting\n  ‚úÖ SSL seguro\n  ‚úÖ Sanitiza√ß√£o de entrada\n  \n‚ö†Ô∏è  Configure DB_AUTH_HASH e DB_AUTH_SALT no .env para seguran√ßa\n    `);\n    return;\n  }\n\n  const db = new SecureDatabaseManager();\n  \n  try {\n    // Inicializar com seguran√ßa\n    await db.initialize();\n    \n    // Conectar ao banco\n    const connected = await db.connect();\n    if (!connected) {\n      console.error('‚ùå N√£o foi poss√≠vel conectar ao banco de dados');\n      process.exit(1);\n    }\n\n    switch (command) {\n      case 'test-connection':\n        await db.testConnection();\n        break;\n        \n      case 'add-column':\n        const [table, column, type, defaultValue] = args.slice(1);\n        if (!table || !column || !type) {\n          console.error('‚ùå Uso: add-column <table> <column> <type> [default]');\n          process.exit(1);\n        }\n        await db.addColumn(table, column, type, defaultValue);\n        break;\n        \n      case 'execute-sql':\n        const sql = args[1];\n        if (!sql) {\n          console.error('‚ùå Uso: execute-sql \"<sql>\"');\n          process.exit(1);\n        }\n        await db.executeSQL(sql, 'SQL customizado');\n        break;\n        \n      case 'show-structure':\n        const tableName = args[1];\n        if (!tableName) {\n          console.error('‚ùå Uso: show-structure <table>');\n          process.exit(1);\n        }\n        await db.showTableStructure(tableName);\n        break;\n        \n      case 'backup-table':\n        const backupTable = args[1];\n        if (!backupTable) {\n          console.error('‚ùå Uso: backup-table <table>');\n          process.exit(1);\n        }\n        await db.backupTable(backupTable);\n        break;\n        \n      case 'cleanup':\n        db.cleanup();\n        console.log('‚úÖ Limpeza conclu√≠da');\n        break;\n        \n      default:\n        console.error(`‚ùå Comando desconhecido: ${command}`);\n        console.log('üí° Use sem argumentos para ver a lista de comandos');\n        process.exit(1);\n    }\n    \n  } catch (error) {\n    console.error('‚ùå Erro durante execu√ß√£o:', error.message);\n    process.exit(1);\n  } finally {\n    await db.disconnect();\n  }\n}\n\n// Executar apenas se chamado diretamente\nif (require.main === module) {\n  main().catch(console.error);\n}\n\nmodule.exports = SecureDatabaseManager;"