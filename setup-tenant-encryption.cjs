#!/usr/bin/env node\n\n/**\n * üîê SETUP DO SISTEMA DE CRIPTOGRAFIA POR TENANT\n * \n * Script para implementar o sistema completo de criptografia por tenant.\n * Executa todas as etapas necess√°rias para configurar a seguran√ßa.\n */\n\nconst { Client } = require('pg');\nconst fs = require('fs');\nconst path = require('path');\nrequire('dotenv').config();\n\n// Configura√ß√£o do banco\nconst dbConfig = {\n  host: 'db.myxvxponlmulnjstbjwd.supabase.co',\n  port: 5432,\n  database: 'postgres',\n  user: 'postgres',\n  password: process.env.SUPABASE_DB_PASSWORD,\n  ssl: { rejectUnauthorized: false }\n};\n\n// ============================================================================\n// FUN√á√ïES UTILIT√ÅRIAS\n// ============================================================================\n\nfunction log(message, type = 'info') {\n  const timestamp = new Date().toISOString();\n  const icons = {\n    info: '‚ÑπÔ∏è',\n    success: '‚úÖ',\n    warning: '‚ö†Ô∏è',\n    error: '‚ùå',\n    progress: 'üîÑ'\n  };\n  \n  console.log(`${icons[type]} [${timestamp}] ${message}`);\n}\n\nfunction logSection(title) {\n  console.log('\\n' + '='.repeat(80));\n  console.log(`üîê ${title}`);\n  console.log('='.repeat(80));\n}\n\nasync function executeSQL(client, sql, description) {\n  try {\n    log(`Executando: ${description}`, 'progress');\n    const result = await client.query(sql);\n    log(`‚úì ${description} - ${result.rowCount || 0} linhas afetadas`, 'success');\n    return result;\n  } catch (error) {\n    log(`‚úó Erro em ${description}: ${error.message}`, 'error');\n    throw error;\n  }\n}\n\nasync function checkPrerequisites(client) {\n  logSection('VERIFICA√á√ÉO DE PR√â-REQUISITOS');\n  \n  // Verificar extens√µes\n  const extensions = await client.query(`\n    SELECT extname FROM pg_extension \n    WHERE extname IN ('pgcrypto', 'uuid-ossp')\n  `);\n  \n  log(`Extens√µes encontradas: ${extensions.rows.map(r => r.extname).join(', ')}`);\n  \n  // Verificar tabela tenants\n  const tenants = await client.query(`\n    SELECT COUNT(*) as count FROM information_schema.tables \n    WHERE table_name = 'tenants' AND table_schema = 'public'\n  `);\n  \n  if (tenants.rows[0].count === '0') {\n    throw new Error('Tabela tenants n√£o encontrada. Execute primeiro a migra√ß√£o de tenant_id.');\n  }\n  \n  log('‚úì Tabela tenants encontrada');\n  \n  // Verificar tenants existentes\n  const tenantCount = await client.query('SELECT COUNT(*) as count FROM tenants');\n  log(`Tenants existentes: ${tenantCount.rows[0].count}`);\n  \n  return {\n    extensionsOk: extensions.rows.length >= 2,\n    tenantsTable: true,\n    tenantCount: parseInt(tenantCount.rows[0].count)\n  };\n}\n\nasync function implementEncryptionSchema(client) {\n  logSection('IMPLEMENTA√á√ÉO DO SCHEMA DE CRIPTOGRAFIA');\n  \n  const sqlFile = path.join(__dirname, 'sql', '002_tenant_encryption_system.sql');\n  \n  if (!fs.existsSync(sqlFile)) {\n    throw new Error(`Arquivo SQL n√£o encontrado: ${sqlFile}`);\n  }\n  \n  const sql = fs.readFileSync(sqlFile, 'utf8');\n  \n  log('Executando script de criptografia...', 'progress');\n  \n  try {\n    await client.query(sql);\n    log('‚úì Schema de criptografia implementado com sucesso', 'success');\n  } catch (error) {\n    log(`Erro na implementa√ß√£o: ${error.message}`, 'error');\n    throw error;\n  }\n}\n\nasync function verifyEncryptionTables(client) {\n  logSection('VERIFICA√á√ÉO DAS TABELAS DE CRIPTOGRAFIA');\n  \n  const tables = [\n    'tenant_crypto_keys',\n    'tenant_key_history', \n    'crypto_audit_log',\n    'tenant_key_cache',\n    'encryption_config'\n  ];\n  \n  for (const table of tables) {\n    const result = await client.query(`\n      SELECT COUNT(*) as count \n      FROM information_schema.tables \n      WHERE table_name = $1 AND table_schema = 'public'\n    `, [table]);\n    \n    if (result.rows[0].count === '0') {\n      log(`‚úó Tabela ${table} n√£o encontrada`, 'error');\n      throw new Error(`Tabela ${table} n√£o foi criada`);\n    } else {\n      log(`‚úì Tabela ${table} criada`);\n    }\n  }\n}\n\nasync function verifyEncryptionFunctions(client) {\n  logSection('VERIFICA√á√ÉO DAS FUN√á√ïES DE CRIPTOGRAFIA');\n  \n  const functions = [\n    'encrypt_tenant_data',\n    'decrypt_tenant_data',\n    'create_tenant_encryption_keys',\n    'rotate_tenant_key',\n    'generate_crypto_salt',\n    'generate_tenant_master_key'\n  ];\n  \n  for (const func of functions) {\n    const result = await client.query(`\n      SELECT COUNT(*) as count \n      FROM information_schema.routines \n      WHERE routine_name = $1 AND routine_schema = 'public'\n    `, [func]);\n    \n    if (result.rows[0].count === '0') {\n      log(`‚úó Fun√ß√£o ${func} n√£o encontrada`, 'error');\n      throw new Error(`Fun√ß√£o ${func} n√£o foi criada`);\n    } else {\n      log(`‚úì Fun√ß√£o ${func} criada`);\n    }\n  }\n}\n\nasync function testEncryptionFunctionality(client) {\n  logSection('TESTE DE FUNCIONALIDADE DE CRIPTOGRAFIA');\n  \n  try {\n    // Buscar um tenant para teste\n    const tenantResult = await client.query('SELECT id FROM tenants LIMIT 1');\n    \n    if (tenantResult.rows.length === 0) {\n      log('Nenhum tenant encontrado para teste', 'warning');\n      return;\n    }\n    \n    const tenantId = tenantResult.rows[0].id;\n    log(`Testando com tenant: ${tenantId}`);\n    \n    // Verificar se chaves foram criadas\n    const keysResult = await client.query(`\n      SELECT key_purpose, encryption_version, is_active \n      FROM tenant_crypto_keys \n      WHERE tenant_id = $1\n    `, [tenantId]);\n    \n    log(`Chaves encontradas: ${keysResult.rows.length}`);\n    keysResult.rows.forEach(row => {\n      log(`  - ${row.key_purpose}: v${row.encryption_version} (${row.is_active ? 'ativa' : 'inativa'})`);\n    });\n    \n    // Teste de criptografia\n    const testData = 'Dados de teste para criptografia - ' + new Date().toISOString();\n    \n    log('Testando criptografia...', 'progress');\n    const encryptResult = await client.query(`\n      SELECT encrypt_tenant_data($1, $2, 'general') as encrypted_data\n    `, [tenantId, testData]);\n    \n    const encryptedData = encryptResult.rows[0].encrypted_data;\n    log(`‚úì Dados criptografados (${encryptedData.length} chars)`);\n    \n    // Teste de descriptografia\n    log('Testando descriptografia...', 'progress');\n    const decryptResult = await client.query(`\n      SELECT decrypt_tenant_data($1, $2, 'general') as decrypted_data\n    `, [tenantId, encryptedData]);\n    \n    const decryptedData = decryptResult.rows[0].decrypted_data;\n    \n    if (decryptedData === testData) {\n      log('‚úì Teste de criptografia/descriptografia bem-sucedido', 'success');\n    } else {\n      throw new Error('Dados descriptografados n√£o coincidem com os originais');\n    }\n    \n    // Verificar log de auditoria\n    const auditResult = await client.query(`\n      SELECT COUNT(*) as count \n      FROM crypto_audit_log \n      WHERE tenant_id = $1 AND created_at > NOW() - INTERVAL '1 minute'\n    `, [tenantId]);\n    \n    log(`Entradas de auditoria criadas: ${auditResult.rows[0].count}`);\n    \n  } catch (error) {\n    log(`Erro no teste: ${error.message}`, 'error');\n    throw error;\n  }\n}\n\nasync function addEncryptedFieldsToTables(client) {\n  logSection('ADI√á√ÉO DE CAMPOS CRIPTOGRAFADOS √ÄS TABELAS');\n  \n  const tableFields = [\n    {\n      table: 'profiles',\n      fields: [\n        'full_name_encrypted TEXT',\n        'phone_encrypted TEXT',\n        'personal_data_encrypted TEXT'\n      ]\n    },\n    {\n      table: 'audits',\n      fields: [\n        'title_encrypted TEXT',\n        'scope_encrypted TEXT',\n        'objective_encrypted TEXT',\n        'criteria_encrypted TEXT'\n      ]\n    },\n    {\n      table: 'audit_findings',\n      fields: [\n        'title_encrypted TEXT',\n        'description_encrypted TEXT',\n        'evidence_encrypted TEXT',\n        'recommendation_encrypted TEXT'\n      ]\n    },\n    {\n      table: 'risk_assessments',\n      fields: [\n        'title_encrypted TEXT',\n        'description_encrypted TEXT',\n        'executive_summary_encrypted TEXT',\n        'technical_details_encrypted TEXT'\n      ]\n    },\n    {\n      table: 'compliance_records',\n      fields: [\n        'control_description_encrypted TEXT',\n        'evidence_encrypted TEXT',\n        'notes_encrypted TEXT'\n      ]\n    }\n  ];\n  \n  for (const tableConfig of tableFields) {\n    log(`Processando tabela: ${tableConfig.table}`, 'progress');\n    \n    // Verificar se tabela existe\n    const tableExists = await client.query(`\n      SELECT COUNT(*) as count \n      FROM information_schema.tables \n      WHERE table_name = $1 AND table_schema = 'public'\n    `, [tableConfig.table]);\n    \n    if (tableExists.rows[0].count === '0') {\n      log(`‚ö†Ô∏è Tabela ${tableConfig.table} n√£o encontrada, pulando...`, 'warning');\n      continue;\n    }\n    \n    for (const field of tableConfig.fields) {\n      const fieldName = field.split(' ')[0];\n      \n      // Verificar se campo j√° existe\n      const fieldExists = await client.query(`\n        SELECT COUNT(*) as count \n        FROM information_schema.columns \n        WHERE table_name = $1 AND column_name = $2 AND table_schema = 'public'\n      `, [tableConfig.table, fieldName]);\n      \n      if (fieldExists.rows[0].count === '0') {\n        try {\n          await executeSQL(\n            client,\n            `ALTER TABLE ${tableConfig.table} ADD COLUMN ${field}`,\n            `Adicionando campo ${fieldName} √† tabela ${tableConfig.table}`\n          );\n        } catch (error) {\n          log(`‚ö†Ô∏è Erro ao adicionar campo ${fieldName}: ${error.message}`, 'warning');\n        }\n      } else {\n        log(`‚úì Campo ${fieldName} j√° existe na tabela ${tableConfig.table}`);\n      }\n    }\n  }\n}\n\nasync function createEncryptionIndexes(client) {\n  logSection('CRIA√á√ÉO DE √çNDICES PARA CAMPOS CRIPTOGRAFADOS');\n  \n  const indexes = [\n    {\n      name: 'idx_profiles_name_encrypted_hash',\n      table: 'profiles',\n      sql: 'CREATE INDEX IF NOT EXISTS idx_profiles_name_encrypted_hash ON profiles USING btree (digest(COALESCE(full_name_encrypted, \\'\\'), \\'sha256\\')) WHERE full_name_encrypted IS NOT NULL'\n    },\n    {\n      name: 'idx_audits_title_encrypted_hash',\n      table: 'audits', \n      sql: 'CREATE INDEX IF NOT EXISTS idx_audits_title_encrypted_hash ON audits USING btree (digest(COALESCE(title_encrypted, \\'\\'), \\'sha256\\')) WHERE title_encrypted IS NOT NULL'\n    },\n    {\n      name: 'idx_risk_assessments_title_encrypted_hash',\n      table: 'risk_assessments',\n      sql: 'CREATE INDEX IF NOT EXISTS idx_risk_assessments_title_encrypted_hash ON risk_assessments USING btree (digest(COALESCE(title_encrypted, \\'\\'), \\'sha256\\')) WHERE title_encrypted IS NOT NULL'\n    }\n  ];\n  \n  for (const index of indexes) {\n    // Verificar se tabela existe\n    const tableExists = await client.query(`\n      SELECT COUNT(*) as count \n      FROM information_schema.tables \n      WHERE table_name = $1 AND table_schema = 'public'\n    `, [index.table]);\n    \n    if (tableExists.rows[0].count === '0') {\n      log(`‚ö†Ô∏è Tabela ${index.table} n√£o encontrada, pulando √≠ndice...`, 'warning');\n      continue;\n    }\n    \n    try {\n      await executeSQL(client, index.sql, `Criando √≠ndice ${index.name}`);\n    } catch (error) {\n      log(`‚ö†Ô∏è Erro ao criar √≠ndice ${index.name}: ${error.message}`, 'warning');\n    }\n  }\n}\n\nasync function generateEncryptionReport(client) {\n  logSection('RELAT√ìRIO DE IMPLEMENTA√á√ÉO');\n  \n  try {\n    // Estat√≠sticas gerais\n    const stats = await client.query(`\n      SELECT \n        (SELECT COUNT(*) FROM tenants) as total_tenants,\n        (SELECT COUNT(*) FROM tenant_crypto_keys) as total_keys,\n        (SELECT COUNT(DISTINCT tenant_id) FROM tenant_crypto_keys) as tenants_with_keys,\n        (SELECT COUNT(*) FROM crypto_audit_log) as audit_entries,\n        (SELECT COUNT(*) FROM encryption_config WHERE is_active = true) as active_configs\n    `);\n    \n    const data = stats.rows[0];\n    \n    log('üìä ESTAT√çSTICAS DE IMPLEMENTA√á√ÉO:');\n    log(`   ‚Ä¢ Total de tenants: ${data.total_tenants}`);\n    log(`   ‚Ä¢ Total de chaves: ${data.total_keys}`);\n    log(`   ‚Ä¢ Tenants com chaves: ${data.tenants_with_keys}`);\n    log(`   ‚Ä¢ Entradas de auditoria: ${data.audit_entries}`);\n    log(`   ‚Ä¢ Configura√ß√µes ativas: ${data.active_configs}`);\n    \n    // Status por tenant\n    const tenantStatus = await client.query(`\n      SELECT \n        t.name as tenant_name,\n        COUNT(tck.id) as key_count,\n        STRING_AGG(tck.key_purpose, ', ') as purposes\n      FROM tenants t\n      LEFT JOIN tenant_crypto_keys tck ON t.id = tck.tenant_id AND tck.is_active = true\n      GROUP BY t.id, t.name\n      ORDER BY t.name\n    `);\n    \n    log('\\nüè¢ STATUS POR TENANT:');\n    tenantStatus.rows.forEach(row => {\n      log(`   ‚Ä¢ ${row.tenant_name}: ${row.key_count} chaves (${row.purposes || 'nenhuma'})`);\n    });\n    \n    // Configura√ß√µes ativas\n    const configs = await client.query(`\n      SELECT config_key, config_value, description \n      FROM encryption_config \n      WHERE is_active = true \n      ORDER BY config_key\n    `);\n    \n    log('\\n‚öôÔ∏è CONFIGURA√á√ïES ATIVAS:');\n    configs.rows.forEach(row => {\n      log(`   ‚Ä¢ ${row.config_key}: ${row.config_value} (${row.description})`);\n    });\n    \n  } catch (error) {\n    log(`Erro ao gerar relat√≥rio: ${error.message}`, 'error');\n  }\n}\n\n// ============================================================================\n// FUN√á√ÉO PRINCIPAL\n// ============================================================================\n\nasync function main() {\n  const client = new Client(dbConfig);\n  \n  try {\n    log('üîê Iniciando setup do sistema de criptografia por tenant...', 'info');\n    \n    // Conectar ao banco\n    await client.connect();\n    log('‚úì Conectado ao banco de dados', 'success');\n    \n    // 1. Verificar pr√©-requisitos\n    const prereqs = await checkPrerequisites(client);\n    \n    if (!prereqs.extensionsOk) {\n      throw new Error('Extens√µes pgcrypto e uuid-ossp s√£o necess√°rias');\n    }\n    \n    // 2. Implementar schema de criptografia\n    await implementEncryptionSchema(client);\n    \n    // 3. Verificar tabelas criadas\n    await verifyEncryptionTables(client);\n    \n    // 4. Verificar fun√ß√µes criadas\n    await verifyEncryptionFunctions(client);\n    \n    // 5. Adicionar campos criptografados √†s tabelas\n    await addEncryptedFieldsToTables(client);\n    \n    // 6. Criar √≠ndices para busca\n    await createEncryptionIndexes(client);\n    \n    // 7. Testar funcionalidade\n    await testEncryptionFunctionality(client);\n    \n    // 8. Gerar relat√≥rio\n    await generateEncryptionReport(client);\n    \n    logSection('IMPLEMENTA√á√ÉO CONCLU√çDA COM SUCESSO');\n    log('üéâ Sistema de criptografia por tenant implementado!', 'success');\n    log('üìö Consulte a documenta√ß√£o em TENANT_ENCRYPTION_GUIDE.md', 'info');\n    log('üîß Use o middleware TypeScript em src/utils/tenantCrypto.ts', 'info');\n    log('üìä Monitore o sistema atrav√©s das views v_tenant_encryption_status e v_crypto_usage_stats', 'info');\n    \n  } catch (error) {\n    log(`‚ùå Erro durante a implementa√ß√£o: ${error.message}`, 'error');\n    console.error('Stack trace:', error.stack);\n    process.exit(1);\n    \n  } finally {\n    await client.end();\n    log('üîå Desconectado do banco de dados');\n  }\n}\n\n// ============================================================================\n// EXECU√á√ÉO\n// ============================================================================\n\nif (require.main === module) {\n  main().catch(console.error);\n}\n\nmodule.exports = {\n  main,\n  checkPrerequisites,\n  implementEncryptionSchema,\n  testEncryptionFunctionality\n};\n"